// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/identity/v1beta2/import.proto

package identityv1beta2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ImportDigitalTwinsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwinsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwinsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinsRequestMultiError, or nil if none found.
func (m *ImportDigitalTwinsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwinsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetEntities()); l < 1 || l > 1000 {
		err := ImportDigitalTwinsRequestValidationError{
			field:  "Entities",
			reason: "value must contain between 1 and 1000 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if item == nil {
			err := ImportDigitalTwinsRequestValidationError{
				field:  fmt.Sprintf("Entities[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.HashAlgorithm.(type) {

	case *ImportDigitalTwinsRequest_Bcrypt:

		if all {
			switch v := interface{}(m.GetBcrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Bcrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Bcrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBcrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Bcrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_StandardScrypt:

		if all {
			switch v := interface{}(m.GetStandardScrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "StandardScrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "StandardScrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStandardScrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "StandardScrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Scrypt:

		if all {
			switch v := interface{}(m.GetScrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Scrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Scrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Scrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_HmacMd5:

		if all {
			switch v := interface{}(m.GetHmacMd5()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacMd5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacMd5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacMd5()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "HmacMd5",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_HmacSha1:

		if all {
			switch v := interface{}(m.GetHmacSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "HmacSha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_HmacSha512:

		if all {
			switch v := interface{}(m.GetHmacSha512()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha512()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "HmacSha512",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_HmacSha256:

		if all {
			switch v := interface{}(m.GetHmacSha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "HmacSha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "HmacSha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Md5:

		if all {
			switch v := interface{}(m.GetMd5()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Md5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Md5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMd5()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Md5",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Pbkdf2Sha256:

		if all {
			switch v := interface{}(m.GetPbkdf2Sha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Pbkdf2Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Pbkdf2Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPbkdf2Sha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Pbkdf2Sha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_PbkdfSha1:

		if all {
			switch v := interface{}(m.GetPbkdfSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "PbkdfSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "PbkdfSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPbkdfSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "PbkdfSha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Sha1:

		if all {
			switch v := interface{}(m.GetSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Sha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Sha256:

		if all {
			switch v := interface{}(m.GetSha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Sha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinsRequest_Sha512:

		if all {
			switch v := interface{}(m.GetSha512()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsRequestValidationError{
						field:  "Sha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha512()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsRequestValidationError{
					field:  "Sha512",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportDigitalTwinsRequestMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinsRequestMultiError is an error wrapping multiple validation
// errors returned by ImportDigitalTwinsRequest.ValidateAll() if the
// designated constraints aren't met.
type ImportDigitalTwinsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinsRequestMultiError) AllErrors() []error { return m }

// ImportDigitalTwinsRequestValidationError is the validation error returned by
// ImportDigitalTwinsRequest.Validate if the designated constraints aren't met.
type ImportDigitalTwinsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinsRequestValidationError) ErrorName() string {
	return "ImportDigitalTwinsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwinsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinsRequestValidationError{}

// Validate checks the field values on ImportDigitalTwinSuccess with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwinSuccess) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwinSuccess with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinSuccessMultiError, or nil if none found.
func (m *ImportDigitalTwinSuccess) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwinSuccess) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportDigitalTwinSuccessValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportDigitalTwinSuccessValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportDigitalTwinSuccessValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinSuccessValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinSuccessValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinSuccessValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportDigitalTwinSuccessMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinSuccessMultiError is an error wrapping multiple validation
// errors returned by ImportDigitalTwinSuccess.ValidateAll() if the designated
// constraints aren't met.
type ImportDigitalTwinSuccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinSuccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinSuccessMultiError) AllErrors() []error { return m }

// ImportDigitalTwinSuccessValidationError is the validation error returned by
// ImportDigitalTwinSuccess.Validate if the designated constraints aren't met.
type ImportDigitalTwinSuccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinSuccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinSuccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinSuccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinSuccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinSuccessValidationError) ErrorName() string {
	return "ImportDigitalTwinSuccessValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinSuccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwinSuccess.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinSuccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinSuccessValidationError{}

// Validate checks the field values on ImportDigitalTwinError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwinError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwinError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinErrorMultiError, or nil if none found.
func (m *ImportDigitalTwinError) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwinError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ImportDigitalTwinErrorMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinErrorMultiError is an error wrapping multiple validation
// errors returned by ImportDigitalTwinError.ValidateAll() if the designated
// constraints aren't met.
type ImportDigitalTwinErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinErrorMultiError) AllErrors() []error { return m }

// ImportDigitalTwinErrorValidationError is the validation error returned by
// ImportDigitalTwinError.Validate if the designated constraints aren't met.
type ImportDigitalTwinErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinErrorValidationError) ErrorName() string {
	return "ImportDigitalTwinErrorValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwinError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinErrorValidationError{}

// Validate checks the field values on ImportDigitalTwinResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwinResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwinResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinResultMultiError, or nil if none found.
func (m *ImportDigitalTwinResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwinResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	switch m.Result.(type) {

	case *ImportDigitalTwinResult_Success:

		if all {
			switch v := interface{}(m.GetSuccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinResultValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinResultValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinResultValidationError{
					field:  "Success",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportDigitalTwinResult_Error:

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinResultValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinResultValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinResultValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := ImportDigitalTwinResultValidationError{
			field:  "Result",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ImportDigitalTwinResultMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinResultMultiError is an error wrapping multiple validation
// errors returned by ImportDigitalTwinResult.ValidateAll() if the designated
// constraints aren't met.
type ImportDigitalTwinResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinResultMultiError) AllErrors() []error { return m }

// ImportDigitalTwinResultValidationError is the validation error returned by
// ImportDigitalTwinResult.Validate if the designated constraints aren't met.
type ImportDigitalTwinResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinResultValidationError) ErrorName() string {
	return "ImportDigitalTwinResultValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwinResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinResultValidationError{}

// Validate checks the field values on ImportDigitalTwinsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwinsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwinsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinsResponseMultiError, or nil if none found.
func (m *ImportDigitalTwinsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwinsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinsResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinsResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinsResponseValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportDigitalTwinsResponseMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinsResponseMultiError is an error wrapping multiple
// validation errors returned by ImportDigitalTwinsResponse.ValidateAll() if
// the designated constraints aren't met.
type ImportDigitalTwinsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinsResponseMultiError) AllErrors() []error { return m }

// ImportDigitalTwinsResponseValidationError is the validation error returned
// by ImportDigitalTwinsResponse.Validate if the designated constraints aren't met.
type ImportDigitalTwinsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinsResponseValidationError) ErrorName() string {
	return "ImportDigitalTwinsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwinsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinsResponseValidationError{}

// Validate checks the field values on ImportDigitalTwin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportDigitalTwin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportDigitalTwin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportDigitalTwinMultiError, or nil if none found.
func (m *ImportDigitalTwin) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportDigitalTwin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() != "" {

		if l := utf8.RuneCountInString(m.GetId()); l < 27 || l > 100 {
			err := ImportDigitalTwinValidationError{
				field:  "Id",
				reason: "value length must be between 27 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ImportDigitalTwin_Id_Pattern.MatchString(m.GetId()) {
			err := ImportDigitalTwinValidationError{
				field:  "Id",
				reason: "value does not match regex pattern \"^gid:[A-Za-z0-9-_]{27,100}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetTenantId()); l < 27 || l > 100 {
		err := ImportDigitalTwinValidationError{
			field:  "TenantId",
			reason: "value length must be between 27 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ImportDigitalTwin_TenantId_Pattern.MatchString(m.GetTenantId()) {
		err := ImportDigitalTwinValidationError{
			field:  "TenantId",
			reason: "value does not match regex pattern \"^gid:[A-Za-z0-9-_]{27,100}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportDigitalTwin_Kind_InLookup[m.GetKind()]; !ok {
		err := ImportDigitalTwinValidationError{
			field:  "Kind",
			reason: "value must be in list [1 3]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := DigitalTwinKind_name[int32(m.GetKind())]; !ok {
		err := ImportDigitalTwinValidationError{
			field:  "Kind",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ImportDigitalTwin_State_InLookup[m.GetState()]; !ok {
		err := ImportDigitalTwinValidationError{
			field:  "State",
			reason: "value must be in list [1 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := DigitalTwinState_name[int32(m.GetState())]; !ok {
		err := ImportDigitalTwinValidationError{
			field:  "State",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTags()) > 32 {
		err := ImportDigitalTwinValidationError{
			field:  "Tags",
			reason: "value must contain no more than 32 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ImportDigitalTwin_Tags_Unique := make(map[string]struct{}, len(m.GetTags()))

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if _, exists := _ImportDigitalTwin_Tags_Unique[item]; exists {
			err := ImportDigitalTwinValidationError{
				field:  fmt.Sprintf("Tags[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ImportDigitalTwin_Tags_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) > 64 {
			err := ImportDigitalTwinValidationError{
				field:  fmt.Sprintf("Tags[%v]", idx),
				reason: "value length must be at most 64 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ImportDigitalTwin_Tags_Pattern.MatchString(item) {
			err := ImportDigitalTwinValidationError{
				field:  fmt.Sprintf("Tags[%v]", idx),
				reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetPassword()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassword()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportDigitalTwinValidationError{
				field:  "Password",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetProviderUserInfo()) > 10 {
		err := ImportDigitalTwinValidationError{
			field:  "ProviderUserInfo",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetProviderUserInfo() {
		_, _ = idx, item

		if item == nil {
			err := ImportDigitalTwinValidationError{
				field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportDigitalTwinValidationError{
						field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportDigitalTwinValidationError{
						field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportDigitalTwinValidationError{
					field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportDigitalTwinValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportDigitalTwinValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportDigitalTwinValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportDigitalTwinMultiError(errors)
	}

	return nil
}

// ImportDigitalTwinMultiError is an error wrapping multiple validation errors
// returned by ImportDigitalTwin.ValidateAll() if the designated constraints
// aren't met.
type ImportDigitalTwinMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportDigitalTwinMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportDigitalTwinMultiError) AllErrors() []error { return m }

// ImportDigitalTwinValidationError is the validation error returned by
// ImportDigitalTwin.Validate if the designated constraints aren't met.
type ImportDigitalTwinValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportDigitalTwinValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportDigitalTwinValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportDigitalTwinValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportDigitalTwinValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportDigitalTwinValidationError) ErrorName() string {
	return "ImportDigitalTwinValidationError"
}

// Error satisfies the builtin error interface
func (e ImportDigitalTwinValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportDigitalTwin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportDigitalTwinValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportDigitalTwinValidationError{}

var _ImportDigitalTwin_Id_Pattern = regexp.MustCompile("^gid:[A-Za-z0-9-_]{27,100}$")

var _ImportDigitalTwin_TenantId_Pattern = regexp.MustCompile("^gid:[A-Za-z0-9-_]{27,100}$")

var _ImportDigitalTwin_Kind_InLookup = map[DigitalTwinKind]struct{}{
	1: {},
	3: {},
}

var _ImportDigitalTwin_State_InLookup = map[DigitalTwinState]struct{}{
	1: {},
	2: {},
}

var _ImportDigitalTwin_Tags_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

// Validate checks the field values on ImportProperties with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportProperties) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportProperties with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportPropertiesMultiError, or nil if none found.
func (m *ImportProperties) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportProperties) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOperations()) < 1 {
		err := ImportPropertiesValidationError{
			field:  "Operations",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOperations() {
		_, _ = idx, item

		if item == nil {
			err := ImportPropertiesValidationError{
				field:  fmt.Sprintf("Operations[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportPropertiesValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportPropertiesValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportPropertiesValidationError{
					field:  fmt.Sprintf("Operations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ForceDelete

	if len(errors) > 0 {
		return ImportPropertiesMultiError(errors)
	}

	return nil
}

// ImportPropertiesMultiError is an error wrapping multiple validation errors
// returned by ImportProperties.ValidateAll() if the designated constraints
// aren't met.
type ImportPropertiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportPropertiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportPropertiesMultiError) AllErrors() []error { return m }

// ImportPropertiesValidationError is the validation error returned by
// ImportProperties.Validate if the designated constraints aren't met.
type ImportPropertiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportPropertiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportPropertiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportPropertiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportPropertiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportPropertiesValidationError) ErrorName() string { return "ImportPropertiesValidationError" }

// Error satisfies the builtin error interface
func (e ImportPropertiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportProperties.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportPropertiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportPropertiesValidationError{}

// Validate checks the field values on UserMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserMetadataMultiError, or
// nil if none found.
func (m *UserMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreationTimestamp

	// no validation rules for LastLogInTimestamp

	// no validation rules for LastRefreshTimestamp

	if len(errors) > 0 {
		return UserMetadataMultiError(errors)
	}

	return nil
}

// UserMetadataMultiError is an error wrapping multiple validation errors
// returned by UserMetadata.ValidateAll() if the designated constraints aren't met.
type UserMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMetadataMultiError) AllErrors() []error { return m }

// UserMetadataValidationError is the validation error returned by
// UserMetadata.Validate if the designated constraints aren't met.
type UserMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMetadataValidationError) ErrorName() string { return "UserMetadataValidationError" }

// Error satisfies the builtin error interface
func (e UserMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMetadataValidationError{}

// Validate checks the field values on UserProvider with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserProvider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserProvider with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserProviderMultiError, or
// nil if none found.
func (m *UserProvider) ValidateAll() error {
	return m.validate(true)
}

func (m *UserProvider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for ProviderId

	// no validation rules for Email

	// no validation rules for DisplayName

	// no validation rules for PhotoUrl

	if len(errors) > 0 {
		return UserProviderMultiError(errors)
	}

	return nil
}

// UserProviderMultiError is an error wrapping multiple validation errors
// returned by UserProvider.ValidateAll() if the designated constraints aren't met.
type UserProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserProviderMultiError) AllErrors() []error { return m }

// UserProviderValidationError is the validation error returned by
// UserProvider.Validate if the designated constraints aren't met.
type UserProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserProviderValidationError) ErrorName() string { return "UserProviderValidationError" }

// Error satisfies the builtin error interface
func (e UserProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserProvider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserProviderValidationError{}

// Validate checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Email) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmailMultiError, or nil if none found.
func (m *Email) ValidateAll() error {
	return m.validate(true)
}

func (m *Email) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	// no validation rules for Verified

	if len(errors) > 0 {
		return EmailMultiError(errors)
	}

	return nil
}

// EmailMultiError is an error wrapping multiple validation errors returned by
// Email.ValidateAll() if the designated constraints aren't met.
type EmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMultiError) AllErrors() []error { return m }

// EmailValidationError is the validation error returned by Email.Validate if
// the designated constraints aren't met.
type EmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailValidationError) ErrorName() string { return "EmailValidationError" }

// Error satisfies the builtin error interface
func (e EmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailValidationError{}

// Validate checks the field values on Mobile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mobile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mobile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MobileMultiError, or nil if none found.
func (m *Mobile) ValidateAll() error {
	return m.validate(true)
}

func (m *Mobile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMobile() != "" {

		if !_Mobile_Mobile_Pattern.MatchString(m.GetMobile()) {
			err := MobileValidationError{
				field:  "Mobile",
				reason: "value does not match regex pattern \"^+.*[0-9A-Za-z]{7,16}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Verified

	if len(errors) > 0 {
		return MobileMultiError(errors)
	}

	return nil
}

// MobileMultiError is an error wrapping multiple validation errors returned by
// Mobile.ValidateAll() if the designated constraints aren't met.
type MobileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MobileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MobileMultiError) AllErrors() []error { return m }

// MobileValidationError is the validation error returned by Mobile.Validate if
// the designated constraints aren't met.
type MobileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MobileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MobileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MobileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MobileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MobileValidationError) ErrorName() string { return "MobileValidationError" }

// Error satisfies the builtin error interface
func (e MobileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMobile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MobileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MobileValidationError{}

var _Mobile_Mobile_Pattern = regexp.MustCompile("^+.*[0-9A-Za-z]{7,16}$")

// Validate checks the field values on PasswordCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordCredentialMultiError, or nil if none found.
func (m *PasswordCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Uid.(type) {

	case *PasswordCredential_Email:

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PasswordCredential_Mobile:

		if all {
			switch v := interface{}(m.GetMobile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMobile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Mobile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PasswordCredential_Username:
		// no validation rules for Username

	}

	switch m.Password.(type) {

	case *PasswordCredential_Value:
		// no validation rules for Value

	case *PasswordCredential_Hash:

		if all {
			switch v := interface{}(m.GetHash()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Hash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Hash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHash()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Hash",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PasswordCredentialMultiError(errors)
	}

	return nil
}

// PasswordCredentialMultiError is an error wrapping multiple validation errors
// returned by PasswordCredential.ValidateAll() if the designated constraints
// aren't met.
type PasswordCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordCredentialMultiError) AllErrors() []error { return m }

// PasswordCredentialValidationError is the validation error returned by
// PasswordCredential.Validate if the designated constraints aren't met.
type PasswordCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordCredentialValidationError) ErrorName() string {
	return "PasswordCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordCredentialValidationError{}

// Validate checks the field values on PasswordHash with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PasswordHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordHash with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PasswordHashMultiError, or
// nil if none found.
func (m *PasswordHash) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PasswordHash

	// no validation rules for Salt

	if len(errors) > 0 {
		return PasswordHashMultiError(errors)
	}

	return nil
}

// PasswordHashMultiError is an error wrapping multiple validation errors
// returned by PasswordHash.ValidateAll() if the designated constraints aren't met.
type PasswordHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordHashMultiError) AllErrors() []error { return m }

// PasswordHashValidationError is the validation error returned by
// PasswordHash.Validate if the designated constraints aren't met.
type PasswordHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordHashValidationError) ErrorName() string { return "PasswordHashValidationError" }

// Error satisfies the builtin error interface
func (e PasswordHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordHashValidationError{}

// Validate checks the field values on Bcrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bcrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bcrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BcryptMultiError, or nil if none found.
func (m *Bcrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *Bcrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BcryptMultiError(errors)
	}

	return nil
}

// BcryptMultiError is an error wrapping multiple validation errors returned by
// Bcrypt.ValidateAll() if the designated constraints aren't met.
type BcryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BcryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BcryptMultiError) AllErrors() []error { return m }

// BcryptValidationError is the validation error returned by Bcrypt.Validate if
// the designated constraints aren't met.
type BcryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BcryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BcryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BcryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BcryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BcryptValidationError) ErrorName() string { return "BcryptValidationError" }

// Error satisfies the builtin error interface
func (e BcryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBcrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BcryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BcryptValidationError{}

// Validate checks the field values on StandardScrypt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StandardScrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StandardScrypt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StandardScryptMultiError,
// or nil if none found.
func (m *StandardScrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *StandardScrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlockSize

	// no validation rules for DerivedKeyLength

	// no validation rules for MemoryCost

	// no validation rules for Parallelization

	if len(errors) > 0 {
		return StandardScryptMultiError(errors)
	}

	return nil
}

// StandardScryptMultiError is an error wrapping multiple validation errors
// returned by StandardScrypt.ValidateAll() if the designated constraints
// aren't met.
type StandardScryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StandardScryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StandardScryptMultiError) AllErrors() []error { return m }

// StandardScryptValidationError is the validation error returned by
// StandardScrypt.Validate if the designated constraints aren't met.
type StandardScryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StandardScryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StandardScryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StandardScryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StandardScryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StandardScryptValidationError) ErrorName() string { return "StandardScryptValidationError" }

// Error satisfies the builtin error interface
func (e StandardScryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStandardScrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StandardScryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StandardScryptValidationError{}

// Validate checks the field values on Scrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ScryptMultiError, or nil if none found.
func (m *Scrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *Scrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for SaltSeparator

	// no validation rules for Rounds

	// no validation rules for MemoryCost

	if len(errors) > 0 {
		return ScryptMultiError(errors)
	}

	return nil
}

// ScryptMultiError is an error wrapping multiple validation errors returned by
// Scrypt.ValidateAll() if the designated constraints aren't met.
type ScryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScryptMultiError) AllErrors() []error { return m }

// ScryptValidationError is the validation error returned by Scrypt.Validate if
// the designated constraints aren't met.
type ScryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScryptValidationError) ErrorName() string { return "ScryptValidationError" }

// Error satisfies the builtin error interface
func (e ScryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScryptValidationError{}

// Validate checks the field values on HMACMD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACMD5) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACMD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HMACMD5MultiError, or nil if none found.
func (m *HMACMD5) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACMD5) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACMD5MultiError(errors)
	}

	return nil
}

// HMACMD5MultiError is an error wrapping multiple validation errors returned
// by HMACMD5.ValidateAll() if the designated constraints aren't met.
type HMACMD5MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACMD5MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACMD5MultiError) AllErrors() []error { return m }

// HMACMD5ValidationError is the validation error returned by HMACMD5.Validate
// if the designated constraints aren't met.
type HMACMD5ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACMD5ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACMD5ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACMD5ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACMD5ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACMD5ValidationError) ErrorName() string { return "HMACMD5ValidationError" }

// Error satisfies the builtin error interface
func (e HMACMD5ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACMD5.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACMD5ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACMD5ValidationError{}

// Validate checks the field values on HMACSHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA1 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA1MultiError, or nil
// if none found.
func (m *HMACSHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA1MultiError(errors)
	}

	return nil
}

// HMACSHA1MultiError is an error wrapping multiple validation errors returned
// by HMACSHA1.ValidateAll() if the designated constraints aren't met.
type HMACSHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA1MultiError) AllErrors() []error { return m }

// HMACSHA1ValidationError is the validation error returned by
// HMACSHA1.Validate if the designated constraints aren't met.
type HMACSHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA1ValidationError) ErrorName() string { return "HMACSHA1ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA1ValidationError{}

// Validate checks the field values on HMACSHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA512) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA512 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA512MultiError, or
// nil if none found.
func (m *HMACSHA512) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA512) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA512MultiError(errors)
	}

	return nil
}

// HMACSHA512MultiError is an error wrapping multiple validation errors
// returned by HMACSHA512.ValidateAll() if the designated constraints aren't met.
type HMACSHA512MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA512MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA512MultiError) AllErrors() []error { return m }

// HMACSHA512ValidationError is the validation error returned by
// HMACSHA512.Validate if the designated constraints aren't met.
type HMACSHA512ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA512ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA512ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA512ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA512ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA512ValidationError) ErrorName() string { return "HMACSHA512ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA512ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA512.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA512ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA512ValidationError{}

// Validate checks the field values on HMACSHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA256 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA256MultiError, or
// nil if none found.
func (m *HMACSHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA256MultiError(errors)
	}

	return nil
}

// HMACSHA256MultiError is an error wrapping multiple validation errors
// returned by HMACSHA256.ValidateAll() if the designated constraints aren't met.
type HMACSHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA256MultiError) AllErrors() []error { return m }

// HMACSHA256ValidationError is the validation error returned by
// HMACSHA256.Validate if the designated constraints aren't met.
type HMACSHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA256ValidationError) ErrorName() string { return "HMACSHA256ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA256ValidationError{}

// Validate checks the field values on MD5 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *MD5) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MD5MultiError, or nil if none found.
func (m *MD5) ValidateAll() error {
	return m.validate(true)
}

func (m *MD5) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return MD5MultiError(errors)
	}

	return nil
}

// MD5MultiError is an error wrapping multiple validation errors returned by
// MD5.ValidateAll() if the designated constraints aren't met.
type MD5MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MD5MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MD5MultiError) AllErrors() []error { return m }

// MD5ValidationError is the validation error returned by MD5.Validate if the
// designated constraints aren't met.
type MD5ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MD5ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MD5ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MD5ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MD5ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MD5ValidationError) ErrorName() string { return "MD5ValidationError" }

// Error satisfies the builtin error interface
func (e MD5ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMD5.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MD5ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MD5ValidationError{}

// Validate checks the field values on PBKDF2SHA256 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PBKDF2SHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PBKDF2SHA256 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PBKDF2SHA256MultiError, or
// nil if none found.
func (m *PBKDF2SHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *PBKDF2SHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return PBKDF2SHA256MultiError(errors)
	}

	return nil
}

// PBKDF2SHA256MultiError is an error wrapping multiple validation errors
// returned by PBKDF2SHA256.ValidateAll() if the designated constraints aren't met.
type PBKDF2SHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PBKDF2SHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PBKDF2SHA256MultiError) AllErrors() []error { return m }

// PBKDF2SHA256ValidationError is the validation error returned by
// PBKDF2SHA256.Validate if the designated constraints aren't met.
type PBKDF2SHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PBKDF2SHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PBKDF2SHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PBKDF2SHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PBKDF2SHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PBKDF2SHA256ValidationError) ErrorName() string { return "PBKDF2SHA256ValidationError" }

// Error satisfies the builtin error interface
func (e PBKDF2SHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPBKDF2SHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PBKDF2SHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PBKDF2SHA256ValidationError{}

// Validate checks the field values on PBKDFSHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PBKDFSHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PBKDFSHA1 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PBKDFSHA1MultiError, or nil
// if none found.
func (m *PBKDFSHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *PBKDFSHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return PBKDFSHA1MultiError(errors)
	}

	return nil
}

// PBKDFSHA1MultiError is an error wrapping multiple validation errors returned
// by PBKDFSHA1.ValidateAll() if the designated constraints aren't met.
type PBKDFSHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PBKDFSHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PBKDFSHA1MultiError) AllErrors() []error { return m }

// PBKDFSHA1ValidationError is the validation error returned by
// PBKDFSHA1.Validate if the designated constraints aren't met.
type PBKDFSHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PBKDFSHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PBKDFSHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PBKDFSHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PBKDFSHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PBKDFSHA1ValidationError) ErrorName() string { return "PBKDFSHA1ValidationError" }

// Error satisfies the builtin error interface
func (e PBKDFSHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPBKDFSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PBKDFSHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PBKDFSHA1ValidationError{}

// Validate checks the field values on SHA1 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *SHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA1MultiError, or nil if none found.
func (m *SHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA1MultiError(errors)
	}

	return nil
}

// SHA1MultiError is an error wrapping multiple validation errors returned by
// SHA1.ValidateAll() if the designated constraints aren't met.
type SHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA1MultiError) AllErrors() []error { return m }

// SHA1ValidationError is the validation error returned by SHA1.Validate if the
// designated constraints aren't met.
type SHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA1ValidationError) ErrorName() string { return "SHA1ValidationError" }

// Error satisfies the builtin error interface
func (e SHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA1ValidationError{}

// Validate checks the field values on SHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA256MultiError, or nil if none found.
func (m *SHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA256MultiError(errors)
	}

	return nil
}

// SHA256MultiError is an error wrapping multiple validation errors returned by
// SHA256.ValidateAll() if the designated constraints aren't met.
type SHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA256MultiError) AllErrors() []error { return m }

// SHA256ValidationError is the validation error returned by SHA256.Validate if
// the designated constraints aren't met.
type SHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA256ValidationError) ErrorName() string { return "SHA256ValidationError" }

// Error satisfies the builtin error interface
func (e SHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA256ValidationError{}

// Validate checks the field values on SHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SHA512) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA512MultiError, or nil if none found.
func (m *SHA512) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA512) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA512MultiError(errors)
	}

	return nil
}

// SHA512MultiError is an error wrapping multiple validation errors returned by
// SHA512.ValidateAll() if the designated constraints aren't met.
type SHA512MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA512MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA512MultiError) AllErrors() []error { return m }

// SHA512ValidationError is the validation error returned by SHA512.Validate if
// the designated constraints aren't met.
type SHA512ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA512ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA512ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA512ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA512ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA512ValidationError) ErrorName() string { return "SHA512ValidationError" }

// Error satisfies the builtin error interface
func (e SHA512ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA512.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA512ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA512ValidationError{}
