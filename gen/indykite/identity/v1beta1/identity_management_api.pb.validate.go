// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/identity/v1beta1/identity_management_api.proto

package identityv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TokenIntrospectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectRequestMultiError, or nil if none found.
func (m *TokenIntrospectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for Token

	if len(errors) > 0 {
		return TokenIntrospectRequestMultiError(errors)
	}

	return nil
}

// TokenIntrospectRequestMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectRequest.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectRequestMultiError) AllErrors() []error { return m }

// TokenIntrospectRequestValidationError is the validation error returned by
// TokenIntrospectRequest.Validate if the designated constraints aren't met.
type TokenIntrospectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectRequestValidationError) ErrorName() string {
	return "TokenIntrospectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectRequestValidationError{}

// Validate checks the field values on TokenIntrospectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectResponseMultiError, or nil if none found.
func (m *TokenIntrospectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Active

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenIntrospectResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenIntrospectResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenIntrospectResponseValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenIntrospectResponseMultiError(errors)
	}

	return nil
}

// TokenIntrospectResponseMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectResponse.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectResponseMultiError) AllErrors() []error { return m }

// TokenIntrospectResponseValidationError is the validation error returned by
// TokenIntrospectResponse.Validate if the designated constraints aren't met.
type TokenIntrospectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectResponseValidationError) ErrorName() string {
	return "TokenIntrospectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectResponseValidationError{}

// Validate checks the field values on StartForgottenPasswordFlowRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *StartForgottenPasswordFlowRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartForgottenPasswordFlowRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartForgottenPasswordFlowRequestMultiError, or nil if none found.
func (m *StartForgottenPasswordFlowRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartForgottenPasswordFlowRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartForgottenPasswordFlowRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartForgottenPasswordFlowRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartForgottenPasswordFlowRequestValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartForgottenPasswordFlowRequestMultiError(errors)
	}

	return nil
}

// StartForgottenPasswordFlowRequestMultiError is an error wrapping multiple
// validation errors returned by
// StartForgottenPasswordFlowRequest.ValidateAll() if the designated
// constraints aren't met.
type StartForgottenPasswordFlowRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartForgottenPasswordFlowRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartForgottenPasswordFlowRequestMultiError) AllErrors() []error { return m }

// StartForgottenPasswordFlowRequestValidationError is the validation error
// returned by StartForgottenPasswordFlowRequest.Validate if the designated
// constraints aren't met.
type StartForgottenPasswordFlowRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartForgottenPasswordFlowRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartForgottenPasswordFlowRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartForgottenPasswordFlowRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartForgottenPasswordFlowRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartForgottenPasswordFlowRequestValidationError) ErrorName() string {
	return "StartForgottenPasswordFlowRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartForgottenPasswordFlowRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartForgottenPasswordFlowRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartForgottenPasswordFlowRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartForgottenPasswordFlowRequestValidationError{}

// Validate checks the field values on StartForgottenPasswordFlowResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *StartForgottenPasswordFlowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartForgottenPasswordFlowResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// StartForgottenPasswordFlowResponseMultiError, or nil if none found.
func (m *StartForgottenPasswordFlowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartForgottenPasswordFlowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StartForgottenPasswordFlowResponseMultiError(errors)
	}

	return nil
}

// StartForgottenPasswordFlowResponseMultiError is an error wrapping multiple
// validation errors returned by
// StartForgottenPasswordFlowResponse.ValidateAll() if the designated
// constraints aren't met.
type StartForgottenPasswordFlowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartForgottenPasswordFlowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartForgottenPasswordFlowResponseMultiError) AllErrors() []error { return m }

// StartForgottenPasswordFlowResponseValidationError is the validation error
// returned by StartForgottenPasswordFlowResponse.Validate if the designated
// constraints aren't met.
type StartForgottenPasswordFlowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartForgottenPasswordFlowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartForgottenPasswordFlowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartForgottenPasswordFlowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartForgottenPasswordFlowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartForgottenPasswordFlowResponseValidationError) ErrorName() string {
	return "StartForgottenPasswordFlowResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartForgottenPasswordFlowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartForgottenPasswordFlowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartForgottenPasswordFlowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartForgottenPasswordFlowResponseValidationError{}

// Validate checks the field values on ChangePasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePasswordRequestMultiError, or nil if none found.
func (m *ChangePasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Password

	// no validation rules for IgnorePolicy

	switch m.Uid.(type) {

	case *ChangePasswordRequest_Token:
		// no validation rules for Token

	case *ChangePasswordRequest_DigitalTwin:

		if all {
			switch v := interface{}(m.GetDigitalTwin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangePasswordRequestValidationError{
						field:  "DigitalTwin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangePasswordRequestValidationError{
						field:  "DigitalTwin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangePasswordRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChangePasswordRequestMultiError(errors)
	}

	return nil
}

// ChangePasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ChangePasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ChangePasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordRequestMultiError) AllErrors() []error { return m }

// ChangePasswordRequestValidationError is the validation error returned by
// ChangePasswordRequest.Validate if the designated constraints aren't met.
type ChangePasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordRequestValidationError) ErrorName() string {
	return "ChangePasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordRequestValidationError{}

// Validate checks the field values on ChangePasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePasswordResponseMultiError, or nil if none found.
func (m *ChangePasswordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangePasswordResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangePasswordResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangePasswordResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChangePasswordResponseMultiError(errors)
	}

	return nil
}

// ChangePasswordResponseMultiError is an error wrapping multiple validation
// errors returned by ChangePasswordResponse.ValidateAll() if the designated
// constraints aren't met.
type ChangePasswordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordResponseMultiError) AllErrors() []error { return m }

// ChangePasswordResponseValidationError is the validation error returned by
// ChangePasswordResponse.Validate if the designated constraints aren't met.
type ChangePasswordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordResponseValidationError) ErrorName() string {
	return "ChangePasswordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordResponseValidationError{}

// Validate checks the field values on StartDigitalTwinEmailVerificationRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *StartDigitalTwinEmailVerificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// StartDigitalTwinEmailVerificationRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// StartDigitalTwinEmailVerificationRequestMultiError, or nil if none found.
func (m *StartDigitalTwinEmailVerificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDigitalTwinEmailVerificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDigitalTwin() == nil {
		err := StartDigitalTwinEmailVerificationRequestValidationError{
			field:  "DigitalTwin",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDigitalTwinEmailVerificationRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDigitalTwinEmailVerificationRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDigitalTwinEmailVerificationRequestValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = StartDigitalTwinEmailVerificationRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDigitalTwinEmailVerificationRequestValidationError{
					field:  "Attributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDigitalTwinEmailVerificationRequestValidationError{
					field:  "Attributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDigitalTwinEmailVerificationRequestValidationError{
				field:  "Attributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartDigitalTwinEmailVerificationRequestMultiError(errors)
	}

	return nil
}

func (m *StartDigitalTwinEmailVerificationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *StartDigitalTwinEmailVerificationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// StartDigitalTwinEmailVerificationRequestMultiError is an error wrapping
// multiple validation errors returned by
// StartDigitalTwinEmailVerificationRequest.ValidateAll() if the designated
// constraints aren't met.
type StartDigitalTwinEmailVerificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDigitalTwinEmailVerificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDigitalTwinEmailVerificationRequestMultiError) AllErrors() []error { return m }

// StartDigitalTwinEmailVerificationRequestValidationError is the validation
// error returned by StartDigitalTwinEmailVerificationRequest.Validate if the
// designated constraints aren't met.
type StartDigitalTwinEmailVerificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDigitalTwinEmailVerificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDigitalTwinEmailVerificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDigitalTwinEmailVerificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDigitalTwinEmailVerificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDigitalTwinEmailVerificationRequestValidationError) ErrorName() string {
	return "StartDigitalTwinEmailVerificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartDigitalTwinEmailVerificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDigitalTwinEmailVerificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDigitalTwinEmailVerificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDigitalTwinEmailVerificationRequestValidationError{}

// Validate checks the field values on
// StartDigitalTwinEmailVerificationResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StartDigitalTwinEmailVerificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// StartDigitalTwinEmailVerificationResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// StartDigitalTwinEmailVerificationResponseMultiError, or nil if none found.
func (m *StartDigitalTwinEmailVerificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDigitalTwinEmailVerificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StartDigitalTwinEmailVerificationResponseMultiError(errors)
	}

	return nil
}

// StartDigitalTwinEmailVerificationResponseMultiError is an error wrapping
// multiple validation errors returned by
// StartDigitalTwinEmailVerificationResponse.ValidateAll() if the designated
// constraints aren't met.
type StartDigitalTwinEmailVerificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDigitalTwinEmailVerificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDigitalTwinEmailVerificationResponseMultiError) AllErrors() []error { return m }

// StartDigitalTwinEmailVerificationResponseValidationError is the validation
// error returned by StartDigitalTwinEmailVerificationResponse.Validate if the
// designated constraints aren't met.
type StartDigitalTwinEmailVerificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDigitalTwinEmailVerificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDigitalTwinEmailVerificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDigitalTwinEmailVerificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDigitalTwinEmailVerificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDigitalTwinEmailVerificationResponseValidationError) ErrorName() string {
	return "StartDigitalTwinEmailVerificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartDigitalTwinEmailVerificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDigitalTwinEmailVerificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDigitalTwinEmailVerificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDigitalTwinEmailVerificationResponseValidationError{}

// Validate checks the field values on VerifyDigitalTwinEmailRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifyDigitalTwinEmailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyDigitalTwinEmailRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// VerifyDigitalTwinEmailRequestMultiError, or nil if none found.
func (m *VerifyDigitalTwinEmailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyDigitalTwinEmailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return VerifyDigitalTwinEmailRequestMultiError(errors)
	}

	return nil
}

// VerifyDigitalTwinEmailRequestMultiError is an error wrapping multiple
// validation errors returned by VerifyDigitalTwinEmailRequest.ValidateAll()
// if the designated constraints aren't met.
type VerifyDigitalTwinEmailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyDigitalTwinEmailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyDigitalTwinEmailRequestMultiError) AllErrors() []error { return m }

// VerifyDigitalTwinEmailRequestValidationError is the validation error
// returned by VerifyDigitalTwinEmailRequest.Validate if the designated
// constraints aren't met.
type VerifyDigitalTwinEmailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyDigitalTwinEmailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyDigitalTwinEmailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyDigitalTwinEmailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyDigitalTwinEmailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyDigitalTwinEmailRequestValidationError) ErrorName() string {
	return "VerifyDigitalTwinEmailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerifyDigitalTwinEmailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyDigitalTwinEmailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyDigitalTwinEmailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyDigitalTwinEmailRequestValidationError{}

// Validate checks the field values on VerifyDigitalTwinEmailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifyDigitalTwinEmailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifyDigitalTwinEmailResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// VerifyDigitalTwinEmailResponseMultiError, or nil if none found.
func (m *VerifyDigitalTwinEmailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifyDigitalTwinEmailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifyDigitalTwinEmailResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifyDigitalTwinEmailResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifyDigitalTwinEmailResponseValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifyDigitalTwinEmailResponseMultiError(errors)
	}

	return nil
}

// VerifyDigitalTwinEmailResponseMultiError is an error wrapping multiple
// validation errors returned by VerifyDigitalTwinEmailResponse.ValidateAll()
// if the designated constraints aren't met.
type VerifyDigitalTwinEmailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifyDigitalTwinEmailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifyDigitalTwinEmailResponseMultiError) AllErrors() []error { return m }

// VerifyDigitalTwinEmailResponseValidationError is the validation error
// returned by VerifyDigitalTwinEmailResponse.Validate if the designated
// constraints aren't met.
type VerifyDigitalTwinEmailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifyDigitalTwinEmailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifyDigitalTwinEmailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifyDigitalTwinEmailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifyDigitalTwinEmailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifyDigitalTwinEmailResponseValidationError) ErrorName() string {
	return "VerifyDigitalTwinEmailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e VerifyDigitalTwinEmailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifyDigitalTwinEmailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifyDigitalTwinEmailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifyDigitalTwinEmailResponseValidationError{}

// Validate checks the field values on SelfServiceTerminateSessionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SelfServiceTerminateSessionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelfServiceTerminateSessionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SelfServiceTerminateSessionRequestMultiError, or nil if none found.
func (m *SelfServiceTerminateSessionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SelfServiceTerminateSessionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefreshToken

	if len(errors) > 0 {
		return SelfServiceTerminateSessionRequestMultiError(errors)
	}

	return nil
}

// SelfServiceTerminateSessionRequestMultiError is an error wrapping multiple
// validation errors returned by
// SelfServiceTerminateSessionRequest.ValidateAll() if the designated
// constraints aren't met.
type SelfServiceTerminateSessionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelfServiceTerminateSessionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelfServiceTerminateSessionRequestMultiError) AllErrors() []error { return m }

// SelfServiceTerminateSessionRequestValidationError is the validation error
// returned by SelfServiceTerminateSessionRequest.Validate if the designated
// constraints aren't met.
type SelfServiceTerminateSessionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelfServiceTerminateSessionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelfServiceTerminateSessionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelfServiceTerminateSessionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelfServiceTerminateSessionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelfServiceTerminateSessionRequestValidationError) ErrorName() string {
	return "SelfServiceTerminateSessionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SelfServiceTerminateSessionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelfServiceTerminateSessionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelfServiceTerminateSessionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelfServiceTerminateSessionRequestValidationError{}

// Validate checks the field values on SelfServiceTerminateSessionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SelfServiceTerminateSessionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelfServiceTerminateSessionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SelfServiceTerminateSessionResponseMultiError, or nil if none found.
func (m *SelfServiceTerminateSessionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SelfServiceTerminateSessionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SelfServiceTerminateSessionResponseMultiError(errors)
	}

	return nil
}

// SelfServiceTerminateSessionResponseMultiError is an error wrapping multiple
// validation errors returned by
// SelfServiceTerminateSessionResponse.ValidateAll() if the designated
// constraints aren't met.
type SelfServiceTerminateSessionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelfServiceTerminateSessionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelfServiceTerminateSessionResponseMultiError) AllErrors() []error { return m }

// SelfServiceTerminateSessionResponseValidationError is the validation error
// returned by SelfServiceTerminateSessionResponse.Validate if the designated
// constraints aren't met.
type SelfServiceTerminateSessionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelfServiceTerminateSessionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelfServiceTerminateSessionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelfServiceTerminateSessionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelfServiceTerminateSessionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelfServiceTerminateSessionResponseValidationError) ErrorName() string {
	return "SelfServiceTerminateSessionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SelfServiceTerminateSessionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelfServiceTerminateSessionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelfServiceTerminateSessionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelfServiceTerminateSessionResponseValidationError{}

// Validate checks the field values on DigitalTwinIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DigitalTwinIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DigitalTwinIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DigitalTwinIdentifierMultiError, or nil if none found.
func (m *DigitalTwinIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *DigitalTwinIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Filter.(type) {

	case *DigitalTwinIdentifier_DigitalTwin:

		if m.GetDigitalTwin() == nil {
			err := DigitalTwinIdentifierValidationError{
				field:  "DigitalTwin",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDigitalTwin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DigitalTwinIdentifierValidationError{
						field:  "DigitalTwin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DigitalTwinIdentifierValidationError{
						field:  "DigitalTwin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DigitalTwinIdentifierValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DigitalTwinIdentifier_Property:

		if m.GetProperty() == nil {
			err := DigitalTwinIdentifierValidationError{
				field:  "Property",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProperty()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DigitalTwinIdentifierValidationError{
						field:  "Property",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DigitalTwinIdentifierValidationError{
						field:  "Property",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProperty()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DigitalTwinIdentifierValidationError{
					field:  "Property",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DigitalTwinIdentifier_AccessToken:

		if utf8.RuneCountInString(m.GetAccessToken()) < 20 {
			err := DigitalTwinIdentifierValidationError{
				field:  "AccessToken",
				reason: "value length must be at least 20 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		err := DigitalTwinIdentifierValidationError{
			field:  "Filter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return DigitalTwinIdentifierMultiError(errors)
	}

	return nil
}

// DigitalTwinIdentifierMultiError is an error wrapping multiple validation
// errors returned by DigitalTwinIdentifier.ValidateAll() if the designated
// constraints aren't met.
type DigitalTwinIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DigitalTwinIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DigitalTwinIdentifierMultiError) AllErrors() []error { return m }

// DigitalTwinIdentifierValidationError is the validation error returned by
// DigitalTwinIdentifier.Validate if the designated constraints aren't met.
type DigitalTwinIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DigitalTwinIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DigitalTwinIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DigitalTwinIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DigitalTwinIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DigitalTwinIdentifierValidationError) ErrorName() string {
	return "DigitalTwinIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e DigitalTwinIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDigitalTwinIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DigitalTwinIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DigitalTwinIdentifierValidationError{}

// Validate checks the field values on GetDigitalTwinRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDigitalTwinRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDigitalTwinRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDigitalTwinRequestMultiError, or nil if none found.
func (m *GetDigitalTwinRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDigitalTwinRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := GetDigitalTwinRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDigitalTwinRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetProperties()) > 0 {

		for idx, item := range m.GetProperties() {
			_, _ = idx, item

			if item == nil {
				err := GetDigitalTwinRequestValidationError{
					field:  fmt.Sprintf("Properties[%v]", idx),
					reason: "value is required",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(item).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetDigitalTwinRequestValidationError{
							field:  fmt.Sprintf("Properties[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetDigitalTwinRequestValidationError{
							field:  fmt.Sprintf("Properties[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetDigitalTwinRequestValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}

	}

	if len(errors) > 0 {
		return GetDigitalTwinRequestMultiError(errors)
	}

	return nil
}

// GetDigitalTwinRequestMultiError is an error wrapping multiple validation
// errors returned by GetDigitalTwinRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDigitalTwinRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDigitalTwinRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDigitalTwinRequestMultiError) AllErrors() []error { return m }

// GetDigitalTwinRequestValidationError is the validation error returned by
// GetDigitalTwinRequest.Validate if the designated constraints aren't met.
type GetDigitalTwinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDigitalTwinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDigitalTwinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDigitalTwinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDigitalTwinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDigitalTwinRequestValidationError) ErrorName() string {
	return "GetDigitalTwinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDigitalTwinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDigitalTwinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDigitalTwinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDigitalTwinRequestValidationError{}

// Validate checks the field values on GetDigitalTwinResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDigitalTwinResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDigitalTwinResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDigitalTwinResponseMultiError, or nil if none found.
func (m *GetDigitalTwinResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDigitalTwinResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDigitalTwinResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDigitalTwinResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDigitalTwinResponseValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDigitalTwinResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDigitalTwinResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDigitalTwinResponseValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDigitalTwinResponseMultiError(errors)
	}

	return nil
}

// GetDigitalTwinResponseMultiError is an error wrapping multiple validation
// errors returned by GetDigitalTwinResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDigitalTwinResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDigitalTwinResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDigitalTwinResponseMultiError) AllErrors() []error { return m }

// GetDigitalTwinResponseValidationError is the validation error returned by
// GetDigitalTwinResponse.Validate if the designated constraints aren't met.
type GetDigitalTwinResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDigitalTwinResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDigitalTwinResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDigitalTwinResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDigitalTwinResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDigitalTwinResponseValidationError) ErrorName() string {
	return "GetDigitalTwinResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDigitalTwinResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDigitalTwinResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDigitalTwinResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDigitalTwinResponseValidationError{}

// Validate checks the field values on ListDigitalTwinsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDigitalTwinsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDigitalTwinsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDigitalTwinsRequestMultiError, or nil if none found.
func (m *ListDigitalTwinsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDigitalTwinsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetTenantId()) != 16 {
		err := ListDigitalTwinsRequestValidationError{
			field:  "TenantId",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CollectionId

	// no validation rules for PageSize

	// no validation rules for PageToken

	// no validation rules for OrderBy

	for idx, item := range m.GetProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDigitalTwinsRequestValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDigitalTwinsRequestValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDigitalTwinsRequestValidationError{
					field:  fmt.Sprintf("Properties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDigitalTwinsRequestMultiError(errors)
	}

	return nil
}

// ListDigitalTwinsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDigitalTwinsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDigitalTwinsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDigitalTwinsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDigitalTwinsRequestMultiError) AllErrors() []error { return m }

// ListDigitalTwinsRequestValidationError is the validation error returned by
// ListDigitalTwinsRequest.Validate if the designated constraints aren't met.
type ListDigitalTwinsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDigitalTwinsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDigitalTwinsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDigitalTwinsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDigitalTwinsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDigitalTwinsRequestValidationError) ErrorName() string {
	return "ListDigitalTwinsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDigitalTwinsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDigitalTwinsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDigitalTwinsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDigitalTwinsRequestValidationError{}

// Validate checks the field values on ListDigitalTwinsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDigitalTwinsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDigitalTwinsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDigitalTwinsResponseMultiError, or nil if none found.
func (m *ListDigitalTwinsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDigitalTwinsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDigitalTwin() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDigitalTwinsResponseValidationError{
						field:  fmt.Sprintf("DigitalTwin[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDigitalTwinsResponseValidationError{
						field:  fmt.Sprintf("DigitalTwin[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDigitalTwinsResponseValidationError{
					field:  fmt.Sprintf("DigitalTwin[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListDigitalTwinsResponseMultiError(errors)
	}

	return nil
}

// ListDigitalTwinsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDigitalTwinsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDigitalTwinsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDigitalTwinsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDigitalTwinsResponseMultiError) AllErrors() []error { return m }

// ListDigitalTwinsResponseValidationError is the validation error returned by
// ListDigitalTwinsResponse.Validate if the designated constraints aren't met.
type ListDigitalTwinsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDigitalTwinsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDigitalTwinsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDigitalTwinsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDigitalTwinsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDigitalTwinsResponseValidationError) ErrorName() string {
	return "ListDigitalTwinsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDigitalTwinsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDigitalTwinsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDigitalTwinsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDigitalTwinsResponseValidationError{}

// Validate checks the field values on PatchDigitalTwinRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchDigitalTwinRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PatchDigitalTwinRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchDigitalTwinRequestMultiError, or nil if none found.
func (m *PatchDigitalTwinRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PatchDigitalTwinRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := PatchDigitalTwinRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PatchDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PatchDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PatchDigitalTwinRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetOperations()) < 1 {
		err := PatchDigitalTwinRequestValidationError{
			field:  "Operations",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOperations() {
		_, _ = idx, item

		if item == nil {
			err := PatchDigitalTwinRequestValidationError{
				field:  fmt.Sprintf("Operations[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PatchDigitalTwinRequestValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PatchDigitalTwinRequestValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PatchDigitalTwinRequestValidationError{
					field:  fmt.Sprintf("Operations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AdminToken

	// no validation rules for ForceDelete

	if len(errors) > 0 {
		return PatchDigitalTwinRequestMultiError(errors)
	}

	return nil
}

// PatchDigitalTwinRequestMultiError is an error wrapping multiple validation
// errors returned by PatchDigitalTwinRequest.ValidateAll() if the designated
// constraints aren't met.
type PatchDigitalTwinRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchDigitalTwinRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PatchDigitalTwinRequestMultiError) AllErrors() []error { return m }

// PatchDigitalTwinRequestValidationError is the validation error returned by
// PatchDigitalTwinRequest.Validate if the designated constraints aren't met.
type PatchDigitalTwinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PatchDigitalTwinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PatchDigitalTwinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PatchDigitalTwinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PatchDigitalTwinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PatchDigitalTwinRequestValidationError) ErrorName() string {
	return "PatchDigitalTwinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PatchDigitalTwinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPatchDigitalTwinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PatchDigitalTwinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PatchDigitalTwinRequestValidationError{}

// Validate checks the field values on PatchDigitalTwinResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PatchDigitalTwinResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PatchDigitalTwinResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PatchDigitalTwinResponseMultiError, or nil if none found.
func (m *PatchDigitalTwinResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PatchDigitalTwinResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResult() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PatchDigitalTwinResponseValidationError{
						field:  fmt.Sprintf("Result[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PatchDigitalTwinResponseValidationError{
						field:  fmt.Sprintf("Result[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PatchDigitalTwinResponseValidationError{
					field:  fmt.Sprintf("Result[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PatchDigitalTwinResponseMultiError(errors)
	}

	return nil
}

// PatchDigitalTwinResponseMultiError is an error wrapping multiple validation
// errors returned by PatchDigitalTwinResponse.ValidateAll() if the designated
// constraints aren't met.
type PatchDigitalTwinResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PatchDigitalTwinResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PatchDigitalTwinResponseMultiError) AllErrors() []error { return m }

// PatchDigitalTwinResponseValidationError is the validation error returned by
// PatchDigitalTwinResponse.Validate if the designated constraints aren't met.
type PatchDigitalTwinResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PatchDigitalTwinResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PatchDigitalTwinResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PatchDigitalTwinResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PatchDigitalTwinResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PatchDigitalTwinResponseValidationError) ErrorName() string {
	return "PatchDigitalTwinResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PatchDigitalTwinResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPatchDigitalTwinResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PatchDigitalTwinResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PatchDigitalTwinResponseValidationError{}

// Validate checks the field values on DeleteDigitalTwinRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDigitalTwinRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDigitalTwinRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDigitalTwinRequestMultiError, or nil if none found.
func (m *DeleteDigitalTwinRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDigitalTwinRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := DeleteDigitalTwinRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDigitalTwinRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDigitalTwinRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AdminToken

	if len(errors) > 0 {
		return DeleteDigitalTwinRequestMultiError(errors)
	}

	return nil
}

// DeleteDigitalTwinRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDigitalTwinRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDigitalTwinRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDigitalTwinRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDigitalTwinRequestMultiError) AllErrors() []error { return m }

// DeleteDigitalTwinRequestValidationError is the validation error returned by
// DeleteDigitalTwinRequest.Validate if the designated constraints aren't met.
type DeleteDigitalTwinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDigitalTwinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDigitalTwinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDigitalTwinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDigitalTwinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDigitalTwinRequestValidationError) ErrorName() string {
	return "DeleteDigitalTwinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDigitalTwinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDigitalTwinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDigitalTwinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDigitalTwinRequestValidationError{}

// Validate checks the field values on DeleteDigitalTwinResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDigitalTwinResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDigitalTwinResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDigitalTwinResponseMultiError, or nil if none found.
func (m *DeleteDigitalTwinResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDigitalTwinResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDigitalTwinResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDigitalTwinResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDigitalTwinResponseValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteDigitalTwinResponseMultiError(errors)
	}

	return nil
}

// DeleteDigitalTwinResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDigitalTwinResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteDigitalTwinResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDigitalTwinResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDigitalTwinResponseMultiError) AllErrors() []error { return m }

// DeleteDigitalTwinResponseValidationError is the validation error returned by
// DeleteDigitalTwinResponse.Validate if the designated constraints aren't met.
type DeleteDigitalTwinResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDigitalTwinResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDigitalTwinResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDigitalTwinResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDigitalTwinResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDigitalTwinResponseValidationError) ErrorName() string {
	return "DeleteDigitalTwinResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDigitalTwinResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDigitalTwinResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDigitalTwinResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDigitalTwinResponseValidationError{}

// Validate checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentRequestMultiError, or nil if none found.
func (m *GetDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDocumentRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDocumentRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDocumentRequestValidationError{
				field:  "Mask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDocumentRequestMultiError(errors)
	}

	return nil
}

// GetDocumentRequestMultiError is an error wrapping multiple validation errors
// returned by GetDocumentRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentRequestMultiError) AllErrors() []error { return m }

// GetDocumentRequestValidationError is the validation error returned by
// GetDocumentRequest.Validate if the designated constraints aren't met.
type GetDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentRequestValidationError) ErrorName() string {
	return "GetDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentRequestValidationError{}

// Validate checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentResponseMultiError, or nil if none found.
func (m *GetDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDocumentResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDocumentResponseMultiError(errors)
	}

	return nil
}

// GetDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by GetDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentResponseMultiError) AllErrors() []error { return m }

// GetDocumentResponseValidationError is the validation error returned by
// GetDocumentResponse.Validate if the designated constraints aren't met.
type GetDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentResponseValidationError) ErrorName() string {
	return "GetDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentResponseValidationError{}

// Validate checks the field values on BatchGetDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetDocumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetDocumentsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetDocumentsRequestMultiError, or nil if none found.
func (m *BatchGetDocumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetDocumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Database

	if all {
		switch v := interface{}(m.GetMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetDocumentsRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetDocumentsRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetDocumentsRequestValidationError{
				field:  "Mask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchGetDocumentsRequestMultiError(errors)
	}

	return nil
}

// BatchGetDocumentsRequestMultiError is an error wrapping multiple validation
// errors returned by BatchGetDocumentsRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchGetDocumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetDocumentsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetDocumentsRequestMultiError) AllErrors() []error { return m }

// BatchGetDocumentsRequestValidationError is the validation error returned by
// BatchGetDocumentsRequest.Validate if the designated constraints aren't met.
type BatchGetDocumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetDocumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetDocumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetDocumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetDocumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetDocumentsRequestValidationError) ErrorName() string {
	return "BatchGetDocumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetDocumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetDocumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetDocumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetDocumentsRequestValidationError{}

// Validate checks the field values on BatchGetDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetDocumentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetDocumentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetDocumentsResponseMultiError, or nil if none found.
func (m *BatchGetDocumentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetDocumentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Result.(type) {

	case *BatchGetDocumentsResponse_Found:

		if all {
			switch v := interface{}(m.GetFound()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetDocumentsResponseValidationError{
						field:  "Found",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetDocumentsResponseValidationError{
						field:  "Found",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFound()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetDocumentsResponseValidationError{
					field:  "Found",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BatchGetDocumentsResponse_Missing:
		// no validation rules for Missing

	}

	if len(errors) > 0 {
		return BatchGetDocumentsResponseMultiError(errors)
	}

	return nil
}

// BatchGetDocumentsResponseMultiError is an error wrapping multiple validation
// errors returned by BatchGetDocumentsResponse.ValidateAll() if the
// designated constraints aren't met.
type BatchGetDocumentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetDocumentsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetDocumentsResponseMultiError) AllErrors() []error { return m }

// BatchGetDocumentsResponseValidationError is the validation error returned by
// BatchGetDocumentsResponse.Validate if the designated constraints aren't met.
type BatchGetDocumentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetDocumentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetDocumentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetDocumentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetDocumentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetDocumentsResponseValidationError) ErrorName() string {
	return "BatchGetDocumentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetDocumentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetDocumentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetDocumentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetDocumentsResponseValidationError{}

// Validate checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsRequestMultiError, or nil if none found.
func (m *ListDocumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for CollectionId

	// no validation rules for PageSize

	// no validation rules for PageToken

	// no validation rules for OrderBy

	if all {
		switch v := interface{}(m.GetMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDocumentsRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDocumentsRequestValidationError{
					field:  "Mask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDocumentsRequestValidationError{
				field:  "Mask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListDocumentsRequestMultiError(errors)
	}

	return nil
}

// ListDocumentsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsRequestMultiError) AllErrors() []error { return m }

// ListDocumentsRequestValidationError is the validation error returned by
// ListDocumentsRequest.Validate if the designated constraints aren't met.
type ListDocumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsRequestValidationError) ErrorName() string {
	return "ListDocumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsRequestValidationError{}

// Validate checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsResponseMultiError, or nil if none found.
func (m *ListDocumentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDocuments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDocumentsResponseValidationError{
					field:  fmt.Sprintf("Documents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListDocumentsResponseMultiError(errors)
	}

	return nil
}

// ListDocumentsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsResponseMultiError) AllErrors() []error { return m }

// ListDocumentsResponseValidationError is the validation error returned by
// ListDocumentsResponse.Validate if the designated constraints aren't met.
type ListDocumentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsResponseValidationError) ErrorName() string {
	return "ListDocumentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsResponseValidationError{}

// Validate checks the field values on MutateDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MutateDocumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MutateDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MutateDocumentsRequestMultiError, or nil if none found.
func (m *MutateDocumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MutateDocumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Database

	for idx, item := range m.GetWrites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MutateDocumentsRequestValidationError{
						field:  fmt.Sprintf("Writes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MutateDocumentsRequestValidationError{
						field:  fmt.Sprintf("Writes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MutateDocumentsRequestValidationError{
					field:  fmt.Sprintf("Writes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MutateDocumentsRequestMultiError(errors)
	}

	return nil
}

// MutateDocumentsRequestMultiError is an error wrapping multiple validation
// errors returned by MutateDocumentsRequest.ValidateAll() if the designated
// constraints aren't met.
type MutateDocumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MutateDocumentsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MutateDocumentsRequestMultiError) AllErrors() []error { return m }

// MutateDocumentsRequestValidationError is the validation error returned by
// MutateDocumentsRequest.Validate if the designated constraints aren't met.
type MutateDocumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MutateDocumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MutateDocumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MutateDocumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MutateDocumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MutateDocumentsRequestValidationError) ErrorName() string {
	return "MutateDocumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MutateDocumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMutateDocumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MutateDocumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MutateDocumentsRequestValidationError{}

// Validate checks the field values on MutateDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MutateDocumentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MutateDocumentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MutateDocumentsResponseMultiError, or nil if none found.
func (m *MutateDocumentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MutateDocumentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWriteResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MutateDocumentsResponseValidationError{
						field:  fmt.Sprintf("WriteResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MutateDocumentsResponseValidationError{
						field:  fmt.Sprintf("WriteResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MutateDocumentsResponseValidationError{
					field:  fmt.Sprintf("WriteResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MutateDocumentsResponseMultiError(errors)
	}

	return nil
}

// MutateDocumentsResponseMultiError is an error wrapping multiple validation
// errors returned by MutateDocumentsResponse.ValidateAll() if the designated
// constraints aren't met.
type MutateDocumentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MutateDocumentsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MutateDocumentsResponseMultiError) AllErrors() []error { return m }

// MutateDocumentsResponseValidationError is the validation error returned by
// MutateDocumentsResponse.Validate if the designated constraints aren't met.
type MutateDocumentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MutateDocumentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MutateDocumentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MutateDocumentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MutateDocumentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MutateDocumentsResponseValidationError) ErrorName() string {
	return "MutateDocumentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MutateDocumentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMutateDocumentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MutateDocumentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MutateDocumentsResponseValidationError{}

// Validate checks the field values on RunQueryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RunQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunQueryRequestMultiError, or nil if none found.
func (m *RunQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	switch m.QueryType.(type) {

	case *RunQueryRequest_StructuredQuery:

		if all {
			switch v := interface{}(m.GetStructuredQuery()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RunQueryRequestValidationError{
						field:  "StructuredQuery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RunQueryRequestValidationError{
						field:  "StructuredQuery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStructuredQuery()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RunQueryRequestValidationError{
					field:  "StructuredQuery",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RunQueryRequestMultiError(errors)
	}

	return nil
}

// RunQueryRequestMultiError is an error wrapping multiple validation errors
// returned by RunQueryRequest.ValidateAll() if the designated constraints
// aren't met.
type RunQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunQueryRequestMultiError) AllErrors() []error { return m }

// RunQueryRequestValidationError is the validation error returned by
// RunQueryRequest.Validate if the designated constraints aren't met.
type RunQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunQueryRequestValidationError) ErrorName() string { return "RunQueryRequestValidationError" }

// Error satisfies the builtin error interface
func (e RunQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunQueryRequestValidationError{}

// Validate checks the field values on RunQueryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RunQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunQueryResponseMultiError, or nil if none found.
func (m *RunQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RunQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunQueryResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunQueryResponseValidationError{
					field:  "Document",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunQueryResponseValidationError{
				field:  "Document",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SkippedResults

	if len(errors) > 0 {
		return RunQueryResponseMultiError(errors)
	}

	return nil
}

// RunQueryResponseMultiError is an error wrapping multiple validation errors
// returned by RunQueryResponse.ValidateAll() if the designated constraints
// aren't met.
type RunQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunQueryResponseMultiError) AllErrors() []error { return m }

// RunQueryResponseValidationError is the validation error returned by
// RunQueryResponse.Validate if the designated constraints aren't met.
type RunQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunQueryResponseValidationError) ErrorName() string { return "RunQueryResponseValidationError" }

// Error satisfies the builtin error interface
func (e RunQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunQueryResponseValidationError{}

// Validate checks the field values on GetPasswordCredentialRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPasswordCredentialRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPasswordCredentialRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPasswordCredentialRequestMultiError, or nil if none found.
func (m *GetPasswordCredentialRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPasswordCredentialRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPasswordCredentialRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPasswordCredentialRequestValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPasswordCredentialRequestValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPasswordCredentialRequestMultiError(errors)
	}

	return nil
}

// GetPasswordCredentialRequestMultiError is an error wrapping multiple
// validation errors returned by GetPasswordCredentialRequest.ValidateAll() if
// the designated constraints aren't met.
type GetPasswordCredentialRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPasswordCredentialRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPasswordCredentialRequestMultiError) AllErrors() []error { return m }

// GetPasswordCredentialRequestValidationError is the validation error returned
// by GetPasswordCredentialRequest.Validate if the designated constraints
// aren't met.
type GetPasswordCredentialRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPasswordCredentialRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPasswordCredentialRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPasswordCredentialRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPasswordCredentialRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPasswordCredentialRequestValidationError) ErrorName() string {
	return "GetPasswordCredentialRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetPasswordCredentialRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPasswordCredentialRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPasswordCredentialRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPasswordCredentialRequestValidationError{}

// Validate checks the field values on GetPasswordCredentialResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPasswordCredentialResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPasswordCredentialResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPasswordCredentialResponseMultiError, or nil if none found.
func (m *GetPasswordCredentialResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPasswordCredentialResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetPasswordCredentialResponseMultiError(errors)
	}

	return nil
}

// GetPasswordCredentialResponseMultiError is an error wrapping multiple
// validation errors returned by GetPasswordCredentialResponse.ValidateAll()
// if the designated constraints aren't met.
type GetPasswordCredentialResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPasswordCredentialResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPasswordCredentialResponseMultiError) AllErrors() []error { return m }

// GetPasswordCredentialResponseValidationError is the validation error
// returned by GetPasswordCredentialResponse.Validate if the designated
// constraints aren't met.
type GetPasswordCredentialResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPasswordCredentialResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPasswordCredentialResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPasswordCredentialResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPasswordCredentialResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPasswordCredentialResponseValidationError) ErrorName() string {
	return "GetPasswordCredentialResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPasswordCredentialResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPasswordCredentialResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPasswordCredentialResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPasswordCredentialResponseValidationError{}

// Validate checks the field values on UpdatePasswordCredentialRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePasswordCredentialRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordCredentialRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdatePasswordCredentialRequestMultiError, or nil if none found.
func (m *UpdatePasswordCredentialRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordCredentialRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMustChange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePasswordCredentialRequestValidationError{
					field:  "MustChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePasswordCredentialRequestValidationError{
					field:  "MustChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMustChange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePasswordCredentialRequestValidationError{
				field:  "MustChange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLocked()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePasswordCredentialRequestValidationError{
					field:  "Locked",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePasswordCredentialRequestValidationError{
					field:  "Locked",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocked()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePasswordCredentialRequestValidationError{
				field:  "Locked",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.Primary.(type) {

	case *UpdatePasswordCredentialRequest_Email:
		// no validation rules for Email

	case *UpdatePasswordCredentialRequest_Mobile:
		// no validation rules for Mobile

	}

	if len(errors) > 0 {
		return UpdatePasswordCredentialRequestMultiError(errors)
	}

	return nil
}

// UpdatePasswordCredentialRequestMultiError is an error wrapping multiple
// validation errors returned by UpdatePasswordCredentialRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdatePasswordCredentialRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordCredentialRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordCredentialRequestMultiError) AllErrors() []error { return m }

// UpdatePasswordCredentialRequestValidationError is the validation error
// returned by UpdatePasswordCredentialRequest.Validate if the designated
// constraints aren't met.
type UpdatePasswordCredentialRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordCredentialRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordCredentialRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordCredentialRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordCredentialRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordCredentialRequestValidationError) ErrorName() string {
	return "UpdatePasswordCredentialRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordCredentialRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordCredentialRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordCredentialRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordCredentialRequestValidationError{}

// Validate checks the field values on UpdatePasswordCredentialResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdatePasswordCredentialResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePasswordCredentialResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdatePasswordCredentialResponseMultiError, or nil if none found.
func (m *UpdatePasswordCredentialResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePasswordCredentialResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePasswordCredentialResponseMultiError(errors)
	}

	return nil
}

// UpdatePasswordCredentialResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdatePasswordCredentialResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePasswordCredentialResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePasswordCredentialResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePasswordCredentialResponseMultiError) AllErrors() []error { return m }

// UpdatePasswordCredentialResponseValidationError is the validation error
// returned by UpdatePasswordCredentialResponse.Validate if the designated
// constraints aren't met.
type UpdatePasswordCredentialResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePasswordCredentialResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePasswordCredentialResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePasswordCredentialResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePasswordCredentialResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePasswordCredentialResponseValidationError) ErrorName() string {
	return "UpdatePasswordCredentialResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePasswordCredentialResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePasswordCredentialResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePasswordCredentialResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePasswordCredentialResponseValidationError{}

// Validate checks the field values on Error with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Error) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Error with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ErrorMultiError, or nil if none found.
func (m *Error) ValidateAll() error {
	return m.validate(true)
}

func (m *Error) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	if len(errors) > 0 {
		return ErrorMultiError(errors)
	}

	return nil
}

// ErrorMultiError is an error wrapping multiple validation errors returned by
// Error.ValidateAll() if the designated constraints aren't met.
type ErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorMultiError) AllErrors() []error { return m }

// ErrorValidationError is the validation error returned by Error.Validate if
// the designated constraints aren't met.
type ErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorValidationError) ErrorName() string { return "ErrorValidationError" }

// Error satisfies the builtin error interface
func (e ErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorValidationError{}

// Validate checks the field values on SelfServiceChangePasswordRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SelfServiceChangePasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelfServiceChangePasswordRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SelfServiceChangePasswordRequestMultiError, or nil if none found.
func (m *SelfServiceChangePasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SelfServiceChangePasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Password

	if len(errors) > 0 {
		return SelfServiceChangePasswordRequestMultiError(errors)
	}

	return nil
}

// SelfServiceChangePasswordRequestMultiError is an error wrapping multiple
// validation errors returned by
// SelfServiceChangePasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type SelfServiceChangePasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelfServiceChangePasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelfServiceChangePasswordRequestMultiError) AllErrors() []error { return m }

// SelfServiceChangePasswordRequestValidationError is the validation error
// returned by SelfServiceChangePasswordRequest.Validate if the designated
// constraints aren't met.
type SelfServiceChangePasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelfServiceChangePasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelfServiceChangePasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelfServiceChangePasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelfServiceChangePasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelfServiceChangePasswordRequestValidationError) ErrorName() string {
	return "SelfServiceChangePasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SelfServiceChangePasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelfServiceChangePasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelfServiceChangePasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelfServiceChangePasswordRequestValidationError{}

// Validate checks the field values on SelfServiceChangePasswordResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SelfServiceChangePasswordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelfServiceChangePasswordResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SelfServiceChangePasswordResponseMultiError, or nil if none found.
func (m *SelfServiceChangePasswordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SelfServiceChangePasswordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Error

	if len(errors) > 0 {
		return SelfServiceChangePasswordResponseMultiError(errors)
	}

	return nil
}

// SelfServiceChangePasswordResponseMultiError is an error wrapping multiple
// validation errors returned by
// SelfServiceChangePasswordResponse.ValidateAll() if the designated
// constraints aren't met.
type SelfServiceChangePasswordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelfServiceChangePasswordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelfServiceChangePasswordResponseMultiError) AllErrors() []error { return m }

// SelfServiceChangePasswordResponseValidationError is the validation error
// returned by SelfServiceChangePasswordResponse.Validate if the designated
// constraints aren't met.
type SelfServiceChangePasswordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelfServiceChangePasswordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelfServiceChangePasswordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelfServiceChangePasswordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelfServiceChangePasswordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelfServiceChangePasswordResponseValidationError) ErrorName() string {
	return "SelfServiceChangePasswordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SelfServiceChangePasswordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelfServiceChangePasswordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelfServiceChangePasswordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelfServiceChangePasswordResponseValidationError{}

// Validate checks the field values on CreateInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvitationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvitationRequestMultiError, or nil if none found.
func (m *CreateInvitationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvitationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetTenantId()) != 16 {
		err := CreateInvitationRequestValidationError{
			field:  "TenantId",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetReferenceId()); l < 10 || l > 100 {
		err := CreateInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value length must be between 10 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateInvitationRequest_ReferenceId_Pattern.MatchString(m.GetReferenceId()) {
		err := CreateInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_]{10,100}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if t := m.GetInviteAtTime(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = CreateInvitationRequestValidationError{
				field:  "InviteAtTime",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) <= 0 {
				err := CreateInvitationRequestValidationError{
					field:  "InviteAtTime",
					reason: "value must be greater than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if t := m.GetExpireTime(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = CreateInvitationRequestValidationError{
				field:  "ExpireTime",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) <= 0 {
				err := CreateInvitationRequestValidationError{
					field:  "ExpireTime",
					reason: "value must be greater than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if all {
		switch v := interface{}(m.GetMessageAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvitationRequestValidationError{
					field:  "MessageAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvitationRequestValidationError{
					field:  "MessageAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMessageAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvitationRequestValidationError{
				field:  "MessageAttributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.Invitee.(type) {

	case *CreateInvitationRequest_Email:

		if l := utf8.RuneCountInString(m.GetEmail()); l < 5 || l > 255 {
			err := CreateInvitationRequestValidationError{
				field:  "Email",
				reason: "value length must be between 5 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = CreateInvitationRequestValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *CreateInvitationRequest_Mobile:
		// no validation rules for Mobile

	default:
		err := CreateInvitationRequestValidationError{
			field:  "Invitee",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CreateInvitationRequestMultiError(errors)
	}

	return nil
}

func (m *CreateInvitationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateInvitationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateInvitationRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInvitationRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInvitationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvitationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvitationRequestMultiError) AllErrors() []error { return m }

// CreateInvitationRequestValidationError is the validation error returned by
// CreateInvitationRequest.Validate if the designated constraints aren't met.
type CreateInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvitationRequestValidationError) ErrorName() string {
	return "CreateInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvitationRequestValidationError{}

var _CreateInvitationRequest_ReferenceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]{10,100}$")

// Validate checks the field values on CreateInvitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvitationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvitationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvitationResponseMultiError, or nil if none found.
func (m *CreateInvitationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvitationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateInvitationResponseMultiError(errors)
	}

	return nil
}

// CreateInvitationResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInvitationResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInvitationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvitationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvitationResponseMultiError) AllErrors() []error { return m }

// CreateInvitationResponseValidationError is the validation error returned by
// CreateInvitationResponse.Validate if the designated constraints aren't met.
type CreateInvitationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvitationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvitationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvitationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvitationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvitationResponseValidationError) ErrorName() string {
	return "CreateInvitationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvitationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvitationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvitationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvitationResponseValidationError{}

// Validate checks the field values on CheckInvitationStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckInvitationStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckInvitationStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckInvitationStateRequestMultiError, or nil if none found.
func (m *CheckInvitationStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckInvitationStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Identifier.(type) {

	case *CheckInvitationStateRequest_ReferenceId:

		if l := utf8.RuneCountInString(m.GetReferenceId()); l < 10 || l > 100 {
			err := CheckInvitationStateRequestValidationError{
				field:  "ReferenceId",
				reason: "value length must be between 10 and 100 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_CheckInvitationStateRequest_ReferenceId_Pattern.MatchString(m.GetReferenceId()) {
			err := CheckInvitationStateRequestValidationError{
				field:  "ReferenceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_]{10,100}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *CheckInvitationStateRequest_InvitationToken:

		if l := utf8.RuneCountInString(m.GetInvitationToken()); l < 10 || l > 2048 {
			err := CheckInvitationStateRequestValidationError{
				field:  "InvitationToken",
				reason: "value length must be between 10 and 2048 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		err := CheckInvitationStateRequestValidationError{
			field:  "Identifier",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CheckInvitationStateRequestMultiError(errors)
	}

	return nil
}

// CheckInvitationStateRequestMultiError is an error wrapping multiple
// validation errors returned by CheckInvitationStateRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckInvitationStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckInvitationStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckInvitationStateRequestMultiError) AllErrors() []error { return m }

// CheckInvitationStateRequestValidationError is the validation error returned
// by CheckInvitationStateRequest.Validate if the designated constraints
// aren't met.
type CheckInvitationStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckInvitationStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckInvitationStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckInvitationStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckInvitationStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckInvitationStateRequestValidationError) ErrorName() string {
	return "CheckInvitationStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckInvitationStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckInvitationStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckInvitationStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckInvitationStateRequestValidationError{}

var _CheckInvitationStateRequest_ReferenceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]{10,100}$")

// Validate checks the field values on CheckInvitationStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckInvitationStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckInvitationStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckInvitationStateResponseMultiError, or nil if none found.
func (m *CheckInvitationStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckInvitationStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvitation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckInvitationStateResponseValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckInvitationStateResponseValidationError{
					field:  "Invitation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckInvitationStateResponseValidationError{
				field:  "Invitation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckInvitationStateResponseMultiError(errors)
	}

	return nil
}

// CheckInvitationStateResponseMultiError is an error wrapping multiple
// validation errors returned by CheckInvitationStateResponse.ValidateAll() if
// the designated constraints aren't met.
type CheckInvitationStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckInvitationStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckInvitationStateResponseMultiError) AllErrors() []error { return m }

// CheckInvitationStateResponseValidationError is the validation error returned
// by CheckInvitationStateResponse.Validate if the designated constraints
// aren't met.
type CheckInvitationStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckInvitationStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckInvitationStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckInvitationStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckInvitationStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckInvitationStateResponseValidationError) ErrorName() string {
	return "CheckInvitationStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckInvitationStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckInvitationStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckInvitationStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckInvitationStateResponseValidationError{}

// Validate checks the field values on ResendInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResendInvitationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResendInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResendInvitationRequestMultiError, or nil if none found.
func (m *ResendInvitationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResendInvitationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetReferenceId()); l < 10 || l > 100 {
		err := ResendInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value length must be between 10 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResendInvitationRequest_ReferenceId_Pattern.MatchString(m.GetReferenceId()) {
		err := ResendInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_]{10,100}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResendInvitationRequestMultiError(errors)
	}

	return nil
}

// ResendInvitationRequestMultiError is an error wrapping multiple validation
// errors returned by ResendInvitationRequest.ValidateAll() if the designated
// constraints aren't met.
type ResendInvitationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResendInvitationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResendInvitationRequestMultiError) AllErrors() []error { return m }

// ResendInvitationRequestValidationError is the validation error returned by
// ResendInvitationRequest.Validate if the designated constraints aren't met.
type ResendInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResendInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResendInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResendInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResendInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResendInvitationRequestValidationError) ErrorName() string {
	return "ResendInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResendInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResendInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResendInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResendInvitationRequestValidationError{}

var _ResendInvitationRequest_ReferenceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]{10,100}$")

// Validate checks the field values on ResendInvitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResendInvitationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResendInvitationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResendInvitationResponseMultiError, or nil if none found.
func (m *ResendInvitationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResendInvitationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResendInvitationResponseMultiError(errors)
	}

	return nil
}

// ResendInvitationResponseMultiError is an error wrapping multiple validation
// errors returned by ResendInvitationResponse.ValidateAll() if the designated
// constraints aren't met.
type ResendInvitationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResendInvitationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResendInvitationResponseMultiError) AllErrors() []error { return m }

// ResendInvitationResponseValidationError is the validation error returned by
// ResendInvitationResponse.Validate if the designated constraints aren't met.
type ResendInvitationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResendInvitationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResendInvitationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResendInvitationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResendInvitationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResendInvitationResponseValidationError) ErrorName() string {
	return "ResendInvitationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResendInvitationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResendInvitationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResendInvitationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResendInvitationResponseValidationError{}

// Validate checks the field values on CancelInvitationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelInvitationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelInvitationRequestMultiError, or nil if none found.
func (m *CancelInvitationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelInvitationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetReferenceId()); l < 10 || l > 100 {
		err := CancelInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value length must be between 10 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CancelInvitationRequest_ReferenceId_Pattern.MatchString(m.GetReferenceId()) {
		err := CancelInvitationRequestValidationError{
			field:  "ReferenceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_]{10,100}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CancelInvitationRequestMultiError(errors)
	}

	return nil
}

// CancelInvitationRequestMultiError is an error wrapping multiple validation
// errors returned by CancelInvitationRequest.ValidateAll() if the designated
// constraints aren't met.
type CancelInvitationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelInvitationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelInvitationRequestMultiError) AllErrors() []error { return m }

// CancelInvitationRequestValidationError is the validation error returned by
// CancelInvitationRequest.Validate if the designated constraints aren't met.
type CancelInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelInvitationRequestValidationError) ErrorName() string {
	return "CancelInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelInvitationRequestValidationError{}

var _CancelInvitationRequest_ReferenceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]{10,100}$")

// Validate checks the field values on CancelInvitationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelInvitationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelInvitationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelInvitationResponseMultiError, or nil if none found.
func (m *CancelInvitationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelInvitationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CancelInvitationResponseMultiError(errors)
	}

	return nil
}

// CancelInvitationResponseMultiError is an error wrapping multiple validation
// errors returned by CancelInvitationResponse.ValidateAll() if the designated
// constraints aren't met.
type CancelInvitationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelInvitationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelInvitationResponseMultiError) AllErrors() []error { return m }

// CancelInvitationResponseValidationError is the validation error returned by
// CancelInvitationResponse.Validate if the designated constraints aren't met.
type CancelInvitationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelInvitationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelInvitationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelInvitationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelInvitationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelInvitationResponseValidationError) ErrorName() string {
	return "CancelInvitationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelInvitationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelInvitationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelInvitationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelInvitationResponseValidationError{}

// Validate checks the field values on CheckConsentChallengeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConsentChallengeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConsentChallengeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckConsentChallengeRequestMultiError, or nil if none found.
func (m *CheckConsentChallengeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConsentChallengeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChallenge()) != 22 {
		err := CheckConsentChallengeRequestValidationError{
			field:  "Challenge",
			reason: "value length must be 22 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CheckConsentChallengeRequestMultiError(errors)
	}

	return nil
}

// CheckConsentChallengeRequestMultiError is an error wrapping multiple
// validation errors returned by CheckConsentChallengeRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckConsentChallengeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConsentChallengeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConsentChallengeRequestMultiError) AllErrors() []error { return m }

// CheckConsentChallengeRequestValidationError is the validation error returned
// by CheckConsentChallengeRequest.Validate if the designated constraints
// aren't met.
type CheckConsentChallengeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConsentChallengeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConsentChallengeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConsentChallengeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConsentChallengeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConsentChallengeRequestValidationError) ErrorName() string {
	return "CheckConsentChallengeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConsentChallengeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConsentChallengeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConsentChallengeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConsentChallengeRequestValidationError{}

// Validate checks the field values on CheckConsentChallengeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConsentChallengeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConsentChallengeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckConsentChallengeResponseMultiError, or nil if none found.
func (m *CheckConsentChallengeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConsentChallengeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	// no validation rules for AppSpaceId

	for idx, item := range m.GetAudiences() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckConsentChallengeResponseValidationError{
						field:  fmt.Sprintf("Audiences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckConsentChallengeResponseValidationError{
						field:  fmt.Sprintf("Audiences[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckConsentChallengeResponseValidationError{
					field:  fmt.Sprintf("Audiences[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetScopes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckConsentChallengeResponseValidationError{
						field:  fmt.Sprintf("Scopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckConsentChallengeResponseValidationError{
						field:  fmt.Sprintf("Scopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckConsentChallengeResponseValidationError{
					field:  fmt.Sprintf("Scopes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestUrl

	// no validation rules for Skip

	if all {
		switch v := interface{}(m.GetDigitalTwin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "DigitalTwin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDigitalTwin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConsentChallengeResponseValidationError{
				field:  "DigitalTwin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SubjectIdentifier

	if all {
		switch v := interface{}(m.GetAuthenticatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "AuthenticatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "AuthenticatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConsentChallengeResponseValidationError{
				field:  "AuthenticatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "RequestedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "RequestedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConsentChallengeResponseValidationError{
				field:  "RequestedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConsentChallengeResponseValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConsentChallengeResponseValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckConsentChallengeResponseMultiError(errors)
	}

	return nil
}

// CheckConsentChallengeResponseMultiError is an error wrapping multiple
// validation errors returned by CheckConsentChallengeResponse.ValidateAll()
// if the designated constraints aren't met.
type CheckConsentChallengeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConsentChallengeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConsentChallengeResponseMultiError) AllErrors() []error { return m }

// CheckConsentChallengeResponseValidationError is the validation error
// returned by CheckConsentChallengeResponse.Validate if the designated
// constraints aren't met.
type CheckConsentChallengeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConsentChallengeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConsentChallengeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConsentChallengeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConsentChallengeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConsentChallengeResponseValidationError) ErrorName() string {
	return "CheckConsentChallengeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConsentChallengeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConsentChallengeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConsentChallengeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConsentChallengeResponseValidationError{}

// Validate checks the field values on ScopeItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScopeItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScopeItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScopeItemMultiError, or nil
// if none found.
func (m *ScopeItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ScopeItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Required

	if len(errors) > 0 {
		return ScopeItemMultiError(errors)
	}

	return nil
}

// ScopeItemMultiError is an error wrapping multiple validation errors returned
// by ScopeItem.ValidateAll() if the designated constraints aren't met.
type ScopeItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScopeItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScopeItemMultiError) AllErrors() []error { return m }

// ScopeItemValidationError is the validation error returned by
// ScopeItem.Validate if the designated constraints aren't met.
type ScopeItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScopeItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScopeItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScopeItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScopeItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScopeItemValidationError) ErrorName() string { return "ScopeItemValidationError" }

// Error satisfies the builtin error interface
func (e ScopeItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScopeItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScopeItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScopeItemValidationError{}

// Validate checks the field values on AudienceItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AudienceItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AudienceItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AudienceItemMultiError, or
// nil if none found.
func (m *AudienceItem) ValidateAll() error {
	return m.validate(true)
}

func (m *AudienceItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserSupportEmailAddress

	// no validation rules for ClientId

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for LogoUrl

	// no validation rules for HomepageUrl

	// no validation rules for PrivacyPolicyUrl

	// no validation rules for TosUrl

	if len(errors) > 0 {
		return AudienceItemMultiError(errors)
	}

	return nil
}

// AudienceItemMultiError is an error wrapping multiple validation errors
// returned by AudienceItem.ValidateAll() if the designated constraints aren't met.
type AudienceItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AudienceItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AudienceItemMultiError) AllErrors() []error { return m }

// AudienceItemValidationError is the validation error returned by
// AudienceItem.Validate if the designated constraints aren't met.
type AudienceItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AudienceItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AudienceItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AudienceItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AudienceItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AudienceItemValidationError) ErrorName() string { return "AudienceItemValidationError" }

// Error satisfies the builtin error interface
func (e AudienceItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAudienceItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AudienceItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AudienceItemValidationError{}

// Validate checks the field values on CreateConsentVerifierRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsentVerifierRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConsentVerifierRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConsentVerifierRequestMultiError, or nil if none found.
func (m *CreateConsentVerifierRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsentVerifierRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChallenge()) != 22 {
		err := CreateConsentVerifierRequestValidationError{
			field:  "Challenge",
			reason: "value length must be 22 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	switch m.Result.(type) {

	case *CreateConsentVerifierRequest_Approval:

		if all {
			switch v := interface{}(m.GetApproval()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateConsentVerifierRequestValidationError{
						field:  "Approval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateConsentVerifierRequestValidationError{
						field:  "Approval",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApproval()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateConsentVerifierRequestValidationError{
					field:  "Approval",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateConsentVerifierRequest_Denial:

		if all {
			switch v := interface{}(m.GetDenial()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateConsentVerifierRequestValidationError{
						field:  "Denial",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateConsentVerifierRequestValidationError{
						field:  "Denial",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDenial()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateConsentVerifierRequestValidationError{
					field:  "Denial",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := CreateConsentVerifierRequestValidationError{
			field:  "Result",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return CreateConsentVerifierRequestMultiError(errors)
	}

	return nil
}

// CreateConsentVerifierRequestMultiError is an error wrapping multiple
// validation errors returned by CreateConsentVerifierRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateConsentVerifierRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsentVerifierRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsentVerifierRequestMultiError) AllErrors() []error { return m }

// CreateConsentVerifierRequestValidationError is the validation error returned
// by CreateConsentVerifierRequest.Validate if the designated constraints
// aren't met.
type CreateConsentVerifierRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsentVerifierRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsentVerifierRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsentVerifierRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsentVerifierRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsentVerifierRequestValidationError) ErrorName() string {
	return "CreateConsentVerifierRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsentVerifierRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsentVerifierRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsentVerifierRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsentVerifierRequestValidationError{}

// Validate checks the field values on CreateConsentVerifierResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsentVerifierResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConsentVerifierResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateConsentVerifierResponseMultiError, or nil if none found.
func (m *CreateConsentVerifierResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsentVerifierResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Verifier

	// no validation rules for AuthorizationEndpoint

	if len(errors) > 0 {
		return CreateConsentVerifierResponseMultiError(errors)
	}

	return nil
}

// CreateConsentVerifierResponseMultiError is an error wrapping multiple
// validation errors returned by CreateConsentVerifierResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateConsentVerifierResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsentVerifierResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsentVerifierResponseMultiError) AllErrors() []error { return m }

// CreateConsentVerifierResponseValidationError is the validation error
// returned by CreateConsentVerifierResponse.Validate if the designated
// constraints aren't met.
type CreateConsentVerifierResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsentVerifierResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsentVerifierResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsentVerifierResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsentVerifierResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsentVerifierResponseValidationError) ErrorName() string {
	return "CreateConsentVerifierResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsentVerifierResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsentVerifierResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsentVerifierResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsentVerifierResponseValidationError{}

// Validate checks the field values on ConsentApproval with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConsentApproval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentApproval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentApprovalMultiError, or nil if none found.
func (m *ConsentApproval) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentApproval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetGrantScopes()) < 1 {
		err := ConsentApprovalValidationError{
			field:  "GrantScopes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ConsentApproval_GrantScopes_Unique := make(map[string]struct{}, len(m.GetGrantScopes()))

	for idx, item := range m.GetGrantScopes() {
		_, _ = idx, item

		if _, exists := _ConsentApproval_GrantScopes_Unique[item]; exists {
			err := ConsentApprovalValidationError{
				field:  fmt.Sprintf("GrantScopes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ConsentApproval_GrantScopes_Unique[item] = struct{}{}
		}

		// no validation rules for GrantScopes[idx]
	}

	_ConsentApproval_GrantedAudiences_Unique := make(map[string]struct{}, len(m.GetGrantedAudiences()))

	for idx, item := range m.GetGrantedAudiences() {
		_, _ = idx, item

		if _, exists := _ConsentApproval_GrantedAudiences_Unique[item]; exists {
			err := ConsentApprovalValidationError{
				field:  fmt.Sprintf("GrantedAudiences[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ConsentApproval_GrantedAudiences_Unique[item] = struct{}{}
		}

		// no validation rules for GrantedAudiences[idx]
	}

	if all {
		switch v := interface{}(m.GetSession()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsentApprovalValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsentApprovalValidationError{
					field:  "Session",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSession()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsentApprovalValidationError{
				field:  "Session",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Remember

	// no validation rules for RememberFor

	if len(errors) > 0 {
		return ConsentApprovalMultiError(errors)
	}

	return nil
}

// ConsentApprovalMultiError is an error wrapping multiple validation errors
// returned by ConsentApproval.ValidateAll() if the designated constraints
// aren't met.
type ConsentApprovalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentApprovalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentApprovalMultiError) AllErrors() []error { return m }

// ConsentApprovalValidationError is the validation error returned by
// ConsentApproval.Validate if the designated constraints aren't met.
type ConsentApprovalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentApprovalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentApprovalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentApprovalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentApprovalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentApprovalValidationError) ErrorName() string { return "ConsentApprovalValidationError" }

// Error satisfies the builtin error interface
func (e ConsentApprovalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentApproval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentApprovalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentApprovalValidationError{}

// Validate checks the field values on ConsentRequestSessionData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentRequestSessionData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentRequestSessionData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentRequestSessionDataMultiError, or nil if none found.
func (m *ConsentRequestSessionData) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentRequestSessionData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "AccessToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsentRequestSessionDataValidationError{
				field:  "AccessToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIdToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "IdToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "IdToken",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsentRequestSessionDataValidationError{
				field:  "IdToken",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserinfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "Userinfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsentRequestSessionDataValidationError{
					field:  "Userinfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserinfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsentRequestSessionDataValidationError{
				field:  "Userinfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConsentRequestSessionDataMultiError(errors)
	}

	return nil
}

// ConsentRequestSessionDataMultiError is an error wrapping multiple validation
// errors returned by ConsentRequestSessionData.ValidateAll() if the
// designated constraints aren't met.
type ConsentRequestSessionDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentRequestSessionDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentRequestSessionDataMultiError) AllErrors() []error { return m }

// ConsentRequestSessionDataValidationError is the validation error returned by
// ConsentRequestSessionData.Validate if the designated constraints aren't met.
type ConsentRequestSessionDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentRequestSessionDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentRequestSessionDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentRequestSessionDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentRequestSessionDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentRequestSessionDataValidationError) ErrorName() string {
	return "ConsentRequestSessionDataValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentRequestSessionDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentRequestSessionData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentRequestSessionDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentRequestSessionDataValidationError{}

// Validate checks the field values on DenialResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DenialResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DenialResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DenialResponseMultiError,
// or nil if none found.
func (m *DenialResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DenialResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetError() != "" {

		if !_DenialResponse_Error_Pattern.MatchString(m.GetError()) {
			err := DenialResponseValidationError{
				field:  "Error",
				reason: "value does not match regex pattern \"^[ !#-\\\\[\\\\]-~]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetErrorDescription() != "" {

		if !_DenialResponse_ErrorDescription_Pattern.MatchString(m.GetErrorDescription()) {
			err := DenialResponseValidationError{
				field:  "ErrorDescription",
				reason: "value does not match regex pattern \"^[ !#-\\\\[\\\\]-~]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for ErrorHint

	if m.GetStatusCode() != 0 {

		if _, ok := _DenialResponse_StatusCode_InLookup[m.GetStatusCode()]; !ok {
			err := DenialResponseValidationError{
				field:  "StatusCode",
				reason: "value must be in list [400 401 403 408 409 410 412 422 429 451]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return DenialResponseMultiError(errors)
	}

	return nil
}

// DenialResponseMultiError is an error wrapping multiple validation errors
// returned by DenialResponse.ValidateAll() if the designated constraints
// aren't met.
type DenialResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DenialResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DenialResponseMultiError) AllErrors() []error { return m }

// DenialResponseValidationError is the validation error returned by
// DenialResponse.Validate if the designated constraints aren't met.
type DenialResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DenialResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DenialResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DenialResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DenialResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DenialResponseValidationError) ErrorName() string { return "DenialResponseValidationError" }

// Error satisfies the builtin error interface
func (e DenialResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDenialResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DenialResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DenialResponseValidationError{}

var _DenialResponse_Error_Pattern = regexp.MustCompile("^[ !#-\\[\\]-~]+$")

var _DenialResponse_ErrorDescription_Pattern = regexp.MustCompile("^[ !#-\\[\\]-~]+$")

var _DenialResponse_StatusCode_InLookup = map[int64]struct{}{
	400: {},
	401: {},
	403: {},
	408: {},
	409: {},
	410: {},
	412: {},
	422: {},
	429: {},
	451: {},
}

// Validate checks the field values on GetAccessTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessTokenRequestMultiError, or nil if none found.
func (m *GetAccessTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for ProviderId

	// no validation rules for ProviderName

	// no validation rules for SubjectId

	// no validation rules for OfflineAccess

	if len(errors) > 0 {
		return GetAccessTokenRequestMultiError(errors)
	}

	return nil
}

// GetAccessTokenRequestMultiError is an error wrapping multiple validation
// errors returned by GetAccessTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAccessTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessTokenRequestMultiError) AllErrors() []error { return m }

// GetAccessTokenRequestValidationError is the validation error returned by
// GetAccessTokenRequest.Validate if the designated constraints aren't met.
type GetAccessTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessTokenRequestValidationError) ErrorName() string {
	return "GetAccessTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessTokenRequestValidationError{}

// Validate checks the field values on GetAccessTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessTokenResponseMultiError, or nil if none found.
func (m *GetAccessTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAccessTokenResponseValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAccessTokenResponseValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAccessTokenResponseValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAccessTokenResponseMultiError(errors)
	}

	return nil
}

// GetAccessTokenResponseMultiError is an error wrapping multiple validation
// errors returned by GetAccessTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAccessTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessTokenResponseMultiError) AllErrors() []error { return m }

// GetAccessTokenResponseValidationError is the validation error returned by
// GetAccessTokenResponse.Validate if the designated constraints aren't met.
type GetAccessTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessTokenResponseValidationError) ErrorName() string {
	return "GetAccessTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessTokenResponseValidationError{}

// Validate checks the field values on SessionIntrospectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionIntrospectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionIntrospectRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionIntrospectRequestMultiError, or nil if none found.
func (m *SessionIntrospectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionIntrospectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantId

	// no validation rules for Token

	if len(errors) > 0 {
		return SessionIntrospectRequestMultiError(errors)
	}

	return nil
}

// SessionIntrospectRequestMultiError is an error wrapping multiple validation
// errors returned by SessionIntrospectRequest.ValidateAll() if the designated
// constraints aren't met.
type SessionIntrospectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionIntrospectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionIntrospectRequestMultiError) AllErrors() []error { return m }

// SessionIntrospectRequestValidationError is the validation error returned by
// SessionIntrospectRequest.Validate if the designated constraints aren't met.
type SessionIntrospectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionIntrospectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionIntrospectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionIntrospectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionIntrospectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionIntrospectRequestValidationError) ErrorName() string {
	return "SessionIntrospectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SessionIntrospectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionIntrospectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionIntrospectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionIntrospectRequestValidationError{}

// Validate checks the field values on SessionIntrospectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SessionIntrospectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SessionIntrospectResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SessionIntrospectResponseMultiError, or nil if none found.
func (m *SessionIntrospectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SessionIntrospectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Active

	if all {
		switch v := interface{}(m.GetTokenInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SessionIntrospectResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SessionIntrospectResponseValidationError{
					field:  "TokenInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SessionIntrospectResponseValidationError{
				field:  "TokenInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SessionIntrospectResponseMultiError(errors)
	}

	return nil
}

// SessionIntrospectResponseMultiError is an error wrapping multiple validation
// errors returned by SessionIntrospectResponse.ValidateAll() if the
// designated constraints aren't met.
type SessionIntrospectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SessionIntrospectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SessionIntrospectResponseMultiError) AllErrors() []error { return m }

// SessionIntrospectResponseValidationError is the validation error returned by
// SessionIntrospectResponse.Validate if the designated constraints aren't met.
type SessionIntrospectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SessionIntrospectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SessionIntrospectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SessionIntrospectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SessionIntrospectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SessionIntrospectResponseValidationError) ErrorName() string {
	return "SessionIntrospectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SessionIntrospectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSessionIntrospectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SessionIntrospectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SessionIntrospectResponseValidationError{}

// Validate checks the field values on IsAuthorizedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsAuthorizedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsAuthorizedRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsAuthorizedRequestMultiError, or nil if none found.
func (m *IsAuthorizedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsAuthorizedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubject() == nil {
		err := IsAuthorizedRequestValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IsAuthorizedRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IsAuthorizedRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IsAuthorizedRequestValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetResources()); l < 1 || l > 32 {
		err := IsAuthorizedRequestValidationError{
			field:  "Resources",
			reason: "value must contain between 1 and 32 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IsAuthorizedRequestValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IsAuthorizedRequestValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IsAuthorizedRequestValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetActions()) != 1 {
		err := IsAuthorizedRequestValidationError{
			field:  "Actions",
			reason: "value must contain exactly 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if l := utf8.RuneCountInString(item); l < 2 || l > 50 {
			err := IsAuthorizedRequestValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "value length must be between 2 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_IsAuthorizedRequest_Actions_Pattern.MatchString(item) {
			err := IsAuthorizedRequestValidationError{
				field:  fmt.Sprintf("Actions[%v]", idx),
				reason: "value does not match regex pattern \"^[a-zA-Z0-9.:_\\\\-\\\\/]{2,}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return IsAuthorizedRequestMultiError(errors)
	}

	return nil
}

// IsAuthorizedRequestMultiError is an error wrapping multiple validation
// errors returned by IsAuthorizedRequest.ValidateAll() if the designated
// constraints aren't met.
type IsAuthorizedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsAuthorizedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsAuthorizedRequestMultiError) AllErrors() []error { return m }

// IsAuthorizedRequestValidationError is the validation error returned by
// IsAuthorizedRequest.Validate if the designated constraints aren't met.
type IsAuthorizedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsAuthorizedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsAuthorizedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsAuthorizedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsAuthorizedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsAuthorizedRequestValidationError) ErrorName() string {
	return "IsAuthorizedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsAuthorizedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsAuthorizedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsAuthorizedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsAuthorizedRequestValidationError{}

var _IsAuthorizedRequest_Actions_Pattern = regexp.MustCompile("^[a-zA-Z0-9.:_\\-\\/]{2,}$")

// Validate checks the field values on IsAuthorizedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsAuthorizedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsAuthorizedResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsAuthorizedResponseMultiError, or nil if none found.
func (m *IsAuthorizedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsAuthorizedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDecisionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IsAuthorizedResponseValidationError{
					field:  "DecisionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IsAuthorizedResponseValidationError{
					field:  "DecisionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDecisionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IsAuthorizedResponseValidationError{
				field:  "DecisionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetDecisions()))
		i := 0
		for key := range m.GetDecisions() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDecisions()[key]
			_ = val

			// no validation rules for Decisions[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, IsAuthorizedResponseValidationError{
							field:  fmt.Sprintf("Decisions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, IsAuthorizedResponseValidationError{
							field:  fmt.Sprintf("Decisions[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return IsAuthorizedResponseValidationError{
						field:  fmt.Sprintf("Decisions[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return IsAuthorizedResponseMultiError(errors)
	}

	return nil
}

// IsAuthorizedResponseMultiError is an error wrapping multiple validation
// errors returned by IsAuthorizedResponse.ValidateAll() if the designated
// constraints aren't met.
type IsAuthorizedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsAuthorizedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsAuthorizedResponseMultiError) AllErrors() []error { return m }

// IsAuthorizedResponseValidationError is the validation error returned by
// IsAuthorizedResponse.Validate if the designated constraints aren't met.
type IsAuthorizedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsAuthorizedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsAuthorizedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsAuthorizedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsAuthorizedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsAuthorizedResponseValidationError) ErrorName() string {
	return "IsAuthorizedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsAuthorizedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsAuthorizedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsAuthorizedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsAuthorizedResponseValidationError{}

// Validate checks the field values on AuthorizationDecision with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationDecision) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationDecision with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationDecisionMultiError, or nil if none found.
func (m *AuthorizationDecision) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationDecision) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AllowAction

	if len(errors) > 0 {
		return AuthorizationDecisionMultiError(errors)
	}

	return nil
}

// AuthorizationDecisionMultiError is an error wrapping multiple validation
// errors returned by AuthorizationDecision.ValidateAll() if the designated
// constraints aren't met.
type AuthorizationDecisionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationDecisionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationDecisionMultiError) AllErrors() []error { return m }

// AuthorizationDecisionValidationError is the validation error returned by
// AuthorizationDecision.Validate if the designated constraints aren't met.
type AuthorizationDecisionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationDecisionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationDecisionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationDecisionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationDecisionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationDecisionValidationError) ErrorName() string {
	return "AuthorizationDecisionValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationDecisionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationDecision.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationDecisionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationDecisionValidationError{}

// Validate checks the field values on EnrichTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichTokenRequestMultiError, or nil if none found.
func (m *EnrichTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if all {
		switch v := interface{}(m.GetTokenClaims()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnrichTokenRequestValidationError{
					field:  "TokenClaims",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnrichTokenRequestValidationError{
					field:  "TokenClaims",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenClaims()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnrichTokenRequestValidationError{
				field:  "TokenClaims",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSessionClaims()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnrichTokenRequestValidationError{
					field:  "SessionClaims",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnrichTokenRequestValidationError{
					field:  "SessionClaims",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSessionClaims()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnrichTokenRequestValidationError{
				field:  "SessionClaims",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnrichTokenRequestMultiError(errors)
	}

	return nil
}

// EnrichTokenRequestMultiError is an error wrapping multiple validation errors
// returned by EnrichTokenRequest.ValidateAll() if the designated constraints
// aren't met.
type EnrichTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichTokenRequestMultiError) AllErrors() []error { return m }

// EnrichTokenRequestValidationError is the validation error returned by
// EnrichTokenRequest.Validate if the designated constraints aren't met.
type EnrichTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichTokenRequestValidationError) ErrorName() string {
	return "EnrichTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichTokenRequestValidationError{}

// Validate checks the field values on EnrichTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichTokenResponseMultiError, or nil if none found.
func (m *EnrichTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EnrichTokenResponseMultiError(errors)
	}

	return nil
}

// EnrichTokenResponseMultiError is an error wrapping multiple validation
// errors returned by EnrichTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type EnrichTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichTokenResponseMultiError) AllErrors() []error { return m }

// EnrichTokenResponseValidationError is the validation error returned by
// EnrichTokenResponse.Validate if the designated constraints aren't met.
type EnrichTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichTokenResponseValidationError) ErrorName() string {
	return "EnrichTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichTokenResponseValidationError{}

// Validate checks the field values on IsAuthorizedRequest_Resource with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsAuthorizedRequest_Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsAuthorizedRequest_Resource with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsAuthorizedRequest_ResourceMultiError, or nil if none found.
func (m *IsAuthorizedRequest_Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *IsAuthorizedRequest_Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 2 || l > 50 {
		err := IsAuthorizedRequest_ResourceValidationError{
			field:  "Id",
			reason: "value length must be between 2 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetLabel()); l < 2 || l > 50 {
		err := IsAuthorizedRequest_ResourceValidationError{
			field:  "Label",
			reason: "value length must be between 2 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IsAuthorizedRequest_Resource_Label_Pattern.MatchString(m.GetLabel()) {
		err := IsAuthorizedRequest_ResourceValidationError{
			field:  "Label",
			reason: "value does not match regex pattern \"^(?:[A-Z][a-z]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsAuthorizedRequest_ResourceMultiError(errors)
	}

	return nil
}

// IsAuthorizedRequest_ResourceMultiError is an error wrapping multiple
// validation errors returned by IsAuthorizedRequest_Resource.ValidateAll() if
// the designated constraints aren't met.
type IsAuthorizedRequest_ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsAuthorizedRequest_ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsAuthorizedRequest_ResourceMultiError) AllErrors() []error { return m }

// IsAuthorizedRequest_ResourceValidationError is the validation error returned
// by IsAuthorizedRequest_Resource.Validate if the designated constraints
// aren't met.
type IsAuthorizedRequest_ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsAuthorizedRequest_ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsAuthorizedRequest_ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsAuthorizedRequest_ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsAuthorizedRequest_ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsAuthorizedRequest_ResourceValidationError) ErrorName() string {
	return "IsAuthorizedRequest_ResourceValidationError"
}

// Error satisfies the builtin error interface
func (e IsAuthorizedRequest_ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsAuthorizedRequest_Resource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsAuthorizedRequest_ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsAuthorizedRequest_ResourceValidationError{}

var _IsAuthorizedRequest_Resource_Label_Pattern = regexp.MustCompile("^(?:[A-Z][a-z]+)+$")
