// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/config/v1beta1/model.proto

package configv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _model_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UniqueNameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UniqueNameIdentifierMultiError, or nil if none found.
func (m *UniqueNameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *UniqueNameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLocation()); l < 22 || l > 254 {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Location_Pattern.MatchString(m.GetLocation()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Name_Pattern.MatchString(m.GetName()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UniqueNameIdentifierMultiError(errors)
	}

	return nil
}

// UniqueNameIdentifierMultiError is an error wrapping multiple validation
// errors returned by UniqueNameIdentifier.ValidateAll() if the designated
// constraints aren't met.
type UniqueNameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UniqueNameIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UniqueNameIdentifierMultiError) AllErrors() []error { return m }

// UniqueNameIdentifierValidationError is the validation error returned by
// UniqueNameIdentifier.Validate if the designated constraints aren't met.
type UniqueNameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UniqueNameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UniqueNameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UniqueNameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UniqueNameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UniqueNameIdentifierValidationError) ErrorName() string {
	return "UniqueNameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e UniqueNameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUniqueNameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UniqueNameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UniqueNameIdentifierValidationError{}

var _UniqueNameIdentifier_Location_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _UniqueNameIdentifier_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on Customer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Customer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerMultiError, or nil
// if none found.
func (m *Customer) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Id_Pattern.MatchString(m.GetId()) {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Name_Pattern.MatchString(m.GetName()) {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := CustomerValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := CustomerValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if len(errors) > 0 {
		return CustomerMultiError(errors)
	}

	return nil
}

// CustomerMultiError is an error wrapping multiple validation errors returned
// by Customer.ValidateAll() if the designated constraints aren't met.
type CustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerMultiError) AllErrors() []error { return m }

// CustomerValidationError is the validation error returned by
// Customer.Validate if the designated constraints aren't met.
type CustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerValidationError) ErrorName() string { return "CustomerValidationError" }

// Error satisfies the builtin error interface
func (e CustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerValidationError{}

var _Customer_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Customer_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on ApplicationSpace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceMultiError, or nil if none found.
func (m *ApplicationSpace) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationSpaceValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIssuerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "IssuerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_IssuerId_Pattern.MatchString(m.GetIssuerId()) {
		err := ApplicationSpaceValidationError{
			field:  "IssuerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IkgStatus

	if len(errors) > 0 {
		return ApplicationSpaceMultiError(errors)
	}

	return nil
}

// ApplicationSpaceMultiError is an error wrapping multiple validation errors
// returned by ApplicationSpace.ValidateAll() if the designated constraints
// aren't met.
type ApplicationSpaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceMultiError) AllErrors() []error { return m }

// ApplicationSpaceValidationError is the validation error returned by
// ApplicationSpace.Validate if the designated constraints aren't met.
type ApplicationSpaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceValidationError) ErrorName() string { return "ApplicationSpaceValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationSpaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceValidationError{}

var _ApplicationSpace_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationSpace_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_IssuerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Tenant with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Tenant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tenant with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TenantMultiError, or nil if none found.
func (m *Tenant) ValidateAll() error {
	return m.validate(true)
}

func (m *Tenant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_Id_Pattern.MatchString(m.GetId()) {
		err := TenantValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := TenantValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_Name_Pattern.MatchString(m.GetName()) {
		err := TenantValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := TenantValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := TenantValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := TenantValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := TenantValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIssuerId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "IssuerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_IssuerId_Pattern.MatchString(m.GetIssuerId()) {
		err := TenantValidationError{
			field:  "IssuerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Default

	if len(errors) > 0 {
		return TenantMultiError(errors)
	}

	return nil
}

// TenantMultiError is an error wrapping multiple validation errors returned by
// Tenant.ValidateAll() if the designated constraints aren't met.
type TenantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantMultiError) AllErrors() []error { return m }

// TenantValidationError is the validation error returned by Tenant.Validate if
// the designated constraints aren't met.
type TenantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantValidationError) ErrorName() string { return "TenantValidationError" }

// Error satisfies the builtin error interface
func (e TenantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantValidationError{}

var _Tenant_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Tenant_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_IssuerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentMultiError, or nil if none found.
func (m *ApplicationAgent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationAgentValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentMultiError(errors)
	}

	return nil
}

// ApplicationAgentMultiError is an error wrapping multiple validation errors
// returned by ApplicationAgent.ValidateAll() if the designated constraints
// aren't met.
type ApplicationAgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentMultiError) AllErrors() []error { return m }

// ApplicationAgentValidationError is the validation error returned by
// ApplicationAgent.Validate if the designated constraints aren't met.
type ApplicationAgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentValidationError) ErrorName() string { return "ApplicationAgentValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationAgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentValidationError{}

var _ApplicationAgent_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationAgent_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgentCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialMultiError, or nil if none found.
func (m *ApplicationAgentCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationAgentId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationAgentId_Pattern.MatchString(m.GetApplicationAgentId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialMultiError is an error wrapping multiple
// validation errors returned by ApplicationAgentCredential.ValidateAll() if
// the designated constraints aren't met.
type ApplicationAgentCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialValidationError is the validation error returned
// by ApplicationAgentCredential.Validate if the designated constraints aren't met.
type ApplicationAgentCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialValidationError) ErrorName() string {
	return "ApplicationAgentCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialValidationError{}

var _ApplicationAgentCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ApplicationAgentCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationAgentId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceAccountMultiError,
// or nil if none found.
func (m *ServiceAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Name_Pattern.MatchString(m.GetName()) {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccount_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ServiceAccountMultiError(errors)
	}

	return nil
}

// ServiceAccountMultiError is an error wrapping multiple validation errors
// returned by ServiceAccount.ValidateAll() if the designated constraints
// aren't met.
type ServiceAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountMultiError) AllErrors() []error { return m }

// ServiceAccountValidationError is the validation error returned by
// ServiceAccount.Validate if the designated constraints aren't met.
type ServiceAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountValidationError) ErrorName() string { return "ServiceAccountValidationError" }

// Error satisfies the builtin error interface
func (e ServiceAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountValidationError{}

var _ServiceAccount_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ServiceAccount_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccountCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialMultiError, or nil if none found.
func (m *ServiceAccountCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccountCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetServiceAccountId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_ServiceAccountId_Pattern.MatchString(m.GetServiceAccountId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialMultiError is an error wrapping multiple validation
// errors returned by ServiceAccountCredential.ValidateAll() if the designated
// constraints aren't met.
type ServiceAccountCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialValidationError is the validation error returned by
// ServiceAccountCredential.Validate if the designated constraints aren't met.
type ServiceAccountCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialValidationError) ErrorName() string {
	return "ServiceAccountCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialValidationError{}

var _ServiceAccountCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ServiceAccountCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_ServiceAccountId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ConfigNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigNodeMultiError, or
// nil if none found.
func (m *ConfigNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Id_Pattern.MatchString(m.GetId()) {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Name_Pattern.MatchString(m.GetName()) {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ConfigNodeValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTenantId() != "" {

		if l := utf8.RuneCountInString(m.GetTenantId()); l < 22 || l > 254 {
			err := ConfigNodeValidationError{
				field:  "TenantId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ConfigNode_TenantId_Pattern.MatchString(m.GetTenantId()) {
			err := ConfigNodeValidationError{
				field:  "TenantId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Version

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *ConfigNode_EmailServiceConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetEmailServiceConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "EmailServiceConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmailServiceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmailServiceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "EmailServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuditSinkConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetAuditSinkConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "AuditSinkConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuditSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_Oauth2ClientConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetOauth2ClientConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "Oauth2ClientConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOauth2ClientConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOauth2ClientConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "Oauth2ClientConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_WebauthnProviderConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetWebauthnProviderConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "WebauthnProviderConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebauthnProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "WebauthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "WebauthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebauthnProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "WebauthnProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_SafrProviderConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetSafrProviderConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "SafrProviderConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSafrProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "SafrProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "SafrProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSafrProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "SafrProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetAuthorizationPolicyConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "AuthorizationPolicyConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_ConsentConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetConsentConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "ConsentConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_TokenIntrospectConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetTokenIntrospectConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "TokenIntrospectConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenIntrospectConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenIntrospectConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "TokenIntrospectConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := ConfigNodeValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigNodeMultiError(errors)
	}

	return nil
}

// ConfigNodeMultiError is an error wrapping multiple validation errors
// returned by ConfigNode.ValidateAll() if the designated constraints aren't met.
type ConfigNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigNodeMultiError) AllErrors() []error { return m }

// ConfigNodeValidationError is the validation error returned by
// ConfigNode.Validate if the designated constraints aren't met.
type ConfigNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigNodeValidationError) ErrorName() string { return "ConfigNodeValidationError" }

// Error satisfies the builtin error interface
func (e ConfigNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigNodeValidationError{}

var _ConfigNode_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ConfigNode_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ClientConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ClientConfigMultiError, or nil if none found.
func (m *OAuth2ClientConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ClientConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _OAuth2ClientConfig_ProviderType_NotInLookup[m.GetProviderType()]; ok {
		err := OAuth2ClientConfigValidationError{
			field:  "ProviderType",
			reason: "value must not be in list [PROVIDER_TYPE_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ProviderType_name[int32(m.GetProviderType())]; !ok {
		err := OAuth2ClientConfigValidationError{
			field:  "ProviderType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientId()) < 8 {
		err := OAuth2ClientConfigValidationError{
			field:  "ClientId",
			reason: "value length must be at least 8 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetClientSecret() != "" {

		if utf8.RuneCountInString(m.GetClientSecret()) < 8 {
			err := OAuth2ClientConfigValidationError{
				field:  "ClientSecret",
				reason: "value length must be at least 8 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetRedirectUri()) > 0 {

		_OAuth2ClientConfig_RedirectUri_Unique := make(map[string]struct{}, len(m.GetRedirectUri()))

		for idx, item := range m.GetRedirectUri() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_RedirectUri_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_RedirectUri_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 8 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value length must be at least 8 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(item); err != nil {
				err = OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(m.GetDefaultScopes()) > 0 {

		_OAuth2ClientConfig_DefaultScopes_Unique := make(map[string]struct{}, len(m.GetDefaultScopes()))

		for idx, item := range m.GetDefaultScopes() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_DefaultScopes_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("DefaultScopes[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_DefaultScopes_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 1 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("DefaultScopes[%v]", idx),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(m.GetAllowedScopes()) > 0 {

		_OAuth2ClientConfig_AllowedScopes_Unique := make(map[string]struct{}, len(m.GetAllowedScopes()))

		for idx, item := range m.GetAllowedScopes() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_AllowedScopes_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("AllowedScopes[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_AllowedScopes_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 1 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("AllowedScopes[%v]", idx),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	// no validation rules for AllowSignup

	if m.GetIssuer() != "" {

		if utf8.RuneCountInString(m.GetIssuer()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetIssuer(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetIssuer()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetAuthorizationEndpoint() != "" {

		if utf8.RuneCountInString(m.GetAuthorizationEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetAuthorizationEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetAuthorizationEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTokenEndpoint() != "" {

		if utf8.RuneCountInString(m.GetTokenEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetTokenEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetTokenEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetDiscoveryUrl() != "" {

		if utf8.RuneCountInString(m.GetDiscoveryUrl()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetDiscoveryUrl(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetDiscoveryUrl()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetUserinfoEndpoint() != "" {

		if utf8.RuneCountInString(m.GetUserinfoEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetUserinfoEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetUserinfoEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetJwksUri() != "" {

		if utf8.RuneCountInString(m.GetJwksUri()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetJwksUri(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetJwksUri()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetImageUrl() != "" {

		if l := utf8.RuneCountInString(m.GetImageUrl()); l < 2 || l > 1024 {
			err := OAuth2ClientConfigValidationError{
				field:  "ImageUrl",
				reason: "value length must be between 2 and 1024 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTenant() != "" {

		if l := utf8.RuneCountInString(m.GetTenant()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "Tenant",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetHostedDomain() != "" {

		if l := utf8.RuneCountInString(m.GetHostedDomain()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "HostedDomain",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetHostedDomain()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "HostedDomain",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := AuthStyle_name[int32(m.GetAuthStyle())]; !ok {
		err := OAuth2ClientConfigValidationError{
			field:  "AuthStyle",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetPrivateKeyPem()) > 0 {

		if l := len(m.GetPrivateKeyPem()); l < 85 || l > 8192 {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value length must be between 85 and 8192 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasPrefix(m.GetPrivateKeyPem(), []uint8{0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D}) {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value does not have prefix \"\\x2D\\x2D\\x2D\\x2D\\x2D\\x42\\x45\\x47\\x49\\x4E\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4B\\x45\\x59\\x2D\\x2D\\x2D\\x2D\\x2D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasSuffix(m.GetPrivateKeyPem(), []uint8{0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D}) {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value does not have suffix \"\\x2D\\x2D\\x2D\\x2D\\x2D\\x45\\x4E\\x44\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4B\\x45\\x59\\x2D\\x2D\\x2D\\x2D\\x2D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetPrivateKeyId() != "" {

		if l := utf8.RuneCountInString(m.GetPrivateKeyId()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyId",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTeamId() != "" {

		if l := utf8.RuneCountInString(m.GetTeamId()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "TeamId",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return OAuth2ClientConfigMultiError(errors)
	}

	return nil
}

func (m *OAuth2ClientConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// OAuth2ClientConfigMultiError is an error wrapping multiple validation errors
// returned by OAuth2ClientConfig.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ClientConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ClientConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ClientConfigMultiError) AllErrors() []error { return m }

// OAuth2ClientConfigValidationError is the validation error returned by
// OAuth2ClientConfig.Validate if the designated constraints aren't met.
type OAuth2ClientConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ClientConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ClientConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ClientConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ClientConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ClientConfigValidationError) ErrorName() string {
	return "OAuth2ClientConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ClientConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ClientConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ClientConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ClientConfigValidationError{}

var _OAuth2ClientConfig_ProviderType_NotInLookup = map[ProviderType]struct{}{
	0: {},
}

// Validate checks the field values on OAuth2Application with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OAuth2Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2Application with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ApplicationMultiError, or nil if none found.
func (m *OAuth2Application) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Id_Pattern.MatchString(m.GetId()) {
		err := OAuth2ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := OAuth2ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Name_Pattern.MatchString(m.GetName()) {
		err := OAuth2ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := OAuth2ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := OAuth2ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := OAuth2ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOauth2ProviderId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "Oauth2ProviderId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Oauth2ProviderId_Pattern.MatchString(m.GetOauth2ProviderId()) {
		err := OAuth2ApplicationValidationError{
			field:  "Oauth2ProviderId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OAuth2ApplicationMultiError(errors)
	}

	return nil
}

// OAuth2ApplicationMultiError is an error wrapping multiple validation errors
// returned by OAuth2Application.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ApplicationMultiError) AllErrors() []error { return m }

// OAuth2ApplicationValidationError is the validation error returned by
// OAuth2Application.Validate if the designated constraints aren't met.
type OAuth2ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ApplicationValidationError) ErrorName() string {
	return "OAuth2ApplicationValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2Application.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ApplicationValidationError{}

var _OAuth2Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _OAuth2Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_Oauth2ProviderId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ApplicationConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ApplicationConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ApplicationConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ApplicationConfigMultiError, or nil if none found.
func (m *OAuth2ApplicationConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ApplicationConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDescription() != "" {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 2 || l > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetRedirectUris()) < 1 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "RedirectUris",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_RedirectUris_Unique := make(map[string]struct{}, len(m.GetRedirectUris()))

	for idx, item := range m.GetRedirectUris() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_RedirectUris_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_RedirectUris_Unique[item] = struct{}{}
		}

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetOwner()); l < 2 || l > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "Owner",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPolicyUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetPolicyUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_AllowedCorsOrigins_Unique := make(map[string]struct{}, len(m.GetAllowedCorsOrigins()))

	for idx, item := range m.GetAllowedCorsOrigins() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_AllowedCorsOrigins_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_AllowedCorsOrigins_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetTermsOfServiceUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetTermsOfServiceUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetClientUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLogoUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetLogoUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserSupportEmailAddress()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "UserSupportEmailAddress",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetUserSupportEmailAddress()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "UserSupportEmailAddress",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _OAuth2ApplicationConfig_SubjectType_NotInLookup[m.GetSubjectType()]; ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "SubjectType",
			reason: "value must not be in list [CLIENT_SUBJECT_TYPE_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ClientSubjectType_name[int32(m.GetSubjectType())]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "SubjectType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSectorIdentifierUri() != "" {

		if utf8.RuneCountInString(m.GetSectorIdentifierUri()) > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetSectorIdentifierUri()); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_GrantTypes_Unique := make(map[GrantType]struct{}, len(m.GetGrantTypes()))

	for idx, item := range m.GetGrantTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_GrantTypes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_GrantTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ApplicationConfig_GrantTypes_NotInLookup[item]; ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := GrantType_name[int32(item)]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_ResponseTypes_Unique := make(map[ResponseType]struct{}, len(m.GetResponseTypes()))

	for idx, item := range m.GetResponseTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_ResponseTypes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_ResponseTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ApplicationConfig_ResponseTypes_NotInLookup[item]; ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := ResponseType_name[int32(item)]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetScopes()) < 1 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "Scopes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_Scopes_Unique := make(map[string]struct{}, len(m.GetScopes()))

	for idx, item := range m.GetScopes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_Scopes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_Scopes_Unique[item] = struct{}{}
		}

		if !_OAuth2ApplicationConfig_Scopes_Pattern.MatchString(item) {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "value does not match regex pattern \"^[\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e]{1,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_Audiences_Unique := make(map[string]struct{}, len(m.GetAudiences()))

	for idx, item := range m.GetAudiences() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_Audiences_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Audiences[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_Audiences_Unique[item] = struct{}{}
		}

		if err := m._validateUuid(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Audiences[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _OAuth2ApplicationConfig_TokenEndpointAuthMethod_NotInLookup[m.GetTokenEndpointAuthMethod()]; ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must not be in list [TOKEN_ENDPOINT_AUTH_METHOD_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TokenEndpointAuthMethod_name[int32(m.GetTokenEndpointAuthMethod())]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _OAuth2ApplicationConfig_TokenEndpointAuthSigningAlg_InLookup[m.GetTokenEndpointAuthSigningAlg()]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthSigningAlg",
			reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserinfoSignedResponseAlg() != "" {

		if _, ok := _OAuth2ApplicationConfig_UserinfoSignedResponseAlg_InLookup[m.GetUserinfoSignedResponseAlg()]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  "UserinfoSignedResponseAlg",
				reason: "value must be in list [RS256]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Trusted

	if len(errors) > 0 {
		return OAuth2ApplicationConfigMultiError(errors)
	}

	return nil
}

func (m *OAuth2ApplicationConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *OAuth2ApplicationConfig) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

func (m *OAuth2ApplicationConfig) _validateUuid(uuid string) error {
	if matched := _model_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// OAuth2ApplicationConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ApplicationConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ApplicationConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ApplicationConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ApplicationConfigMultiError) AllErrors() []error { return m }

// OAuth2ApplicationConfigValidationError is the validation error returned by
// OAuth2ApplicationConfig.Validate if the designated constraints aren't met.
type OAuth2ApplicationConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ApplicationConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ApplicationConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ApplicationConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ApplicationConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ApplicationConfigValidationError) ErrorName() string {
	return "OAuth2ApplicationConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ApplicationConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ApplicationConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ApplicationConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ApplicationConfigValidationError{}

var _OAuth2ApplicationConfig_SubjectType_NotInLookup = map[ClientSubjectType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_GrantTypes_NotInLookup = map[GrantType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_ResponseTypes_NotInLookup = map[ResponseType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_Scopes_Pattern = regexp.MustCompile("^[\\x21\\x23-\\x5b\\x5d-\\x7e]{1,254}$")

var _OAuth2ApplicationConfig_TokenEndpointAuthMethod_NotInLookup = map[TokenEndpointAuthMethod]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_TokenEndpointAuthSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

var _OAuth2ApplicationConfig_UserinfoSignedResponseAlg_InLookup = map[string]struct{}{
	"RS256": {},
}

// Validate checks the field values on OAuth2Provider with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OAuth2Provider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2Provider with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OAuth2ProviderMultiError,
// or nil if none found.
func (m *OAuth2Provider) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2Provider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_Id_Pattern.MatchString(m.GetId()) {
		err := OAuth2ProviderValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := OAuth2ProviderValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_Name_Pattern.MatchString(m.GetName()) {
		err := OAuth2ProviderValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := OAuth2ProviderValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := OAuth2ProviderValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := OAuth2ProviderValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OAuth2ProviderMultiError(errors)
	}

	return nil
}

// OAuth2ProviderMultiError is an error wrapping multiple validation errors
// returned by OAuth2Provider.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ProviderMultiError) AllErrors() []error { return m }

// OAuth2ProviderValidationError is the validation error returned by
// OAuth2Provider.Validate if the designated constraints aren't met.
type OAuth2ProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ProviderValidationError) ErrorName() string { return "OAuth2ProviderValidationError" }

// Error satisfies the builtin error interface
func (e OAuth2ProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2Provider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ProviderValidationError{}

var _OAuth2Provider_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Provider_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _OAuth2Provider_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Provider_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ProviderConfigMultiError, or nil if none found.
func (m *OAuth2ProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetGrantTypes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "GrantTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_GrantTypes_Unique := make(map[GrantType]struct{}, len(m.GetGrantTypes()))

	for idx, item := range m.GetGrantTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_GrantTypes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_GrantTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ProviderConfig_GrantTypes_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := GrantType_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetResponseTypes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "ResponseTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_ResponseTypes_Unique := make(map[ResponseType]struct{}, len(m.GetResponseTypes()))

	for idx, item := range m.GetResponseTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_ResponseTypes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_ResponseTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ProviderConfig_ResponseTypes_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := ResponseType_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetScopes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "Scopes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_Scopes_Unique := make(map[string]struct{}, len(m.GetScopes()))

	for idx, item := range m.GetScopes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_Scopes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_Scopes_Unique[item] = struct{}{}
		}

		if !_OAuth2ProviderConfig_Scopes_Pattern.MatchString(item) {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "value does not match regex pattern \"^[\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e]{1,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetTokenEndpointAuthMethod()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTokenEndpointAuthMethod() {
		_, _ = idx, item

		if _, ok := _OAuth2ProviderConfig_TokenEndpointAuthMethod_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthMethod[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := TokenEndpointAuthMethod_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthMethod[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetTokenEndpointAuthSigningAlg()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "TokenEndpointAuthSigningAlg",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTokenEndpointAuthSigningAlg() {
		_, _ = idx, item

		if _, ok := _OAuth2ProviderConfig_TokenEndpointAuthSigningAlg_InLookup[item]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthSigningAlg[%v]", idx),
				reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetRequestUris() {
		_, _ = idx, item

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("RequestUris[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("RequestUris[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetRequestObjectSigningAlg() != "" {

		if _, ok := _OAuth2ProviderConfig_RequestObjectSigningAlg_InLookup[m.GetRequestObjectSigningAlg()]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  "RequestObjectSigningAlg",
				reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetFrontChannelLoginUri()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "FrontChannelLoginUri",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetFrontChannelLoginUri()))
		i := 0
		for key := range m.GetFrontChannelLoginUri() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFrontChannelLoginUri()[key]
			_ = val

			if utf8.RuneCountInString(key) > 32 {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value length must be at most 32 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(val); err != nil {
				err = OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(m.GetFrontChannelConsentUri()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "FrontChannelConsentUri",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetFrontChannelConsentUri()))
		i := 0
		for key := range m.GetFrontChannelConsentUri() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFrontChannelConsentUri()[key]
			_ = val

			if utf8.RuneCountInString(key) > 32 {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value length must be at most 32 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(val); err != nil {
				err = OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return OAuth2ProviderConfigMultiError(errors)
	}

	return nil
}

// OAuth2ProviderConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ProviderConfigMultiError) AllErrors() []error { return m }

// OAuth2ProviderConfigValidationError is the validation error returned by
// OAuth2ProviderConfig.Validate if the designated constraints aren't met.
type OAuth2ProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ProviderConfigValidationError) ErrorName() string {
	return "OAuth2ProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ProviderConfigValidationError{}

var _OAuth2ProviderConfig_GrantTypes_NotInLookup = map[GrantType]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_ResponseTypes_NotInLookup = map[ResponseType]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_Scopes_Pattern = regexp.MustCompile("^[\\x21\\x23-\\x5b\\x5d-\\x7e]{1,254}$")

var _OAuth2ProviderConfig_TokenEndpointAuthMethod_NotInLookup = map[TokenEndpointAuthMethod]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_TokenEndpointAuthSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

var _OAuth2ProviderConfig_RequestObjectSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

// Validate checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebAuthnProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAuthnProviderConfigMultiError, or nil if none found.
func (m *WebAuthnProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAuthnProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRelyingParties()) < 1 {
		err := WebAuthnProviderConfigValidationError{
			field:  "RelyingParties",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetRelyingParties()))
		i := 0
		for key := range m.GetRelyingParties() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRelyingParties()[key]
			_ = val

			if uri, err := url.Parse(key); err != nil {
				err = WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if l := utf8.RuneCountInString(val); l < 1 || l > 256 {
				err := WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value length must be between 1 and 256 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if _, ok := ConveyancePreference_name[int32(m.GetAttestationPreference())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "AttestationPreference",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := AuthenticatorAttachment_name[int32(m.GetAuthenticatorAttachment())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "AuthenticatorAttachment",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RequireResidentKey

	if _, ok := UserVerificationRequirement_name[int32(m.GetUserVerification())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "UserVerification",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if d := m.GetRegistrationTimeout(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = WebAuthnProviderConfigValidationError{
				field:  "RegistrationTimeout",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(900*time.Second + 0*time.Nanosecond)
			gte := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := WebAuthnProviderConfigValidationError{
					field:  "RegistrationTimeout",
					reason: "value must be inside range [0s, 15m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if d := m.GetAuthenticationTimeout(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = WebAuthnProviderConfigValidationError{
				field:  "AuthenticationTimeout",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(900*time.Second + 0*time.Nanosecond)
			gte := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := WebAuthnProviderConfigValidationError{
					field:  "AuthenticationTimeout",
					reason: "value must be inside range [0s, 15m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return WebAuthnProviderConfigMultiError(errors)
	}

	return nil
}

// WebAuthnProviderConfigMultiError is an error wrapping multiple validation
// errors returned by WebAuthnProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type WebAuthnProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAuthnProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAuthnProviderConfigMultiError) AllErrors() []error { return m }

// WebAuthnProviderConfigValidationError is the validation error returned by
// WebAuthnProviderConfig.Validate if the designated constraints aren't met.
type WebAuthnProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAuthnProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAuthnProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAuthnProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAuthnProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAuthnProviderConfigValidationError) ErrorName() string {
	return "WebAuthnProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e WebAuthnProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAuthnProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAuthnProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAuthnProviderConfigValidationError{}

// Validate checks the field values on WebAuthnSiteDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebAuthnSiteDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAuthnSiteDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAuthnSiteDefinitionMultiError, or nil if none found.
func (m *WebAuthnSiteDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAuthnSiteDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DisplayName

	// no validation rules for Origin

	// no validation rules for Icon

	if len(errors) > 0 {
		return WebAuthnSiteDefinitionMultiError(errors)
	}

	return nil
}

// WebAuthnSiteDefinitionMultiError is an error wrapping multiple validation
// errors returned by WebAuthnSiteDefinition.ValidateAll() if the designated
// constraints aren't met.
type WebAuthnSiteDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAuthnSiteDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAuthnSiteDefinitionMultiError) AllErrors() []error { return m }

// WebAuthnSiteDefinitionValidationError is the validation error returned by
// WebAuthnSiteDefinition.Validate if the designated constraints aren't met.
type WebAuthnSiteDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAuthnSiteDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAuthnSiteDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAuthnSiteDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAuthnSiteDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAuthnSiteDefinitionValidationError) ErrorName() string {
	return "WebAuthnSiteDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e WebAuthnSiteDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAuthnSiteDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAuthnSiteDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAuthnSiteDefinitionValidationError{}

// Validate checks the field values on SAFRProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SAFRProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SAFRProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SAFRProviderConfigMultiError, or nil if none found.
func (m *SAFRProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SAFRProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccountId()); l < 2 || l > 254 {
		err := SAFRProviderConfigValidationError{
			field:  "AccountId",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPassword() != "" {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 4 || l > 254 {
			err := SAFRProviderConfigValidationError{
				field:  "Password",
				reason: "value length must be between 4 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetDirectory()); l < 2 || l > 254 {
		err := SAFRProviderConfigValidationError{
			field:  "Directory",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SAFRProviderConfigMultiError(errors)
	}

	return nil
}

// SAFRProviderConfigMultiError is an error wrapping multiple validation errors
// returned by SAFRProviderConfig.ValidateAll() if the designated constraints
// aren't met.
type SAFRProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SAFRProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SAFRProviderConfigMultiError) AllErrors() []error { return m }

// SAFRProviderConfigValidationError is the validation error returned by
// SAFRProviderConfig.Validate if the designated constraints aren't met.
type SAFRProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SAFRProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SAFRProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SAFRProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SAFRProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SAFRProviderConfigValidationError) ErrorName() string {
	return "SAFRProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SAFRProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSAFRProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SAFRProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SAFRProviderConfigValidationError{}

// Validate checks the field values on SMSServiceConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SMSServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMSServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SMSServiceConfigMultiError, or nil if none found.
func (m *SMSServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SMSServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SMSServiceConfigMultiError(errors)
	}

	return nil
}

// SMSServiceConfigMultiError is an error wrapping multiple validation errors
// returned by SMSServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type SMSServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMSServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMSServiceConfigMultiError) AllErrors() []error { return m }

// SMSServiceConfigValidationError is the validation error returned by
// SMSServiceConfig.Validate if the designated constraints aren't met.
type SMSServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMSServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMSServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMSServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMSServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMSServiceConfigValidationError) ErrorName() string { return "SMSServiceConfigValidationError" }

// Error satisfies the builtin error interface
func (e SMSServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMSServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMSServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMSServiceConfigValidationError{}

// Validate checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailServiceConfigMultiError, or nil if none found.
func (m *EmailServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Default

	if all {
		switch v := interface{}(m.GetInvitationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "InvitationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResetPasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResetPasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "ResetPasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerificationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerificationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "VerificationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOneTimePasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOneTimePasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "OneTimePasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAppSpaceReadyToUseMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "AppSpaceReadyToUseMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "AppSpaceReadyToUseMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAppSpaceReadyToUseMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "AppSpaceReadyToUseMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Provider.(type) {
	case *EmailServiceConfig_Sendgrid:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetSendgrid() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Sendgrid",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSendgrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendgrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Sendgrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Mailjet:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetMailjet() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Mailjet",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMailjet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailjet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailjet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMailjet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Mailjet",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Mailgun:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetMailgun() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Mailgun",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMailgun()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailgun",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailgun",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMailgun()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Mailgun",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Amazon:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetAmazon() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Amazon",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAmazon()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAmazon()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Amazon",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EmailServiceConfigMultiError(errors)
	}

	return nil
}

// EmailServiceConfigMultiError is an error wrapping multiple validation errors
// returned by EmailServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type EmailServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailServiceConfigMultiError) AllErrors() []error { return m }

// EmailServiceConfigValidationError is the validation error returned by
// EmailServiceConfig.Validate if the designated constraints aren't met.
type EmailServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailServiceConfigValidationError) ErrorName() string {
	return "EmailServiceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EmailServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailServiceConfigValidationError{}

// Validate checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Email) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmailMultiError, or nil if none found.
func (m *Email) ValidateAll() error {
	return m.validate(true)
}

func (m *Email) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) > 254 {
		err := EmailValidationError{
			field:  "Address",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetAddress()); err != nil {
		err = EmailValidationError{
			field:  "Address",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetName() != "" {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 503 {
			err := EmailValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return EmailMultiError(errors)
	}

	return nil
}

func (m *Email) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Email) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// EmailMultiError is an error wrapping multiple validation errors returned by
// Email.ValidateAll() if the designated constraints aren't met.
type EmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMultiError) AllErrors() []error { return m }

// EmailValidationError is the validation error returned by Email.Validate if
// the designated constraints aren't met.
type EmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailValidationError) ErrorName() string { return "EmailValidationError" }

// Error satisfies the builtin error interface
func (e EmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailValidationError{}

// Validate checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendGridProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendGridProviderConfigMultiError, or nil if none found.
func (m *SendGridProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SendGridProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := SendGridProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for SandboxMode

	if wrapper := m.GetIpPoolName(); wrapper != nil {

		if wrapper.GetValue() != "" {

			if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 64 {
				err := SendGridProviderConfigValidationError{
					field:  "IpPoolName",
					reason: "value length must be between 2 and 64 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if wrapper := m.GetHost(); wrapper != nil {

		if wrapper.GetValue() != "" {

			if l := utf8.RuneCountInString(wrapper.GetValue()); l < 10 || l > 254 {
				err := SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value length must be between 10 and 254 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(wrapper.GetValue()); err != nil {
				err = SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return SendGridProviderConfigMultiError(errors)
	}

	return nil
}

// SendGridProviderConfigMultiError is an error wrapping multiple validation
// errors returned by SendGridProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type SendGridProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendGridProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendGridProviderConfigMultiError) AllErrors() []error { return m }

// SendGridProviderConfigValidationError is the validation error returned by
// SendGridProviderConfig.Validate if the designated constraints aren't met.
type SendGridProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendGridProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendGridProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendGridProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendGridProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendGridProviderConfigValidationError) ErrorName() string {
	return "SendGridProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SendGridProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendGridProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendGridProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendGridProviderConfigValidationError{}

// Validate checks the field values on MailJetProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MailJetProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MailJetProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MailJetProviderConfigMultiError, or nil if none found.
func (m *MailJetProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MailJetProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := MailJetProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for SandboxMode

	// no validation rules for UrlTags

	if all {
		switch v := interface{}(m.GetCustomCampaign()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MailJetProviderConfigValidationError{
					field:  "CustomCampaign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MailJetProviderConfigValidationError{
					field:  "CustomCampaign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomCampaign()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MailJetProviderConfigValidationError{
				field:  "CustomCampaign",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MailJetProviderConfigMultiError(errors)
	}

	return nil
}

// MailJetProviderConfigMultiError is an error wrapping multiple validation
// errors returned by MailJetProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type MailJetProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MailJetProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MailJetProviderConfigMultiError) AllErrors() []error { return m }

// MailJetProviderConfigValidationError is the validation error returned by
// MailJetProviderConfig.Validate if the designated constraints aren't met.
type MailJetProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MailJetProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MailJetProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MailJetProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MailJetProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MailJetProviderConfigValidationError) ErrorName() string {
	return "MailJetProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MailJetProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMailJetProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MailJetProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MailJetProviderConfigValidationError{}

// Validate checks the field values on MailgunProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MailgunProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MailgunProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MailgunProviderConfigMultiError, or nil if none found.
func (m *MailgunProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MailgunProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := MailgunProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MailgunProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MailgunProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MailgunProviderConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MailgunProviderConfigMultiError(errors)
	}

	return nil
}

// MailgunProviderConfigMultiError is an error wrapping multiple validation
// errors returned by MailgunProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type MailgunProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MailgunProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MailgunProviderConfigMultiError) AllErrors() []error { return m }

// MailgunProviderConfigValidationError is the validation error returned by
// MailgunProviderConfig.Validate if the designated constraints aren't met.
type MailgunProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MailgunProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MailgunProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MailgunProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MailgunProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MailgunProviderConfigValidationError) ErrorName() string {
	return "MailgunProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MailgunProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMailgunProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MailgunProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MailgunProviderConfigValidationError{}

// Validate checks the field values on AmazonSESProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AmazonSESProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmazonSESProviderConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmazonSESProviderConfigMultiError, or nil if none found.
func (m *AmazonSESProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AmazonSESProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccessKeyId()); l < 25 || l > 254 {
		err := AmazonSESProviderConfigValidationError{
			field:  "AccessKeyId",
			reason: "value length must be between 25 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecretAccessKey() != "" {

		if l := utf8.RuneCountInString(m.GetSecretAccessKey()); l < 25 || l > 254 {
			err := AmazonSESProviderConfigValidationError{
				field:  "SecretAccessKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 2 || l > 20 {
		err := AmazonSESProviderConfigValidationError{
			field:  "Region",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetConfigurationSetName() != "" {

		if utf8.RuneCountInString(m.GetConfigurationSetName()) > 254 {
			err := AmazonSESProviderConfigValidationError{
				field:  "ConfigurationSetName",
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmazonSESProviderConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetFeedbackForwardingEmailAddress() != "" {

		if utf8.RuneCountInString(m.GetFeedbackForwardingEmailAddress()) > 503 {
			err := AmazonSESProviderConfigValidationError{
				field:  "FeedbackForwardingEmailAddress",
				reason: "value length must be at most 503 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateEmail(m.GetFeedbackForwardingEmailAddress()); err != nil {
			err = AmazonSESProviderConfigValidationError{
				field:  "FeedbackForwardingEmailAddress",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetReplyToAddresses() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 503 {
			err := AmazonSESProviderConfigValidationError{
				field:  fmt.Sprintf("ReplyToAddresses[%v]", idx),
				reason: "value length must be at most 503 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateEmail(item); err != nil {
			err = AmazonSESProviderConfigValidationError{
				field:  fmt.Sprintf("ReplyToAddresses[%v]", idx),
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return AmazonSESProviderConfigMultiError(errors)
	}

	return nil
}

func (m *AmazonSESProviderConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *AmazonSESProviderConfig) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// AmazonSESProviderConfigMultiError is an error wrapping multiple validation
// errors returned by AmazonSESProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type AmazonSESProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmazonSESProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmazonSESProviderConfigMultiError) AllErrors() []error { return m }

// AmazonSESProviderConfigValidationError is the validation error returned by
// AmazonSESProviderConfig.Validate if the designated constraints aren't met.
type AmazonSESProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmazonSESProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmazonSESProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmazonSESProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmazonSESProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmazonSESProviderConfigValidationError) ErrorName() string {
	return "AmazonSESProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AmazonSESProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmazonSESProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmazonSESProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmazonSESProviderConfigValidationError{}

// Validate checks the field values on EmailDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailDefinitionMultiError, or nil if none found.
func (m *EmailDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Email.(type) {
	case *EmailDefinition_Template:
		if v == nil {
			err := EmailDefinitionValidationError{
				field:  "Email",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetTemplate() == nil {
			err := EmailDefinitionValidationError{
				field:  "Template",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTemplate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailDefinitionValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailDefinition_Message:
		if v == nil {
			err := EmailDefinitionValidationError{
				field:  "Email",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetMessage() == nil {
			err := EmailDefinitionValidationError{
				field:  "Message",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailDefinitionValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EmailDefinitionMultiError(errors)
	}

	return nil
}

// EmailDefinitionMultiError is an error wrapping multiple validation errors
// returned by EmailDefinition.ValidateAll() if the designated constraints
// aren't met.
type EmailDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailDefinitionMultiError) AllErrors() []error { return m }

// EmailDefinitionValidationError is the validation error returned by
// EmailDefinition.Validate if the designated constraints aren't met.
type EmailDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailDefinitionValidationError) ErrorName() string { return "EmailDefinitionValidationError" }

// Error satisfies the builtin error interface
func (e EmailDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailDefinitionValidationError{}

// Validate checks the field values on EmailTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailTemplateMultiError, or
// nil if none found.
func (m *EmailTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTemplateId()); l < 1 || l > 254 {
		err := EmailTemplateValidationError{
			field:  "TemplateId",
			reason: "value length must be between 1 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetTemplateVersion(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 1 || l > 254 {
			err := EmailTemplateValidationError{
				field:  "TemplateVersion",
				reason: "value length must be between 1 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "ReplyTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Cc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBcc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Bcc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSubject() != "" {

		if l := utf8.RuneCountInString(m.GetSubject()); l < 1 || l > 503 {
			err := EmailTemplateValidationError{
				field:  "Subject",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Headers

	// no validation rules for CustomArgs

	{
		sorted_keys := make([]string, len(m.GetDynamicTemplateValues()))
		i := 0
		for key := range m.GetDynamicTemplateValues() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDynamicTemplateValues()[key]
			_ = val

			// no validation rules for DynamicTemplateValues[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmailTemplateValidationError{
						field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetEventPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "EventPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TemplateArn

	if len(errors) > 0 {
		return EmailTemplateMultiError(errors)
	}

	return nil
}

// EmailTemplateMultiError is an error wrapping multiple validation errors
// returned by EmailTemplate.ValidateAll() if the designated constraints
// aren't met.
type EmailTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailTemplateMultiError) AllErrors() []error { return m }

// EmailTemplateValidationError is the validation error returned by
// EmailTemplate.Validate if the designated constraints aren't met.
type EmailTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailTemplateValidationError) ErrorName() string { return "EmailTemplateValidationError" }

// Error satisfies the builtin error interface
func (e EmailTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailTemplateValidationError{}

// Validate checks the field values on EmailAttachment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailAttachmentMultiError, or nil if none found.
func (m *EmailAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentType

	if all {
		switch v := interface{}(m.GetContentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailAttachmentValidationError{
					field:  "ContentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailAttachmentValidationError{
					field:  "ContentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailAttachmentValidationError{
				field:  "ContentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Inline

	// no validation rules for FileName

	// no validation rules for Content

	if len(errors) > 0 {
		return EmailAttachmentMultiError(errors)
	}

	return nil
}

// EmailAttachmentMultiError is an error wrapping multiple validation errors
// returned by EmailAttachment.ValidateAll() if the designated constraints
// aren't met.
type EmailAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailAttachmentMultiError) AllErrors() []error { return m }

// EmailAttachmentValidationError is the validation error returned by
// EmailAttachment.Validate if the designated constraints aren't met.
type EmailAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailAttachmentValidationError) ErrorName() string { return "EmailAttachmentValidationError" }

// Error satisfies the builtin error interface
func (e EmailAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailAttachmentValidationError{}

// Validate checks the field values on EmailMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailMessageMultiError, or
// nil if none found.
func (m *EmailMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "ReplyTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Cc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBcc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Bcc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSubject() != "" {

		if l := utf8.RuneCountInString(m.GetSubject()); l < 1 || l > 503 {
			err := EmailMessageValidationError{
				field:  "Subject",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for TextContent

	// no validation rules for HtmlContent

	// no validation rules for Headers

	// no validation rules for CustomArgs

	{
		sorted_keys := make([]string, len(m.GetDynamicTemplateValues()))
		i := 0
		for key := range m.GetDynamicTemplateValues() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDynamicTemplateValues()[key]
			_ = val

			// no validation rules for DynamicTemplateValues[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmailMessageValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmailMessageValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmailMessageValidationError{
						field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetEventPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "EventPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmailMessageMultiError(errors)
	}

	return nil
}

// EmailMessageMultiError is an error wrapping multiple validation errors
// returned by EmailMessage.ValidateAll() if the designated constraints aren't met.
type EmailMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMessageMultiError) AllErrors() []error { return m }

// EmailMessageValidationError is the validation error returned by
// EmailMessage.Validate if the designated constraints aren't met.
type EmailMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailMessageValidationError) ErrorName() string { return "EmailMessageValidationError" }

// Error satisfies the builtin error interface
func (e EmailMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailMessageValidationError{}

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPolicy()) > 512000 {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Policy",
			reason: "value length must be at most 512000 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := AuthorizationPolicyConfig_Status_name[int32(m.GetStatus())]; !ok {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTags()) > 0 {

		_AuthorizationPolicyConfig_Tags_Unique := make(map[string]struct{}, len(m.GetTags()))

		for idx, item := range m.GetTags() {
			_, _ = idx, item

			if _, exists := _AuthorizationPolicyConfig_Tags_Unique[item]; exists {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_AuthorizationPolicyConfig_Tags_Unique[item] = struct{}{}
			}

			if l := utf8.RuneCountInString(item); l < 1 || l > 20 {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value length must be between 1 and 20 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_AuthorizationPolicyConfig_Tags_Pattern.MatchString(item) {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if all {
		switch v := interface{}(m.GetBuilder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuilder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorizationPolicyConfigValidationError{
				field:  "Builder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

var _AuthorizationPolicyConfig_Tags_Pattern = regexp.MustCompile("^[a-zA-Z0-9]+$")

// Validate checks the field values on AuditSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfigMultiError, or nil if none found.
func (m *AuditSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofProviderPresent := false
	switch v := m.Provider.(type) {
	case *AuditSinkConfig_Kafka:
		if v == nil {
			err := AuditSinkConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProviderPresent = true

		if m.GetKafka() == nil {
			err := AuditSinkConfigValidationError{
				field:  "Kafka",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditSinkConfigValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofProviderPresent {
		err := AuditSinkConfigValidationError{
			field:  "Provider",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuditSinkConfigMultiError(errors)
	}

	return nil
}

// AuditSinkConfigMultiError is an error wrapping multiple validation errors
// returned by AuditSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type AuditSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfigMultiError) AllErrors() []error { return m }

// AuditSinkConfigValidationError is the validation error returned by
// AuditSinkConfig.Validate if the designated constraints aren't met.
type AuditSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfigValidationError) ErrorName() string { return "AuditSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuditSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfigValidationError{}

// Validate checks the field values on KafkaSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KafkaSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KafkaSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KafkaSinkConfigMultiError, or nil if none found.
func (m *KafkaSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KafkaSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetBrokers()) > 0 {

		_KafkaSinkConfig_Brokers_Unique := make(map[string]struct{}, len(m.GetBrokers()))

		for idx, item := range m.GetBrokers() {
			_, _ = idx, item

			if _, exists := _KafkaSinkConfig_Brokers_Unique[item]; exists {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_KafkaSinkConfig_Brokers_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 8 {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value length must be at least 8 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if _, err := url.Parse(item); err != nil {
				err = KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if l := utf8.RuneCountInString(m.GetTopic()); l < 1 || l > 249 {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value length must be between 1 and 249 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_KafkaSinkConfig_Topic_Pattern.MatchString(m.GetTopic()) {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9._-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return KafkaSinkConfigMultiError(errors)
	}

	return nil
}

// KafkaSinkConfigMultiError is an error wrapping multiple validation errors
// returned by KafkaSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type KafkaSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KafkaSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KafkaSinkConfigMultiError) AllErrors() []error { return m }

// KafkaSinkConfigValidationError is the validation error returned by
// KafkaSinkConfig.Validate if the designated constraints aren't met.
type KafkaSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KafkaSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KafkaSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KafkaSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KafkaSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KafkaSinkConfigValidationError) ErrorName() string { return "KafkaSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e KafkaSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKafkaSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KafkaSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KafkaSinkConfigValidationError{}

var _KafkaSinkConfig_Topic_Pattern = regexp.MustCompile("^[a-zA-Z0-9._-]+$")

// Validate checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentConfigurationMultiError, or nil if none found.
func (m *ConsentConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPurpose()) > 1024 {
		err := ConsentConfigurationValidationError{
			field:  "Purpose",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDataPoints()) < 1 {
		err := ConsentConfigurationValidationError{
			field:  "DataPoints",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ConsentConfiguration_DataPoints_Unique := make(map[string]struct{}, len(m.GetDataPoints()))

	for idx, item := range m.GetDataPoints() {
		_, _ = idx, item

		if _, exists := _ConsentConfiguration_DataPoints_Unique[item]; exists {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ConsentConfiguration_DataPoints_Unique[item] = struct{}{}
		}

		if l := utf8.RuneCountInString(item); l < 1 || l > 1024 {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value length must be between 1 and 1024 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(item, "{") {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value does not have prefix \"{\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConsentConfiguration_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetValidityPeriod(); val < 86400 || val > 63072000 {
		err := ConsentConfigurationValidationError{
			field:  "ValidityPeriod",
			reason: "value must be inside range [86400, 63072000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RevokeAfterUse

	if len(errors) > 0 {
		return ConsentConfigurationMultiError(errors)
	}

	return nil
}

// ConsentConfigurationMultiError is an error wrapping multiple validation
// errors returned by ConsentConfiguration.ValidateAll() if the designated
// constraints aren't met.
type ConsentConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentConfigurationMultiError) AllErrors() []error { return m }

// ConsentConfigurationValidationError is the validation error returned by
// ConsentConfiguration.Validate if the designated constraints aren't met.
type ConsentConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentConfigurationValidationError) ErrorName() string {
	return "ConsentConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentConfigurationValidationError{}

var _ConsentConfiguration_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfigMultiError, or nil if none found.
func (m *TokenIntrospectConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			if utf8.RuneCountInString(key) > 256 {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value length must be at most 256 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_TokenIntrospectConfig_ClaimsMapping_Pattern.MatchString(key) {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_][a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if val == nil {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value is required",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenIntrospectConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetIkgNodeType()); l < 2 || l > 64 {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_TokenIntrospectConfig_IkgNodeType_Pattern.MatchString(m.GetIkgNodeType()) {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PerformUpsert

	oneofTokenMatcherPresent := false
	switch v := m.TokenMatcher.(type) {
	case *TokenIntrospectConfig_Jwt:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetJwt() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Jwt",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Opaque_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetOpaque() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Opaque",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpaque()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTokenMatcherPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "TokenMatcher",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}
	oneofValidationPresent := false
	switch v := m.Validation.(type) {
	case *TokenIntrospectConfig_Offline_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOffline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Offline",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Online_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOnline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Online",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Online",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofValidationPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "Validation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfigMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfigMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfigMultiError) AllErrors() []error { return m }

// TokenIntrospectConfigValidationError is the validation error returned by
// TokenIntrospectConfig.Validate if the designated constraints aren't met.
type TokenIntrospectConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfigValidationError) ErrorName() string {
	return "TokenIntrospectConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfigValidationError{}

var _TokenIntrospectConfig_ClaimsMapping_Pattern = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_]+$")

var _TokenIntrospectConfig_IkgNodeType_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

// Validate checks the field values on ConsentDataPoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPointMultiError, or nil if none found.
func (m *ConsentDataPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuery()) > 1024 {
		err := ConsentDataPointValidationError{
			field:  "Query",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetReturns()); l < 1 || l > 20 {
		err := ConsentDataPointValidationError{
			field:  "Returns",
			reason: "value must contain between 1 and 20 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetReturns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConsentDataPointValidationError{
					field:  fmt.Sprintf("Returns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConsentDataPointMultiError(errors)
	}

	return nil
}

// ConsentDataPointMultiError is an error wrapping multiple validation errors
// returned by ConsentDataPoint.ValidateAll() if the designated constraints
// aren't met.
type ConsentDataPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPointMultiError) AllErrors() []error { return m }

// ConsentDataPointValidationError is the validation error returned by
// ConsentDataPoint.Validate if the designated constraints aren't met.
type ConsentDataPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPointValidationError) ErrorName() string { return "ConsentDataPointValidationError" }

// Error satisfies the builtin error interface
func (e ConsentDataPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPointValidationError{}

// Validate checks the field values on TokenIntrospectConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_JWTMultiError, or nil if none found.
func (m *TokenIntrospectConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetIssuer()); err != nil {
		err = TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAudience()); l < 1 || l > 150 {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Audience",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig_JWT.ValidateAll() if the
// designated constraints aren't met.
type TokenIntrospectConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_JWTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_JWTMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_JWTValidationError is the validation error returned by
// TokenIntrospectConfig_JWT.Validate if the designated constraints aren't met.
type TokenIntrospectConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_JWTValidationError) ErrorName() string {
	return "TokenIntrospectConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_JWTValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Opaque) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OpaqueMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Opaque) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Opaque) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenIntrospectConfig_OpaqueMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OpaqueMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Opaque.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OpaqueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OpaqueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OpaqueMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OpaqueValidationError is the validation error returned
// by TokenIntrospectConfig_Opaque.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OpaqueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OpaqueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OpaqueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OpaqueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OpaqueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OpaqueValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OpaqueValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OpaqueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Opaque.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OpaqueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OpaqueValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Offline with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OfflineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPublicJwks()) > 10 {
		err := TokenIntrospectConfig_OfflineValidationError{
			field:  "PublicJwks",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPublicJwks() {
		_, _ = idx, item

		if l := len(item); l < 96 || l > 8192 {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value length must be between 96 and 8192 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasPrefix(item, []uint8{0x7B}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have prefix \"\\x7B\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasSuffix(item, []uint8{0x7D}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have suffix \"\\x7D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Offline.ValidateAll()
// if the designated constraints aren't met.
type TokenIntrospectConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OfflineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OfflineValidationError is the validation error
// returned by TokenIntrospectConfig_Offline.Validate if the designated
// constraints aren't met.
type TokenIntrospectConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OfflineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OfflineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Online) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OnlineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Online) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Online) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserinfoEndpoint() != "" {

		if uri, err := url.Parse(m.GetUserinfoEndpoint()); err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if d := m.GetCacheTtl(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "CacheTtl",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(3600*time.Second + 0*time.Nanosecond)

			if dur > lte {
				err := TokenIntrospectConfig_OnlineValidationError{
					field:  "CacheTtl",
					reason: "value must be less than or equal to 1h0m0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OnlineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OnlineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Online.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OnlineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OnlineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OnlineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OnlineValidationError is the validation error returned
// by TokenIntrospectConfig_Online.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OnlineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OnlineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OnlineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OnlineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OnlineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OnlineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OnlineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OnlineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Online.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OnlineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OnlineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_ClaimMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetSelector()); l < 1 || l > 200 {
		err := TokenIntrospectConfig_ClaimValidationError{
			field:  "Selector",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_ClaimMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Claim.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_ClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_ClaimValidationError is the validation error returned
// by TokenIntrospectConfig_Claim.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_ClaimValidationError) ErrorName() string {
	return "TokenIntrospectConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_ClaimValidationError{}

// Validate checks the field values on ConsentDataPoint_Return with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint_Return) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint_Return with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPoint_ReturnMultiError, or nil if none found.
func (m *ConsentDataPoint_Return) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint_Return) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetVariable()) > 32 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Variable",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetProperties()) > 50 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Properties",
			reason: "value must contain no more than 50 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConsentDataPoint_ReturnMultiError(errors)
	}

	return nil
}

// ConsentDataPoint_ReturnMultiError is an error wrapping multiple validation
// errors returned by ConsentDataPoint_Return.ValidateAll() if the designated
// constraints aren't met.
type ConsentDataPoint_ReturnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPoint_ReturnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPoint_ReturnMultiError) AllErrors() []error { return m }

// ConsentDataPoint_ReturnValidationError is the validation error returned by
// ConsentDataPoint_Return.Validate if the designated constraints aren't met.
type ConsentDataPoint_ReturnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPoint_ReturnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPoint_ReturnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPoint_ReturnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPoint_ReturnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPoint_ReturnValidationError) ErrorName() string {
	return "ConsentDataPoint_ReturnValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentDataPoint_ReturnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint_Return.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPoint_ReturnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPoint_ReturnValidationError{}
