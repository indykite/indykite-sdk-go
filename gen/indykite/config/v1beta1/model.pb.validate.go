// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/config/v1beta1/model.proto

package configv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UniqueNameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UniqueNameIdentifierMultiError, or nil if none found.
func (m *UniqueNameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *UniqueNameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLocation()); l < 22 || l > 254 {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Location_Pattern.MatchString(m.GetLocation()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Name_Pattern.MatchString(m.GetName()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UniqueNameIdentifierMultiError(errors)
	}

	return nil
}

// UniqueNameIdentifierMultiError is an error wrapping multiple validation
// errors returned by UniqueNameIdentifier.ValidateAll() if the designated
// constraints aren't met.
type UniqueNameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UniqueNameIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UniqueNameIdentifierMultiError) AllErrors() []error { return m }

// UniqueNameIdentifierValidationError is the validation error returned by
// UniqueNameIdentifier.Validate if the designated constraints aren't met.
type UniqueNameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UniqueNameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UniqueNameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UniqueNameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UniqueNameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UniqueNameIdentifierValidationError) ErrorName() string {
	return "UniqueNameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e UniqueNameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUniqueNameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UniqueNameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UniqueNameIdentifierValidationError{}

var _UniqueNameIdentifier_Location_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _UniqueNameIdentifier_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on Customer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Customer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerMultiError, or nil
// if none found.
func (m *Customer) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Id_Pattern.MatchString(m.GetId()) {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Name_Pattern.MatchString(m.GetName()) {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := CustomerValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := CustomerValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if len(errors) > 0 {
		return CustomerMultiError(errors)
	}

	return nil
}

// CustomerMultiError is an error wrapping multiple validation errors returned
// by Customer.ValidateAll() if the designated constraints aren't met.
type CustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerMultiError) AllErrors() []error { return m }

// CustomerValidationError is the validation error returned by
// Customer.Validate if the designated constraints aren't met.
type CustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerValidationError) ErrorName() string { return "CustomerValidationError" }

// Error satisfies the builtin error interface
func (e CustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerValidationError{}

var _Customer_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Customer_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on ApplicationSpace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceMultiError, or nil if none found.
func (m *ApplicationSpace) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationSpaceValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IkgStatus

	// no validation rules for Region

	if len(errors) > 0 {
		return ApplicationSpaceMultiError(errors)
	}

	return nil
}

// ApplicationSpaceMultiError is an error wrapping multiple validation errors
// returned by ApplicationSpace.ValidateAll() if the designated constraints
// aren't met.
type ApplicationSpaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceMultiError) AllErrors() []error { return m }

// ApplicationSpaceValidationError is the validation error returned by
// ApplicationSpace.Validate if the designated constraints aren't met.
type ApplicationSpaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceValidationError) ErrorName() string { return "ApplicationSpaceValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationSpaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceValidationError{}

var _ApplicationSpace_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationSpace_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentMultiError, or nil if none found.
func (m *ApplicationAgent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationAgentValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentMultiError(errors)
	}

	return nil
}

// ApplicationAgentMultiError is an error wrapping multiple validation errors
// returned by ApplicationAgent.ValidateAll() if the designated constraints
// aren't met.
type ApplicationAgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentMultiError) AllErrors() []error { return m }

// ApplicationAgentValidationError is the validation error returned by
// ApplicationAgent.Validate if the designated constraints aren't met.
type ApplicationAgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentValidationError) ErrorName() string { return "ApplicationAgentValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationAgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentValidationError{}

var _ApplicationAgent_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationAgent_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgentCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialMultiError, or nil if none found.
func (m *ApplicationAgentCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationAgentId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationAgentId_Pattern.MatchString(m.GetApplicationAgentId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialMultiError is an error wrapping multiple
// validation errors returned by ApplicationAgentCredential.ValidateAll() if
// the designated constraints aren't met.
type ApplicationAgentCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialValidationError is the validation error returned
// by ApplicationAgentCredential.Validate if the designated constraints aren't met.
type ApplicationAgentCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialValidationError) ErrorName() string {
	return "ApplicationAgentCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialValidationError{}

var _ApplicationAgentCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ApplicationAgentCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationAgentId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceAccountMultiError,
// or nil if none found.
func (m *ServiceAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Name_Pattern.MatchString(m.GetName()) {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccount_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ServiceAccountMultiError(errors)
	}

	return nil
}

// ServiceAccountMultiError is an error wrapping multiple validation errors
// returned by ServiceAccount.ValidateAll() if the designated constraints
// aren't met.
type ServiceAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountMultiError) AllErrors() []error { return m }

// ServiceAccountValidationError is the validation error returned by
// ServiceAccount.Validate if the designated constraints aren't met.
type ServiceAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountValidationError) ErrorName() string { return "ServiceAccountValidationError" }

// Error satisfies the builtin error interface
func (e ServiceAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountValidationError{}

var _ServiceAccount_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ServiceAccount_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccountCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialMultiError, or nil if none found.
func (m *ServiceAccountCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccountCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetServiceAccountId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_ServiceAccountId_Pattern.MatchString(m.GetServiceAccountId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialMultiError is an error wrapping multiple validation
// errors returned by ServiceAccountCredential.ValidateAll() if the designated
// constraints aren't met.
type ServiceAccountCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialValidationError is the validation error returned by
// ServiceAccountCredential.Validate if the designated constraints aren't met.
type ServiceAccountCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialValidationError) ErrorName() string {
	return "ServiceAccountCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialValidationError{}

var _ServiceAccountCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ServiceAccountCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_ServiceAccountId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ConfigNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigNodeMultiError, or
// nil if none found.
func (m *ConfigNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Id_Pattern.MatchString(m.GetId()) {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Name_Pattern.MatchString(m.GetName()) {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ConfigNodeValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *ConfigNode_AuditSinkConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetAuditSinkConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "AuditSinkConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuditSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetAuthorizationPolicyConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "AuthorizationPolicyConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_ConsentConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetConsentConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "ConsentConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_TokenIntrospectConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetTokenIntrospectConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "TokenIntrospectConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenIntrospectConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenIntrospectConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "TokenIntrospectConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := ConfigNodeValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigNodeMultiError(errors)
	}

	return nil
}

// ConfigNodeMultiError is an error wrapping multiple validation errors
// returned by ConfigNode.ValidateAll() if the designated constraints aren't met.
type ConfigNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigNodeMultiError) AllErrors() []error { return m }

// ConfigNodeValidationError is the validation error returned by
// ConfigNode.Validate if the designated constraints aren't met.
type ConfigNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigNodeValidationError) ErrorName() string { return "ConfigNodeValidationError" }

// Error satisfies the builtin error interface
func (e ConfigNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigNodeValidationError{}

var _ConfigNode_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ConfigNode_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPolicy()) > 512000 {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Policy",
			reason: "value length must be at most 512000 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := AuthorizationPolicyConfig_Status_name[int32(m.GetStatus())]; !ok {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTags()) > 0 {

		_AuthorizationPolicyConfig_Tags_Unique := make(map[string]struct{}, len(m.GetTags()))

		for idx, item := range m.GetTags() {
			_, _ = idx, item

			if _, exists := _AuthorizationPolicyConfig_Tags_Unique[item]; exists {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_AuthorizationPolicyConfig_Tags_Unique[item] = struct{}{}
			}

			if l := utf8.RuneCountInString(item); l < 1 || l > 20 {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value length must be between 1 and 20 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_AuthorizationPolicyConfig_Tags_Pattern.MatchString(item) {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if all {
		switch v := interface{}(m.GetBuilder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuilder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorizationPolicyConfigValidationError{
				field:  "Builder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

var _AuthorizationPolicyConfig_Tags_Pattern = regexp.MustCompile("^[a-zA-Z0-9]+$")

// Validate checks the field values on AuditSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfigMultiError, or nil if none found.
func (m *AuditSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofProviderPresent := false
	switch v := m.Provider.(type) {
	case *AuditSinkConfig_Kafka:
		if v == nil {
			err := AuditSinkConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProviderPresent = true

		if m.GetKafka() == nil {
			err := AuditSinkConfigValidationError{
				field:  "Kafka",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditSinkConfigValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofProviderPresent {
		err := AuditSinkConfigValidationError{
			field:  "Provider",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuditSinkConfigMultiError(errors)
	}

	return nil
}

// AuditSinkConfigMultiError is an error wrapping multiple validation errors
// returned by AuditSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type AuditSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfigMultiError) AllErrors() []error { return m }

// AuditSinkConfigValidationError is the validation error returned by
// AuditSinkConfig.Validate if the designated constraints aren't met.
type AuditSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfigValidationError) ErrorName() string { return "AuditSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuditSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfigValidationError{}

// Validate checks the field values on KafkaSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KafkaSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KafkaSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KafkaSinkConfigMultiError, or nil if none found.
func (m *KafkaSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KafkaSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetBrokers()) > 0 {

		_KafkaSinkConfig_Brokers_Unique := make(map[string]struct{}, len(m.GetBrokers()))

		for idx, item := range m.GetBrokers() {
			_, _ = idx, item

			if _, exists := _KafkaSinkConfig_Brokers_Unique[item]; exists {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_KafkaSinkConfig_Brokers_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 8 {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value length must be at least 8 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if _, err := url.Parse(item); err != nil {
				err = KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if l := utf8.RuneCountInString(m.GetTopic()); l < 1 || l > 249 {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value length must be between 1 and 249 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_KafkaSinkConfig_Topic_Pattern.MatchString(m.GetTopic()) {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9._-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return KafkaSinkConfigMultiError(errors)
	}

	return nil
}

// KafkaSinkConfigMultiError is an error wrapping multiple validation errors
// returned by KafkaSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type KafkaSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KafkaSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KafkaSinkConfigMultiError) AllErrors() []error { return m }

// KafkaSinkConfigValidationError is the validation error returned by
// KafkaSinkConfig.Validate if the designated constraints aren't met.
type KafkaSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KafkaSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KafkaSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KafkaSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KafkaSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KafkaSinkConfigValidationError) ErrorName() string { return "KafkaSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e KafkaSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKafkaSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KafkaSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KafkaSinkConfigValidationError{}

var _KafkaSinkConfig_Topic_Pattern = regexp.MustCompile("^[a-zA-Z0-9._-]+$")

// Validate checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentConfigurationMultiError, or nil if none found.
func (m *ConsentConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPurpose()) > 1024 {
		err := ConsentConfigurationValidationError{
			field:  "Purpose",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDataPoints()) < 1 {
		err := ConsentConfigurationValidationError{
			field:  "DataPoints",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ConsentConfiguration_DataPoints_Unique := make(map[string]struct{}, len(m.GetDataPoints()))

	for idx, item := range m.GetDataPoints() {
		_, _ = idx, item

		if _, exists := _ConsentConfiguration_DataPoints_Unique[item]; exists {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ConsentConfiguration_DataPoints_Unique[item] = struct{}{}
		}

		if l := utf8.RuneCountInString(item); l < 1 || l > 1024 {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value length must be between 1 and 1024 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(item, "{") {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value does not have prefix \"{\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConsentConfiguration_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetValidityPeriod(); val < 86400 || val > 63072000 {
		err := ConsentConfigurationValidationError{
			field:  "ValidityPeriod",
			reason: "value must be inside range [86400, 63072000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RevokeAfterUse

	// no validation rules for TokenStatus

	if len(errors) > 0 {
		return ConsentConfigurationMultiError(errors)
	}

	return nil
}

// ConsentConfigurationMultiError is an error wrapping multiple validation
// errors returned by ConsentConfiguration.ValidateAll() if the designated
// constraints aren't met.
type ConsentConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentConfigurationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentConfigurationMultiError) AllErrors() []error { return m }

// ConsentConfigurationValidationError is the validation error returned by
// ConsentConfiguration.Validate if the designated constraints aren't met.
type ConsentConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentConfigurationValidationError) ErrorName() string {
	return "ConsentConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentConfigurationValidationError{}

var _ConsentConfiguration_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfigMultiError, or nil if none found.
func (m *TokenIntrospectConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			if utf8.RuneCountInString(key) > 256 {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value length must be at most 256 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_TokenIntrospectConfig_ClaimsMapping_Pattern.MatchString(key) {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_][a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if val == nil {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value is required",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenIntrospectConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if l := utf8.RuneCountInString(m.GetIkgNodeType()); l < 2 || l > 64 {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_TokenIntrospectConfig_IkgNodeType_Pattern.MatchString(m.GetIkgNodeType()) {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PerformUpsert

	oneofTokenMatcherPresent := false
	switch v := m.TokenMatcher.(type) {
	case *TokenIntrospectConfig_Jwt:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetJwt() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Jwt",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Opaque_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetOpaque() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Opaque",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpaque()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTokenMatcherPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "TokenMatcher",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}
	oneofValidationPresent := false
	switch v := m.Validation.(type) {
	case *TokenIntrospectConfig_Offline_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOffline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Offline",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Online_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOnline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Online",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Online",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofValidationPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "Validation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfigMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfigMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfigMultiError) AllErrors() []error { return m }

// TokenIntrospectConfigValidationError is the validation error returned by
// TokenIntrospectConfig.Validate if the designated constraints aren't met.
type TokenIntrospectConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfigValidationError) ErrorName() string {
	return "TokenIntrospectConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfigValidationError{}

var _TokenIntrospectConfig_ClaimsMapping_Pattern = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_]+$")

var _TokenIntrospectConfig_IkgNodeType_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

// Validate checks the field values on ConsentDataPoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPointMultiError, or nil if none found.
func (m *ConsentDataPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuery()) > 1024 {
		err := ConsentDataPointValidationError{
			field:  "Query",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetReturns()); l < 1 || l > 20 {
		err := ConsentDataPointValidationError{
			field:  "Returns",
			reason: "value must contain between 1 and 20 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetReturns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConsentDataPointValidationError{
					field:  fmt.Sprintf("Returns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConsentDataPointMultiError(errors)
	}

	return nil
}

// ConsentDataPointMultiError is an error wrapping multiple validation errors
// returned by ConsentDataPoint.ValidateAll() if the designated constraints
// aren't met.
type ConsentDataPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPointMultiError) AllErrors() []error { return m }

// ConsentDataPointValidationError is the validation error returned by
// ConsentDataPoint.Validate if the designated constraints aren't met.
type ConsentDataPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPointValidationError) ErrorName() string { return "ConsentDataPointValidationError" }

// Error satisfies the builtin error interface
func (e ConsentDataPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPointValidationError{}

// Validate checks the field values on TokenIntrospectConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_JWTMultiError, or nil if none found.
func (m *TokenIntrospectConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetIssuer()); err != nil {
		err = TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAudience()); l < 1 || l > 150 {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Audience",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig_JWT.ValidateAll() if the
// designated constraints aren't met.
type TokenIntrospectConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_JWTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_JWTMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_JWTValidationError is the validation error returned by
// TokenIntrospectConfig_JWT.Validate if the designated constraints aren't met.
type TokenIntrospectConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_JWTValidationError) ErrorName() string {
	return "TokenIntrospectConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_JWTValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Opaque) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OpaqueMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Opaque) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Opaque) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenIntrospectConfig_OpaqueMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OpaqueMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Opaque.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OpaqueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OpaqueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OpaqueMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OpaqueValidationError is the validation error returned
// by TokenIntrospectConfig_Opaque.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OpaqueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OpaqueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OpaqueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OpaqueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OpaqueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OpaqueValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OpaqueValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OpaqueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Opaque.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OpaqueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OpaqueValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Offline with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OfflineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPublicJwks()) > 10 {
		err := TokenIntrospectConfig_OfflineValidationError{
			field:  "PublicJwks",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPublicJwks() {
		_, _ = idx, item

		if l := len(item); l < 96 || l > 8192 {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value length must be between 96 and 8192 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasPrefix(item, []uint8{0x7B}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have prefix \"\\x7B\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasSuffix(item, []uint8{0x7D}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have suffix \"\\x7D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Offline.ValidateAll()
// if the designated constraints aren't met.
type TokenIntrospectConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OfflineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OfflineValidationError is the validation error
// returned by TokenIntrospectConfig_Offline.Validate if the designated
// constraints aren't met.
type TokenIntrospectConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OfflineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OfflineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Online) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OnlineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Online) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Online) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserinfoEndpoint() != "" {

		if uri, err := url.Parse(m.GetUserinfoEndpoint()); err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if d := m.GetCacheTtl(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "CacheTtl",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(3600*time.Second + 0*time.Nanosecond)

			if dur > lte {
				err := TokenIntrospectConfig_OnlineValidationError{
					field:  "CacheTtl",
					reason: "value must be less than or equal to 1h0m0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OnlineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OnlineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Online.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OnlineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OnlineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OnlineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OnlineValidationError is the validation error returned
// by TokenIntrospectConfig_Online.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OnlineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OnlineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OnlineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OnlineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OnlineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OnlineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OnlineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OnlineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Online.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OnlineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OnlineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_ClaimMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetSelector()); l < 1 || l > 200 {
		err := TokenIntrospectConfig_ClaimValidationError{
			field:  "Selector",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_ClaimMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Claim.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_ClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_ClaimValidationError is the validation error returned
// by TokenIntrospectConfig_Claim.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_ClaimValidationError) ErrorName() string {
	return "TokenIntrospectConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_ClaimValidationError{}

// Validate checks the field values on ConsentDataPoint_Return with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint_Return) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint_Return with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPoint_ReturnMultiError, or nil if none found.
func (m *ConsentDataPoint_Return) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint_Return) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetVariable()) > 32 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Variable",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetProperties()) > 50 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Properties",
			reason: "value must contain no more than 50 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConsentDataPoint_ReturnMultiError(errors)
	}

	return nil
}

// ConsentDataPoint_ReturnMultiError is an error wrapping multiple validation
// errors returned by ConsentDataPoint_Return.ValidateAll() if the designated
// constraints aren't met.
type ConsentDataPoint_ReturnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPoint_ReturnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPoint_ReturnMultiError) AllErrors() []error { return m }

// ConsentDataPoint_ReturnValidationError is the validation error returned by
// ConsentDataPoint_Return.Validate if the designated constraints aren't met.
type ConsentDataPoint_ReturnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPoint_ReturnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPoint_ReturnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPoint_ReturnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPoint_ReturnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPoint_ReturnValidationError) ErrorName() string {
	return "ConsentDataPoint_ReturnValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentDataPoint_ReturnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint_Return.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPoint_ReturnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPoint_ReturnValidationError{}
