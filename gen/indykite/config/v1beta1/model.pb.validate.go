// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/config/v1beta1/model.proto

package configv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _model_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UniqueNameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UniqueNameIdentifierMultiError, or nil if none found.
func (m *UniqueNameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *UniqueNameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLocation()); l < 22 || l > 254 {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Location_Pattern.MatchString(m.GetLocation()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Name_Pattern.MatchString(m.GetName()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UniqueNameIdentifierMultiError(errors)
	}

	return nil
}

// UniqueNameIdentifierMultiError is an error wrapping multiple validation
// errors returned by UniqueNameIdentifier.ValidateAll() if the designated
// constraints aren't met.
type UniqueNameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UniqueNameIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UniqueNameIdentifierMultiError) AllErrors() []error { return m }

// UniqueNameIdentifierValidationError is the validation error returned by
// UniqueNameIdentifier.Validate if the designated constraints aren't met.
type UniqueNameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UniqueNameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UniqueNameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UniqueNameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UniqueNameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UniqueNameIdentifierValidationError) ErrorName() string {
	return "UniqueNameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e UniqueNameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUniqueNameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UniqueNameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UniqueNameIdentifierValidationError{}

var _UniqueNameIdentifier_Location_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _UniqueNameIdentifier_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on Customer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Customer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerMultiError, or nil
// if none found.
func (m *Customer) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Id_Pattern.MatchString(m.GetId()) {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Name_Pattern.MatchString(m.GetName()) {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := CustomerValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := CustomerValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if len(errors) > 0 {
		return CustomerMultiError(errors)
	}

	return nil
}

// CustomerMultiError is an error wrapping multiple validation errors returned
// by Customer.ValidateAll() if the designated constraints aren't met.
type CustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerMultiError) AllErrors() []error { return m }

// CustomerValidationError is the validation error returned by
// Customer.Validate if the designated constraints aren't met.
type CustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerValidationError) ErrorName() string { return "CustomerValidationError" }

// Error satisfies the builtin error interface
func (e CustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerValidationError{}

var _Customer_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Customer_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on ApplicationSpace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceMultiError, or nil if none found.
func (m *ApplicationSpace) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationSpaceValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIssuerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "IssuerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_IssuerId_Pattern.MatchString(m.GetIssuerId()) {
		err := ApplicationSpaceValidationError{
			field:  "IssuerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationSpaceMultiError(errors)
	}

	return nil
}

// ApplicationSpaceMultiError is an error wrapping multiple validation errors
// returned by ApplicationSpace.ValidateAll() if the designated constraints
// aren't met.
type ApplicationSpaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceMultiError) AllErrors() []error { return m }

// ApplicationSpaceValidationError is the validation error returned by
// ApplicationSpace.Validate if the designated constraints aren't met.
type ApplicationSpaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceValidationError) ErrorName() string { return "ApplicationSpaceValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationSpaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceValidationError{}

var _ApplicationSpace_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationSpace_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_IssuerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Tenant with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Tenant) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tenant with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TenantMultiError, or nil if none found.
func (m *Tenant) ValidateAll() error {
	return m.validate(true)
}

func (m *Tenant) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_Id_Pattern.MatchString(m.GetId()) {
		err := TenantValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := TenantValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_Name_Pattern.MatchString(m.GetName()) {
		err := TenantValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := TenantValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := TenantValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := TenantValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := TenantValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetIssuerId()); l < 22 || l > 254 {
		err := TenantValidationError{
			field:  "IssuerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Tenant_IssuerId_Pattern.MatchString(m.GetIssuerId()) {
		err := TenantValidationError{
			field:  "IssuerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TenantMultiError(errors)
	}

	return nil
}

// TenantMultiError is an error wrapping multiple validation errors returned by
// Tenant.ValidateAll() if the designated constraints aren't met.
type TenantMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantMultiError) AllErrors() []error { return m }

// TenantValidationError is the validation error returned by Tenant.Validate if
// the designated constraints aren't met.
type TenantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantValidationError) ErrorName() string { return "TenantValidationError" }

// Error satisfies the builtin error interface
func (e TenantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantValidationError{}

var _Tenant_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Tenant_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Tenant_IssuerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentMultiError, or nil if none found.
func (m *ApplicationAgent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationAgentValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentMultiError(errors)
	}

	return nil
}

// ApplicationAgentMultiError is an error wrapping multiple validation errors
// returned by ApplicationAgent.ValidateAll() if the designated constraints
// aren't met.
type ApplicationAgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentMultiError) AllErrors() []error { return m }

// ApplicationAgentValidationError is the validation error returned by
// ApplicationAgent.Validate if the designated constraints aren't met.
type ApplicationAgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentValidationError) ErrorName() string { return "ApplicationAgentValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationAgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentValidationError{}

var _ApplicationAgent_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationAgent_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgentCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialMultiError, or nil if none found.
func (m *ApplicationAgentCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationAgentId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationAgentId_Pattern.MatchString(m.GetApplicationAgentId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialMultiError is an error wrapping multiple
// validation errors returned by ApplicationAgentCredential.ValidateAll() if
// the designated constraints aren't met.
type ApplicationAgentCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialValidationError is the validation error returned
// by ApplicationAgentCredential.Validate if the designated constraints aren't met.
type ApplicationAgentCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialValidationError) ErrorName() string {
	return "ApplicationAgentCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialValidationError{}

var _ApplicationAgentCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ApplicationAgentCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationAgentId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceAccountMultiError,
// or nil if none found.
func (m *ServiceAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Name_Pattern.MatchString(m.GetName()) {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccount_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ServiceAccountMultiError(errors)
	}

	return nil
}

// ServiceAccountMultiError is an error wrapping multiple validation errors
// returned by ServiceAccount.ValidateAll() if the designated constraints
// aren't met.
type ServiceAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountMultiError) AllErrors() []error { return m }

// ServiceAccountValidationError is the validation error returned by
// ServiceAccount.Validate if the designated constraints aren't met.
type ServiceAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountValidationError) ErrorName() string { return "ServiceAccountValidationError" }

// Error satisfies the builtin error interface
func (e ServiceAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountValidationError{}

var _ServiceAccount_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ServiceAccount_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccountCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialMultiError, or nil if none found.
func (m *ServiceAccountCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccountCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetServiceAccountId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_ServiceAccountId_Pattern.MatchString(m.GetServiceAccountId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialMultiError is an error wrapping multiple validation
// errors returned by ServiceAccountCredential.ValidateAll() if the designated
// constraints aren't met.
type ServiceAccountCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialValidationError is the validation error returned by
// ServiceAccountCredential.Validate if the designated constraints aren't met.
type ServiceAccountCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialValidationError) ErrorName() string {
	return "ServiceAccountCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialValidationError{}

var _ServiceAccountCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ServiceAccountCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_ServiceAccountId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ConfigNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigNodeMultiError, or
// nil if none found.
func (m *ConfigNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Id_Pattern.MatchString(m.GetId()) {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Name_Pattern.MatchString(m.GetName()) {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ConfigNodeValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTenantId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "TenantId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_TenantId_Pattern.MatchString(m.GetTenantId()) {
		err := ConfigNodeValidationError{
			field:  "TenantId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch m.Config.(type) {

	case *ConfigNode_AuthFlowConfig:

		if all {
			switch v := interface{}(m.GetAuthFlowConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthFlowConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthFlowConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthFlowConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthFlowConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_EmailServiceConfig:

		if all {
			switch v := interface{}(m.GetEmailServiceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmailServiceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "EmailServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_Oauth2ClientConfig:

		if all {
			switch v := interface{}(m.GetOauth2ClientConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOauth2ClientConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "Oauth2ClientConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_PasswordProviderConfig:

		if all {
			switch v := interface{}(m.GetPasswordProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "PasswordProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "PasswordProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPasswordProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "PasswordProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_WebauthnProviderConfig:

		if all {
			switch v := interface{}(m.GetWebauthnProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "WebauthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "WebauthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebauthnProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "WebauthnProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuthenteqProviderConfig:

		if all {
			switch v := interface{}(m.GetAuthenteqProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthenteqProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthenteqProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthenteqProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthenteqProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_SafrProviderConfig:

		if all {
			switch v := interface{}(m.GetSafrProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "SafrProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "SafrProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSafrProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "SafrProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_IngestMappingConfig:

		if all {
			switch v := interface{}(m.GetIngestMappingConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "IngestMappingConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "IngestMappingConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIngestMappingConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "IngestMappingConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuthorizationPolicyConfig:

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_KnowledgeGraphSchemaConfig:

		if all {
			switch v := interface{}(m.GetKnowledgeGraphSchemaConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "KnowledgeGraphSchemaConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "KnowledgeGraphSchemaConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKnowledgeGraphSchemaConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "KnowledgeGraphSchemaConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_ReadidProviderConfig:

		if all {
			switch v := interface{}(m.GetReadidProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ReadidProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ReadidProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReadidProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "ReadidProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := ConfigNodeValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return ConfigNodeMultiError(errors)
	}

	return nil
}

// ConfigNodeMultiError is an error wrapping multiple validation errors
// returned by ConfigNode.ValidateAll() if the designated constraints aren't met.
type ConfigNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigNodeMultiError) AllErrors() []error { return m }

// ConfigNodeValidationError is the validation error returned by
// ConfigNode.Validate if the designated constraints aren't met.
type ConfigNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigNodeValidationError) ErrorName() string { return "ConfigNodeValidationError" }

// Error satisfies the builtin error interface
func (e ConfigNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigNodeValidationError{}

var _ConfigNode_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ConfigNode_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ClientConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ClientConfigMultiError, or nil if none found.
func (m *OAuth2ClientConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ClientConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _OAuth2ClientConfig_ProviderType_NotInLookup[m.GetProviderType()]; ok {
		err := OAuth2ClientConfigValidationError{
			field:  "ProviderType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ProviderType_name[int32(m.GetProviderType())]; !ok {
		err := OAuth2ClientConfigValidationError{
			field:  "ProviderType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientId()) < 8 {
		err := OAuth2ClientConfigValidationError{
			field:  "ClientId",
			reason: "value length must be at least 8 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetClientSecret() != "" {

		if utf8.RuneCountInString(m.GetClientSecret()) < 8 {
			err := OAuth2ClientConfigValidationError{
				field:  "ClientSecret",
				reason: "value length must be at least 8 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetRedirectUri()) > 0 {

		_OAuth2ClientConfig_RedirectUri_Unique := make(map[string]struct{}, len(m.GetRedirectUri()))

		for idx, item := range m.GetRedirectUri() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_RedirectUri_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_RedirectUri_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 8 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value length must be at least 8 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(item); err != nil {
				err = OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("RedirectUri[%v]", idx),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(m.GetDefaultScopes()) > 0 {

		_OAuth2ClientConfig_DefaultScopes_Unique := make(map[string]struct{}, len(m.GetDefaultScopes()))

		for idx, item := range m.GetDefaultScopes() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_DefaultScopes_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("DefaultScopes[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_DefaultScopes_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 1 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("DefaultScopes[%v]", idx),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(m.GetAllowedScopes()) > 0 {

		_OAuth2ClientConfig_AllowedScopes_Unique := make(map[string]struct{}, len(m.GetAllowedScopes()))

		for idx, item := range m.GetAllowedScopes() {
			_, _ = idx, item

			if _, exists := _OAuth2ClientConfig_AllowedScopes_Unique[item]; exists {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("AllowedScopes[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_OAuth2ClientConfig_AllowedScopes_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 1 {
				err := OAuth2ClientConfigValidationError{
					field:  fmt.Sprintf("AllowedScopes[%v]", idx),
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	// no validation rules for AllowSignup

	if m.GetIssuer() != "" {

		if utf8.RuneCountInString(m.GetIssuer()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetIssuer(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetIssuer()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "Issuer",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetAuthorizationEndpoint() != "" {

		if utf8.RuneCountInString(m.GetAuthorizationEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetAuthorizationEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetAuthorizationEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "AuthorizationEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTokenEndpoint() != "" {

		if utf8.RuneCountInString(m.GetTokenEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetTokenEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetTokenEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "TokenEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetDiscoveryUrl() != "" {

		if utf8.RuneCountInString(m.GetDiscoveryUrl()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetDiscoveryUrl(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetDiscoveryUrl()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "DiscoveryUrl",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetUserinfoEndpoint() != "" {

		if utf8.RuneCountInString(m.GetUserinfoEndpoint()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetUserinfoEndpoint(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetUserinfoEndpoint()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetJwksUri() != "" {

		if utf8.RuneCountInString(m.GetJwksUri()) < 9 {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value length must be at least 9 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(m.GetJwksUri(), "https") {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value does not have prefix \"https\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetJwksUri()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ClientConfigValidationError{
				field:  "JwksUri",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetImageUrl() != "" {

		if l := utf8.RuneCountInString(m.GetImageUrl()); l < 2 || l > 1024 {
			err := OAuth2ClientConfigValidationError{
				field:  "ImageUrl",
				reason: "value length must be between 2 and 1024 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTenant() != "" {

		if l := utf8.RuneCountInString(m.GetTenant()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "Tenant",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetHostedDomain() != "" {

		if l := utf8.RuneCountInString(m.GetHostedDomain()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "HostedDomain",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateHostname(m.GetHostedDomain()); err != nil {
			err = OAuth2ClientConfigValidationError{
				field:  "HostedDomain",
				reason: "value must be a valid hostname",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := AuthStyle_name[int32(m.GetAuthStyle())]; !ok {
		err := OAuth2ClientConfigValidationError{
			field:  "AuthStyle",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetPrivateKeyPem()) > 0 {

		if l := len(m.GetPrivateKeyPem()); l < 85 || l > 8192 {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value length must be between 85 and 8192 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasPrefix(m.GetPrivateKeyPem(), []uint8{0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D}) {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value does not have prefix \"\\x2D\\x2D\\x2D\\x2D\\x2D\\x42\\x45\\x47\\x49\\x4E\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4B\\x45\\x59\\x2D\\x2D\\x2D\\x2D\\x2D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasSuffix(m.GetPrivateKeyPem(), []uint8{0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D}) {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyPem",
				reason: "value does not have suffix \"\\x2D\\x2D\\x2D\\x2D\\x2D\\x45\\x4E\\x44\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4B\\x45\\x59\\x2D\\x2D\\x2D\\x2D\\x2D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetPrivateKeyId() != "" {

		if l := utf8.RuneCountInString(m.GetPrivateKeyId()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "PrivateKeyId",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetTeamId() != "" {

		if l := utf8.RuneCountInString(m.GetTeamId()); l < 2 || l > 254 {
			err := OAuth2ClientConfigValidationError{
				field:  "TeamId",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return OAuth2ClientConfigMultiError(errors)
	}

	return nil
}

func (m *OAuth2ClientConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// OAuth2ClientConfigMultiError is an error wrapping multiple validation errors
// returned by OAuth2ClientConfig.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ClientConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ClientConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ClientConfigMultiError) AllErrors() []error { return m }

// OAuth2ClientConfigValidationError is the validation error returned by
// OAuth2ClientConfig.Validate if the designated constraints aren't met.
type OAuth2ClientConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ClientConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ClientConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ClientConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ClientConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ClientConfigValidationError) ErrorName() string {
	return "OAuth2ClientConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ClientConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ClientConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ClientConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ClientConfigValidationError{}

var _OAuth2ClientConfig_ProviderType_NotInLookup = map[ProviderType]struct{}{
	0: {},
}

// Validate checks the field values on OAuth2Application with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OAuth2Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2Application with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ApplicationMultiError, or nil if none found.
func (m *OAuth2Application) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Id_Pattern.MatchString(m.GetId()) {
		err := OAuth2ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := OAuth2ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Name_Pattern.MatchString(m.GetName()) {
		err := OAuth2ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := OAuth2ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := OAuth2ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := OAuth2ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOauth2ProviderId()); l < 22 || l > 254 {
		err := OAuth2ApplicationValidationError{
			field:  "Oauth2ProviderId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Application_Oauth2ProviderId_Pattern.MatchString(m.GetOauth2ProviderId()) {
		err := OAuth2ApplicationValidationError{
			field:  "Oauth2ProviderId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ApplicationValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ApplicationValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OAuth2ApplicationMultiError(errors)
	}

	return nil
}

// OAuth2ApplicationMultiError is an error wrapping multiple validation errors
// returned by OAuth2Application.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ApplicationMultiError) AllErrors() []error { return m }

// OAuth2ApplicationValidationError is the validation error returned by
// OAuth2Application.Validate if the designated constraints aren't met.
type OAuth2ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ApplicationValidationError) ErrorName() string {
	return "OAuth2ApplicationValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2Application.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ApplicationValidationError{}

var _OAuth2Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _OAuth2Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Application_Oauth2ProviderId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ApplicationConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ApplicationConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ApplicationConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ApplicationConfigMultiError, or nil if none found.
func (m *OAuth2ApplicationConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ApplicationConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDescription() != "" {

		if l := utf8.RuneCountInString(m.GetDescription()); l < 2 || l > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetRedirectUris()) < 1 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "RedirectUris",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_RedirectUris_Unique := make(map[string]struct{}, len(m.GetRedirectUris()))

	for idx, item := range m.GetRedirectUris() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_RedirectUris_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_RedirectUris_Unique[item] = struct{}{}
		}

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("RedirectUris[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetOwner()); l < 2 || l > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "Owner",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPolicyUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetPolicyUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "PolicyUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_AllowedCorsOrigins_Unique := make(map[string]struct{}, len(m.GetAllowedCorsOrigins()))

	for idx, item := range m.GetAllowedCorsOrigins() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_AllowedCorsOrigins_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_AllowedCorsOrigins_Unique[item] = struct{}{}
		}

		if utf8.RuneCountInString(item) > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("AllowedCorsOrigins[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if utf8.RuneCountInString(m.GetTermsOfServiceUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetTermsOfServiceUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TermsOfServiceUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetClientUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "ClientUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetLogoUri()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetLogoUri()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := OAuth2ApplicationConfigValidationError{
			field:  "LogoUri",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUserSupportEmailAddress()) > 254 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "UserSupportEmailAddress",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetUserSupportEmailAddress()); err != nil {
		err = OAuth2ApplicationConfigValidationError{
			field:  "UserSupportEmailAddress",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _OAuth2ApplicationConfig_SubjectType_NotInLookup[m.GetSubjectType()]; ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "SubjectType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ClientSubjectType_name[int32(m.GetSubjectType())]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "SubjectType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSectorIdentifierUri() != "" {

		if utf8.RuneCountInString(m.GetSectorIdentifierUri()) > 254 {
			err := OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if uri, err := url.Parse(m.GetSectorIdentifierUri()); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ApplicationConfigValidationError{
				field:  "SectorIdentifierUri",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_GrantTypes_Unique := make(map[GrantType]struct{}, len(m.GetGrantTypes()))

	for idx, item := range m.GetGrantTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_GrantTypes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_GrantTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ApplicationConfig_GrantTypes_NotInLookup[item]; ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := GrantType_name[int32(item)]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_ResponseTypes_Unique := make(map[ResponseType]struct{}, len(m.GetResponseTypes()))

	for idx, item := range m.GetResponseTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_ResponseTypes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_ResponseTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ApplicationConfig_ResponseTypes_NotInLookup[item]; ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := ResponseType_name[int32(item)]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetScopes()) < 1 {
		err := OAuth2ApplicationConfigValidationError{
			field:  "Scopes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ApplicationConfig_Scopes_Unique := make(map[string]struct{}, len(m.GetScopes()))

	for idx, item := range m.GetScopes() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_Scopes_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_Scopes_Unique[item] = struct{}{}
		}

		if !_OAuth2ApplicationConfig_Scopes_Pattern.MatchString(item) {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "value does not match regex pattern \"^[\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e]{1,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	_OAuth2ApplicationConfig_Audiences_Unique := make(map[string]struct{}, len(m.GetAudiences()))

	for idx, item := range m.GetAudiences() {
		_, _ = idx, item

		if _, exists := _OAuth2ApplicationConfig_Audiences_Unique[item]; exists {
			err := OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Audiences[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ApplicationConfig_Audiences_Unique[item] = struct{}{}
		}

		if err := m._validateUuid(item); err != nil {
			err = OAuth2ApplicationConfigValidationError{
				field:  fmt.Sprintf("Audiences[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _OAuth2ApplicationConfig_TokenEndpointAuthMethod_NotInLookup[m.GetTokenEndpointAuthMethod()]; ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TokenEndpointAuthMethod_name[int32(m.GetTokenEndpointAuthMethod())]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _OAuth2ApplicationConfig_TokenEndpointAuthSigningAlg_InLookup[m.GetTokenEndpointAuthSigningAlg()]; !ok {
		err := OAuth2ApplicationConfigValidationError{
			field:  "TokenEndpointAuthSigningAlg",
			reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserinfoSignedResponseAlg() != "" {

		if _, ok := _OAuth2ApplicationConfig_UserinfoSignedResponseAlg_InLookup[m.GetUserinfoSignedResponseAlg()]; !ok {
			err := OAuth2ApplicationConfigValidationError{
				field:  "UserinfoSignedResponseAlg",
				reason: "value must be in list [RS256]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return OAuth2ApplicationConfigMultiError(errors)
	}

	return nil
}

func (m *OAuth2ApplicationConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *OAuth2ApplicationConfig) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

func (m *OAuth2ApplicationConfig) _validateUuid(uuid string) error {
	if matched := _model_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// OAuth2ApplicationConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ApplicationConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ApplicationConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ApplicationConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ApplicationConfigMultiError) AllErrors() []error { return m }

// OAuth2ApplicationConfigValidationError is the validation error returned by
// OAuth2ApplicationConfig.Validate if the designated constraints aren't met.
type OAuth2ApplicationConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ApplicationConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ApplicationConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ApplicationConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ApplicationConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ApplicationConfigValidationError) ErrorName() string {
	return "OAuth2ApplicationConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ApplicationConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ApplicationConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ApplicationConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ApplicationConfigValidationError{}

var _OAuth2ApplicationConfig_SubjectType_NotInLookup = map[ClientSubjectType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_GrantTypes_NotInLookup = map[GrantType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_ResponseTypes_NotInLookup = map[ResponseType]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_Scopes_Pattern = regexp.MustCompile("^[\\x21\\x23-\\x5b\\x5d-\\x7e]{1,254}$")

var _OAuth2ApplicationConfig_TokenEndpointAuthMethod_NotInLookup = map[TokenEndpointAuthMethod]struct{}{
	0: {},
}

var _OAuth2ApplicationConfig_TokenEndpointAuthSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

var _OAuth2ApplicationConfig_UserinfoSignedResponseAlg_InLookup = map[string]struct{}{
	"RS256": {},
}

// Validate checks the field values on OAuth2Provider with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OAuth2Provider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2Provider with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OAuth2ProviderMultiError,
// or nil if none found.
func (m *OAuth2Provider) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2Provider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_Id_Pattern.MatchString(m.GetId()) {
		err := OAuth2ProviderValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := OAuth2ProviderValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_Name_Pattern.MatchString(m.GetName()) {
		err := OAuth2ProviderValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := OAuth2ProviderValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := OAuth2ProviderValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := OAuth2ProviderValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_OAuth2Provider_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := OAuth2ProviderValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuth2ProviderValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuth2ProviderValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OAuth2ProviderMultiError(errors)
	}

	return nil
}

// OAuth2ProviderMultiError is an error wrapping multiple validation errors
// returned by OAuth2Provider.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ProviderMultiError) AllErrors() []error { return m }

// OAuth2ProviderValidationError is the validation error returned by
// OAuth2Provider.Validate if the designated constraints aren't met.
type OAuth2ProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ProviderValidationError) ErrorName() string { return "OAuth2ProviderValidationError" }

// Error satisfies the builtin error interface
func (e OAuth2ProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2Provider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ProviderValidationError{}

var _OAuth2Provider_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Provider_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _OAuth2Provider_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _OAuth2Provider_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ProviderConfigMultiError, or nil if none found.
func (m *OAuth2ProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetGrantTypes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "GrantTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_GrantTypes_Unique := make(map[GrantType]struct{}, len(m.GetGrantTypes()))

	for idx, item := range m.GetGrantTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_GrantTypes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_GrantTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ProviderConfig_GrantTypes_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := GrantType_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("GrantTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetResponseTypes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "ResponseTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_ResponseTypes_Unique := make(map[ResponseType]struct{}, len(m.GetResponseTypes()))

	for idx, item := range m.GetResponseTypes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_ResponseTypes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_ResponseTypes_Unique[item] = struct{}{}
		}

		if _, ok := _OAuth2ProviderConfig_ResponseTypes_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := ResponseType_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("ResponseTypes[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetScopes()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "Scopes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_OAuth2ProviderConfig_Scopes_Unique := make(map[string]struct{}, len(m.GetScopes()))

	for idx, item := range m.GetScopes() {
		_, _ = idx, item

		if _, exists := _OAuth2ProviderConfig_Scopes_Unique[item]; exists {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_OAuth2ProviderConfig_Scopes_Unique[item] = struct{}{}
		}

		if !_OAuth2ProviderConfig_Scopes_Pattern.MatchString(item) {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("Scopes[%v]", idx),
				reason: "value does not match regex pattern \"^[\\\\x21\\\\x23-\\\\x5b\\\\x5d-\\\\x7e]{1,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetTokenEndpointAuthMethod()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "TokenEndpointAuthMethod",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTokenEndpointAuthMethod() {
		_, _ = idx, item

		if _, ok := _OAuth2ProviderConfig_TokenEndpointAuthMethod_NotInLookup[item]; ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthMethod[%v]", idx),
				reason: "value must not be in list [0]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if _, ok := TokenEndpointAuthMethod_name[int32(item)]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthMethod[%v]", idx),
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetTokenEndpointAuthSigningAlg()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "TokenEndpointAuthSigningAlg",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTokenEndpointAuthSigningAlg() {
		_, _ = idx, item

		if _, ok := _OAuth2ProviderConfig_TokenEndpointAuthSigningAlg_InLookup[item]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("TokenEndpointAuthSigningAlg[%v]", idx),
				reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetRequestUris() {
		_, _ = idx, item

		if uri, err := url.Parse(item); err != nil {
			err = OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("RequestUris[%v]", idx),
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := OAuth2ProviderConfigValidationError{
				field:  fmt.Sprintf("RequestUris[%v]", idx),
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetRequestObjectSigningAlg() != "" {

		if _, ok := _OAuth2ProviderConfig_RequestObjectSigningAlg_InLookup[m.GetRequestObjectSigningAlg()]; !ok {
			err := OAuth2ProviderConfigValidationError{
				field:  "RequestObjectSigningAlg",
				reason: "value must be in list [RS256 RS384 RS512 PS256 PS384 PS512 ES256 ES384 ES512 ES256K HS256 HS384 HS512 EdDSA]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetFrontChannelLoginUri()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "FrontChannelLoginUri",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetFrontChannelLoginUri()))
		i := 0
		for key := range m.GetFrontChannelLoginUri() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFrontChannelLoginUri()[key]
			_ = val

			if utf8.RuneCountInString(key) > 32 {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value length must be at most 32 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(val); err != nil {
				err = OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelLoginUri[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(m.GetFrontChannelConsentUri()) < 1 {
		err := OAuth2ProviderConfigValidationError{
			field:  "FrontChannelConsentUri",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetFrontChannelConsentUri()))
		i := 0
		for key := range m.GetFrontChannelConsentUri() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFrontChannelConsentUri()[key]
			_ = val

			if utf8.RuneCountInString(key) > 32 {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value length must be at most 32 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(val); err != nil {
				err = OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := OAuth2ProviderConfigValidationError{
					field:  fmt.Sprintf("FrontChannelConsentUri[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return OAuth2ProviderConfigMultiError(errors)
	}

	return nil
}

// OAuth2ProviderConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ProviderConfigMultiError) AllErrors() []error { return m }

// OAuth2ProviderConfigValidationError is the validation error returned by
// OAuth2ProviderConfig.Validate if the designated constraints aren't met.
type OAuth2ProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ProviderConfigValidationError) ErrorName() string {
	return "OAuth2ProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ProviderConfigValidationError{}

var _OAuth2ProviderConfig_GrantTypes_NotInLookup = map[GrantType]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_ResponseTypes_NotInLookup = map[ResponseType]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_Scopes_Pattern = regexp.MustCompile("^[\\x21\\x23-\\x5b\\x5d-\\x7e]{1,254}$")

var _OAuth2ProviderConfig_TokenEndpointAuthMethod_NotInLookup = map[TokenEndpointAuthMethod]struct{}{
	0: {},
}

var _OAuth2ProviderConfig_TokenEndpointAuthSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

var _OAuth2ProviderConfig_RequestObjectSigningAlg_InLookup = map[string]struct{}{
	"RS256":  {},
	"RS384":  {},
	"RS512":  {},
	"PS256":  {},
	"PS384":  {},
	"PS512":  {},
	"ES256":  {},
	"ES384":  {},
	"ES512":  {},
	"ES256K": {},
	"HS256":  {},
	"HS384":  {},
	"HS512":  {},
	"EdDSA":  {},
}

// Validate checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebAuthnProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAuthnProviderConfigMultiError, or nil if none found.
func (m *WebAuthnProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAuthnProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRelyingParties()) < 1 {
		err := WebAuthnProviderConfigValidationError{
			field:  "RelyingParties",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetRelyingParties()))
		i := 0
		for key := range m.GetRelyingParties() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRelyingParties()[key]
			_ = val

			if uri, err := url.Parse(key); err != nil {
				err = WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if l := utf8.RuneCountInString(val); l < 1 || l > 256 {
				err := WebAuthnProviderConfigValidationError{
					field:  fmt.Sprintf("RelyingParties[%v]", key),
					reason: "value length must be between 1 and 256 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if _, ok := ConveyancePreference_name[int32(m.GetAttestationPreference())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "AttestationPreference",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := AuthenticatorAttachment_name[int32(m.GetAuthenticatorAttachment())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "AuthenticatorAttachment",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RequireResidentKey

	if _, ok := UserVerificationRequirement_name[int32(m.GetUserVerification())]; !ok {
		err := WebAuthnProviderConfigValidationError{
			field:  "UserVerification",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if d := m.GetRegistrationTimeout(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = WebAuthnProviderConfigValidationError{
				field:  "RegistrationTimeout",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(900*time.Second + 0*time.Nanosecond)
			gte := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := WebAuthnProviderConfigValidationError{
					field:  "RegistrationTimeout",
					reason: "value must be inside range [0s, 15m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if d := m.GetAuthenticationTimeout(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = WebAuthnProviderConfigValidationError{
				field:  "AuthenticationTimeout",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(900*time.Second + 0*time.Nanosecond)
			gte := time.Duration(0*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := WebAuthnProviderConfigValidationError{
					field:  "AuthenticationTimeout",
					reason: "value must be inside range [0s, 15m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return WebAuthnProviderConfigMultiError(errors)
	}

	return nil
}

// WebAuthnProviderConfigMultiError is an error wrapping multiple validation
// errors returned by WebAuthnProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type WebAuthnProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAuthnProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAuthnProviderConfigMultiError) AllErrors() []error { return m }

// WebAuthnProviderConfigValidationError is the validation error returned by
// WebAuthnProviderConfig.Validate if the designated constraints aren't met.
type WebAuthnProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAuthnProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAuthnProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAuthnProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAuthnProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAuthnProviderConfigValidationError) ErrorName() string {
	return "WebAuthnProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e WebAuthnProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAuthnProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAuthnProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAuthnProviderConfigValidationError{}

// Validate checks the field values on WebAuthnSiteDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebAuthnSiteDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAuthnSiteDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAuthnSiteDefinitionMultiError, or nil if none found.
func (m *WebAuthnSiteDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAuthnSiteDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DisplayName

	// no validation rules for Origin

	// no validation rules for Icon

	if len(errors) > 0 {
		return WebAuthnSiteDefinitionMultiError(errors)
	}

	return nil
}

// WebAuthnSiteDefinitionMultiError is an error wrapping multiple validation
// errors returned by WebAuthnSiteDefinition.ValidateAll() if the designated
// constraints aren't met.
type WebAuthnSiteDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAuthnSiteDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAuthnSiteDefinitionMultiError) AllErrors() []error { return m }

// WebAuthnSiteDefinitionValidationError is the validation error returned by
// WebAuthnSiteDefinition.Validate if the designated constraints aren't met.
type WebAuthnSiteDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAuthnSiteDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAuthnSiteDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAuthnSiteDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAuthnSiteDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAuthnSiteDefinitionValidationError) ErrorName() string {
	return "WebAuthnSiteDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e WebAuthnSiteDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAuthnSiteDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAuthnSiteDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAuthnSiteDefinitionValidationError{}

// Validate checks the field values on AuthFlowConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthFlowConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthFlowConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthFlowConfigMultiError,
// or nil if none found.
func (m *AuthFlowConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthFlowConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := AuthFlowConfig_Format_name[int32(m.GetSourceFormat())]; !ok {
		err := AuthFlowConfigValidationError{
			field:  "SourceFormat",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSource()) > 1048576 {
		err := AuthFlowConfigValidationError{
			field:  "Source",
			reason: "value length must be at most 1048576 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthFlowConfigValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthFlowConfigValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthFlowConfigValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthFlowConfigMultiError(errors)
	}

	return nil
}

// AuthFlowConfigMultiError is an error wrapping multiple validation errors
// returned by AuthFlowConfig.ValidateAll() if the designated constraints
// aren't met.
type AuthFlowConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthFlowConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthFlowConfigMultiError) AllErrors() []error { return m }

// AuthFlowConfigValidationError is the validation error returned by
// AuthFlowConfig.Validate if the designated constraints aren't met.
type AuthFlowConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthFlowConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthFlowConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthFlowConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthFlowConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthFlowConfigValidationError) ErrorName() string { return "AuthFlowConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuthFlowConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthFlowConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthFlowConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthFlowConfigValidationError{}

// Validate checks the field values on AuthenteqProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthenteqProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthenteqProviderConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthenteqProviderConfigMultiError, or nil if none found.
func (m *AuthenteqProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthenteqProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefaultRedirectUri

	if utf8.RuneCountInString(m.GetClientId()) < 12 {
		err := AuthenteqProviderConfigValidationError{
			field:  "ClientId",
			reason: "value length must be at least 12 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetClientSecret() != "" {

		if utf8.RuneCountInString(m.GetClientSecret()) < 12 {
			err := AuthenteqProviderConfigValidationError{
				field:  "ClientSecret",
				reason: "value length must be at least 12 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if err := m._validateHostname(m.GetHostAddress()); err != nil {
		err = AuthenteqProviderConfigValidationError{
			field:  "HostAddress",
			reason: "value must be a valid hostname",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AuthenteqProviderConfigMultiError(errors)
	}

	return nil
}

func (m *AuthenteqProviderConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

// AuthenteqProviderConfigMultiError is an error wrapping multiple validation
// errors returned by AuthenteqProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type AuthenteqProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthenteqProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthenteqProviderConfigMultiError) AllErrors() []error { return m }

// AuthenteqProviderConfigValidationError is the validation error returned by
// AuthenteqProviderConfig.Validate if the designated constraints aren't met.
type AuthenteqProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthenteqProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthenteqProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthenteqProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthenteqProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthenteqProviderConfigValidationError) ErrorName() string {
	return "AuthenteqProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthenteqProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthenteqProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthenteqProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthenteqProviderConfigValidationError{}

// Validate checks the field values on ReadIDProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadIDProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadIDProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadIDProviderConfigMultiError, or nil if none found.
func (m *ReadIDProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadIDProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubmitterSecret() != "" {

		if utf8.RuneCountInString(m.GetSubmitterSecret()) < 36 {
			err := ReadIDProviderConfigValidationError{
				field:  "SubmitterSecret",
				reason: "value length must be at least 36 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetManagerSecret() != "" {

		if utf8.RuneCountInString(m.GetManagerSecret()) < 36 {
			err := ReadIDProviderConfigValidationError{
				field:  "ManagerSecret",
				reason: "value length must be at least 36 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetSubmitterPassword() != "" {

		if l := utf8.RuneCountInString(m.GetSubmitterPassword()); l < 4 || l > 254 {
			err := ReadIDProviderConfigValidationError{
				field:  "SubmitterPassword",
				reason: "value length must be between 4 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetHostAddress() != "" {

		if l := utf8.RuneCountInString(m.GetHostAddress()); l < 4 || l > 254 {
			err := ReadIDProviderConfigValidationError{
				field:  "HostAddress",
				reason: "value length must be between 4 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	{
		sorted_keys := make([]string, len(m.GetPropertyMap()))
		i := 0
		for key := range m.GetPropertyMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPropertyMap()[key]
			_ = val

			// no validation rules for PropertyMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ReadIDProviderConfigValidationError{
							field:  fmt.Sprintf("PropertyMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ReadIDProviderConfigValidationError{
							field:  fmt.Sprintf("PropertyMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ReadIDProviderConfigValidationError{
						field:  fmt.Sprintf("PropertyMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ReadIDProviderConfigMultiError(errors)
	}

	return nil
}

// ReadIDProviderConfigMultiError is an error wrapping multiple validation
// errors returned by ReadIDProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type ReadIDProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadIDProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadIDProviderConfigMultiError) AllErrors() []error { return m }

// ReadIDProviderConfigValidationError is the validation error returned by
// ReadIDProviderConfig.Validate if the designated constraints aren't met.
type ReadIDProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadIDProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadIDProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadIDProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadIDProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadIDProviderConfigValidationError) ErrorName() string {
	return "ReadIDProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ReadIDProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadIDProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadIDProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadIDProviderConfigValidationError{}

// Validate checks the field values on SAFRProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SAFRProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SAFRProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SAFRProviderConfigMultiError, or nil if none found.
func (m *SAFRProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SAFRProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccountId()); l < 2 || l > 254 {
		err := SAFRProviderConfigValidationError{
			field:  "AccountId",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPassword() != "" {

		if l := utf8.RuneCountInString(m.GetPassword()); l < 4 || l > 254 {
			err := SAFRProviderConfigValidationError{
				field:  "Password",
				reason: "value length must be between 4 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetDirectory()); l < 2 || l > 254 {
		err := SAFRProviderConfigValidationError{
			field:  "Directory",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SAFRProviderConfigMultiError(errors)
	}

	return nil
}

// SAFRProviderConfigMultiError is an error wrapping multiple validation errors
// returned by SAFRProviderConfig.ValidateAll() if the designated constraints
// aren't met.
type SAFRProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SAFRProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SAFRProviderConfigMultiError) AllErrors() []error { return m }

// SAFRProviderConfigValidationError is the validation error returned by
// SAFRProviderConfig.Validate if the designated constraints aren't met.
type SAFRProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SAFRProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SAFRProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SAFRProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SAFRProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SAFRProviderConfigValidationError) ErrorName() string {
	return "SAFRProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SAFRProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSAFRProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SAFRProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SAFRProviderConfigValidationError{}

// Validate checks the field values on SMSServiceConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SMSServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SMSServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SMSServiceConfigMultiError, or nil if none found.
func (m *SMSServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SMSServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SMSServiceConfigMultiError(errors)
	}

	return nil
}

// SMSServiceConfigMultiError is an error wrapping multiple validation errors
// returned by SMSServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type SMSServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SMSServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SMSServiceConfigMultiError) AllErrors() []error { return m }

// SMSServiceConfigValidationError is the validation error returned by
// SMSServiceConfig.Validate if the designated constraints aren't met.
type SMSServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SMSServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SMSServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SMSServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SMSServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SMSServiceConfigValidationError) ErrorName() string { return "SMSServiceConfigValidationError" }

// Error satisfies the builtin error interface
func (e SMSServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSMSServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SMSServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SMSServiceConfigValidationError{}

// Validate checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailServiceConfigMultiError, or nil if none found.
func (m *EmailServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuthenticationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "AuthenticationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "AuthenticationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "AuthenticationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvitationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "InvitationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResetPasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResetPasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "ResetPasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerificationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerificationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "VerificationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOneTimePasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOneTimePasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "OneTimePasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.Provider.(type) {

	case *EmailServiceConfig_Sendgrid:

		if m.GetSendgrid() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Sendgrid",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSendgrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendgrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Sendgrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Mailjet:

		if m.GetMailjet() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Mailjet",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMailjet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailjet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailjet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMailjet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Mailjet",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Mailgun:

		if m.GetMailgun() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Mailgun",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMailgun()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailgun",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Mailgun",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMailgun()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Mailgun",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Amazon:

		if m.GetAmazon() == nil {
			err := EmailServiceConfigValidationError{
				field:  "Amazon",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAmazon()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAmazon()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Amazon",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EmailServiceConfigMultiError(errors)
	}

	return nil
}

// EmailServiceConfigMultiError is an error wrapping multiple validation errors
// returned by EmailServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type EmailServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailServiceConfigMultiError) AllErrors() []error { return m }

// EmailServiceConfigValidationError is the validation error returned by
// EmailServiceConfig.Validate if the designated constraints aren't met.
type EmailServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailServiceConfigValidationError) ErrorName() string {
	return "EmailServiceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EmailServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailServiceConfigValidationError{}

// Validate checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Email) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmailMultiError, or nil if none found.
func (m *Email) ValidateAll() error {
	return m.validate(true)
}

func (m *Email) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) > 254 {
		err := EmailValidationError{
			field:  "Address",
			reason: "value length must be at most 254 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetAddress()); err != nil {
		err = EmailValidationError{
			field:  "Address",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetName() != "" {

		if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 503 {
			err := EmailValidationError{
				field:  "Name",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return EmailMultiError(errors)
	}

	return nil
}

func (m *Email) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Email) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// EmailMultiError is an error wrapping multiple validation errors returned by
// Email.ValidateAll() if the designated constraints aren't met.
type EmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMultiError) AllErrors() []error { return m }

// EmailValidationError is the validation error returned by Email.Validate if
// the designated constraints aren't met.
type EmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailValidationError) ErrorName() string { return "EmailValidationError" }

// Error satisfies the builtin error interface
func (e EmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailValidationError{}

// Validate checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendGridProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendGridProviderConfigMultiError, or nil if none found.
func (m *SendGridProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SendGridProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := SendGridProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for SandboxMode

	if wrapper := m.GetIpPoolName(); wrapper != nil {

		if wrapper.GetValue() != "" {

			if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 64 {
				err := SendGridProviderConfigValidationError{
					field:  "IpPoolName",
					reason: "value length must be between 2 and 64 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if wrapper := m.GetHost(); wrapper != nil {

		if wrapper.GetValue() != "" {

			if l := utf8.RuneCountInString(wrapper.GetValue()); l < 10 || l > 254 {
				err := SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value length must be between 10 and 254 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if uri, err := url.Parse(wrapper.GetValue()); err != nil {
				err = SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else if !uri.IsAbs() {
				err := SendGridProviderConfigValidationError{
					field:  "Host",
					reason: "value must be absolute",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return SendGridProviderConfigMultiError(errors)
	}

	return nil
}

// SendGridProviderConfigMultiError is an error wrapping multiple validation
// errors returned by SendGridProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type SendGridProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendGridProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendGridProviderConfigMultiError) AllErrors() []error { return m }

// SendGridProviderConfigValidationError is the validation error returned by
// SendGridProviderConfig.Validate if the designated constraints aren't met.
type SendGridProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendGridProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendGridProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendGridProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendGridProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendGridProviderConfigValidationError) ErrorName() string {
	return "SendGridProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SendGridProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendGridProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendGridProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendGridProviderConfigValidationError{}

// Validate checks the field values on MailJetProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MailJetProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MailJetProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MailJetProviderConfigMultiError, or nil if none found.
func (m *MailJetProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MailJetProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := MailJetProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for SandboxMode

	// no validation rules for UrlTags

	if all {
		switch v := interface{}(m.GetCustomCampaign()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MailJetProviderConfigValidationError{
					field:  "CustomCampaign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MailJetProviderConfigValidationError{
					field:  "CustomCampaign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCustomCampaign()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MailJetProviderConfigValidationError{
				field:  "CustomCampaign",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MailJetProviderConfigMultiError(errors)
	}

	return nil
}

// MailJetProviderConfigMultiError is an error wrapping multiple validation
// errors returned by MailJetProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type MailJetProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MailJetProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MailJetProviderConfigMultiError) AllErrors() []error { return m }

// MailJetProviderConfigValidationError is the validation error returned by
// MailJetProviderConfig.Validate if the designated constraints aren't met.
type MailJetProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MailJetProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MailJetProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MailJetProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MailJetProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MailJetProviderConfigValidationError) ErrorName() string {
	return "MailJetProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MailJetProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMailJetProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MailJetProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MailJetProviderConfigValidationError{}

// Validate checks the field values on MailgunProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MailgunProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MailgunProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MailgunProviderConfigMultiError, or nil if none found.
func (m *MailgunProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MailgunProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApiKey() != "" {

		if l := utf8.RuneCountInString(m.GetApiKey()); l < 25 || l > 254 {
			err := MailgunProviderConfigValidationError{
				field:  "ApiKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MailgunProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MailgunProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MailgunProviderConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MailgunProviderConfigMultiError(errors)
	}

	return nil
}

// MailgunProviderConfigMultiError is an error wrapping multiple validation
// errors returned by MailgunProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type MailgunProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MailgunProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MailgunProviderConfigMultiError) AllErrors() []error { return m }

// MailgunProviderConfigValidationError is the validation error returned by
// MailgunProviderConfig.Validate if the designated constraints aren't met.
type MailgunProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MailgunProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MailgunProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MailgunProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MailgunProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MailgunProviderConfigValidationError) ErrorName() string {
	return "MailgunProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MailgunProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMailgunProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MailgunProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MailgunProviderConfigValidationError{}

// Validate checks the field values on AmazonSESProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AmazonSESProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmazonSESProviderConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmazonSESProviderConfigMultiError, or nil if none found.
func (m *AmazonSESProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AmazonSESProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetAccessKeyId()); l < 25 || l > 254 {
		err := AmazonSESProviderConfigValidationError{
			field:  "AccessKeyId",
			reason: "value length must be between 25 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecretAccessKey() != "" {

		if l := utf8.RuneCountInString(m.GetSecretAccessKey()); l < 25 || l > 254 {
			err := AmazonSESProviderConfigValidationError{
				field:  "SecretAccessKey",
				reason: "value length must be between 25 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetRegion()); l < 2 || l > 20 {
		err := AmazonSESProviderConfigValidationError{
			field:  "Region",
			reason: "value length must be between 2 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetConfigurationSetName() != "" {

		if utf8.RuneCountInString(m.GetConfigurationSetName()) > 254 {
			err := AmazonSESProviderConfigValidationError{
				field:  "ConfigurationSetName",
				reason: "value length must be at most 254 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmazonSESProviderConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetFeedbackForwardingEmailAddress() != "" {

		if utf8.RuneCountInString(m.GetFeedbackForwardingEmailAddress()) > 503 {
			err := AmazonSESProviderConfigValidationError{
				field:  "FeedbackForwardingEmailAddress",
				reason: "value length must be at most 503 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateEmail(m.GetFeedbackForwardingEmailAddress()); err != nil {
			err = AmazonSESProviderConfigValidationError{
				field:  "FeedbackForwardingEmailAddress",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetReplyToAddresses() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 503 {
			err := AmazonSESProviderConfigValidationError{
				field:  fmt.Sprintf("ReplyToAddresses[%v]", idx),
				reason: "value length must be at most 503 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if err := m._validateEmail(item); err != nil {
			err = AmazonSESProviderConfigValidationError{
				field:  fmt.Sprintf("ReplyToAddresses[%v]", idx),
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return AmazonSESProviderConfigMultiError(errors)
	}

	return nil
}

func (m *AmazonSESProviderConfig) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *AmazonSESProviderConfig) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// AmazonSESProviderConfigMultiError is an error wrapping multiple validation
// errors returned by AmazonSESProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type AmazonSESProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmazonSESProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmazonSESProviderConfigMultiError) AllErrors() []error { return m }

// AmazonSESProviderConfigValidationError is the validation error returned by
// AmazonSESProviderConfig.Validate if the designated constraints aren't met.
type AmazonSESProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmazonSESProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmazonSESProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmazonSESProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmazonSESProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmazonSESProviderConfigValidationError) ErrorName() string {
	return "AmazonSESProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AmazonSESProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmazonSESProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmazonSESProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmazonSESProviderConfigValidationError{}

// Validate checks the field values on EmailDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailDefinitionMultiError, or nil if none found.
func (m *EmailDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Email.(type) {

	case *EmailDefinition_Template:

		if m.GetTemplate() == nil {
			err := EmailDefinitionValidationError{
				field:  "Template",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTemplate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailDefinitionValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailDefinition_Message:

		if m.GetMessage() == nil {
			err := EmailDefinitionValidationError{
				field:  "Message",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMessage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Message",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMessage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailDefinitionValidationError{
					field:  "Message",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EmailDefinitionMultiError(errors)
	}

	return nil
}

// EmailDefinitionMultiError is an error wrapping multiple validation errors
// returned by EmailDefinition.ValidateAll() if the designated constraints
// aren't met.
type EmailDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailDefinitionMultiError) AllErrors() []error { return m }

// EmailDefinitionValidationError is the validation error returned by
// EmailDefinition.Validate if the designated constraints aren't met.
type EmailDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailDefinitionValidationError) ErrorName() string { return "EmailDefinitionValidationError" }

// Error satisfies the builtin error interface
func (e EmailDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailDefinitionValidationError{}

// Validate checks the field values on EmailTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailTemplateMultiError, or
// nil if none found.
func (m *EmailTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTemplateId()); l < 1 || l > 254 {
		err := EmailTemplateValidationError{
			field:  "TemplateId",
			reason: "value length must be between 1 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetTemplateVersion(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 1 || l > 254 {
			err := EmailTemplateValidationError{
				field:  "TemplateVersion",
				reason: "value length must be between 1 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "ReplyTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Cc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBcc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Bcc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSubject() != "" {

		if l := utf8.RuneCountInString(m.GetSubject()); l < 1 || l > 503 {
			err := EmailTemplateValidationError{
				field:  "Subject",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Headers

	// no validation rules for CustomArgs

	{
		sorted_keys := make([]string, len(m.GetDynamicTemplateValues()))
		i := 0
		for key := range m.GetDynamicTemplateValues() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDynamicTemplateValues()[key]
			_ = val

			// no validation rules for DynamicTemplateValues[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmailTemplateValidationError{
						field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetEventPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "EventPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TemplateArn

	if len(errors) > 0 {
		return EmailTemplateMultiError(errors)
	}

	return nil
}

// EmailTemplateMultiError is an error wrapping multiple validation errors
// returned by EmailTemplate.ValidateAll() if the designated constraints
// aren't met.
type EmailTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailTemplateMultiError) AllErrors() []error { return m }

// EmailTemplateValidationError is the validation error returned by
// EmailTemplate.Validate if the designated constraints aren't met.
type EmailTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailTemplateValidationError) ErrorName() string { return "EmailTemplateValidationError" }

// Error satisfies the builtin error interface
func (e EmailTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailTemplateValidationError{}

// Validate checks the field values on EmailAttachment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailAttachmentMultiError, or nil if none found.
func (m *EmailAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentType

	if all {
		switch v := interface{}(m.GetContentId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailAttachmentValidationError{
					field:  "ContentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailAttachmentValidationError{
					field:  "ContentId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContentId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailAttachmentValidationError{
				field:  "ContentId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Inline

	// no validation rules for FileName

	// no validation rules for Content

	if len(errors) > 0 {
		return EmailAttachmentMultiError(errors)
	}

	return nil
}

// EmailAttachmentMultiError is an error wrapping multiple validation errors
// returned by EmailAttachment.ValidateAll() if the designated constraints
// aren't met.
type EmailAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailAttachmentMultiError) AllErrors() []error { return m }

// EmailAttachmentValidationError is the validation error returned by
// EmailAttachment.Validate if the designated constraints aren't met.
type EmailAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailAttachmentValidationError) ErrorName() string { return "EmailAttachmentValidationError" }

// Error satisfies the builtin error interface
func (e EmailAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailAttachmentValidationError{}

// Validate checks the field values on EmailMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailMessageMultiError, or
// nil if none found.
func (m *EmailMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "ReplyTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Cc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBcc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Bcc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetSubject() != "" {

		if l := utf8.RuneCountInString(m.GetSubject()); l < 1 || l > 503 {
			err := EmailMessageValidationError{
				field:  "Subject",
				reason: "value length must be between 1 and 503 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for TextContent

	// no validation rules for HtmlContent

	// no validation rules for Headers

	// no validation rules for CustomArgs

	{
		sorted_keys := make([]string, len(m.GetDynamicTemplateValues()))
		i := 0
		for key := range m.GetDynamicTemplateValues() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDynamicTemplateValues()[key]
			_ = val

			// no validation rules for DynamicTemplateValues[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmailMessageValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmailMessageValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmailMessageValidationError{
						field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailMessageValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailMessageValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetEventPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailMessageValidationError{
					field:  "EventPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailMessageValidationError{
				field:  "EventPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EmailMessageMultiError(errors)
	}

	return nil
}

// EmailMessageMultiError is an error wrapping multiple validation errors
// returned by EmailMessage.ValidateAll() if the designated constraints aren't met.
type EmailMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMessageMultiError) AllErrors() []error { return m }

// EmailMessageValidationError is the validation error returned by
// EmailMessage.Validate if the designated constraints aren't met.
type EmailMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailMessageValidationError) ErrorName() string { return "EmailMessageValidationError" }

// Error satisfies the builtin error interface
func (e EmailMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailMessageValidationError{}

// Validate checks the field values on PasswordProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordProviderConfigMultiError, or nil if none found.
func (m *PasswordProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUsernamePolicy() == nil {
		err := PasswordProviderConfigValidationError{
			field:  "UsernamePolicy",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetUsernamePolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsernamePolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "UsernamePolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPasswordPolicy() == nil {
		err := PasswordProviderConfigValidationError{
			field:  "PasswordPolicy",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPasswordPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "PasswordPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "PasswordPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPasswordPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "PasswordPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFailInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "FailInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "FailInterval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "FailInterval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinimumPasswordLifetime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "MinimumPasswordLifetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "MinimumPasswordLifetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinimumPasswordLifetime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "MinimumPasswordLifetime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaximumPasswordLifetime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "MaximumPasswordLifetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "MaximumPasswordLifetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaximumPasswordLifetime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "MaximumPasswordLifetime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PasswordHistory

	// no validation rules for MaximumConsecutiveFailures

	if all {
		switch v := interface{}(m.GetLockoutTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "LockoutTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordProviderConfigValidationError{
					field:  "LockoutTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLockoutTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordProviderConfigValidationError{
				field:  "LockoutTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PasswordProviderConfigMultiError(errors)
	}

	return nil
}

// PasswordProviderConfigMultiError is an error wrapping multiple validation
// errors returned by PasswordProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type PasswordProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordProviderConfigMultiError) AllErrors() []error { return m }

// PasswordProviderConfigValidationError is the validation error returned by
// PasswordProviderConfig.Validate if the designated constraints aren't met.
type PasswordProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordProviderConfigValidationError) ErrorName() string {
	return "PasswordProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordProviderConfigValidationError{}

// Validate checks the field values on UsernamePolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UsernamePolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UsernamePolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UsernamePolicyMultiError,
// or nil if none found.
func (m *UsernamePolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *UsernamePolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ValidEmail

	// no validation rules for VerifyEmail

	if len(errors) > 0 {
		return UsernamePolicyMultiError(errors)
	}

	return nil
}

// UsernamePolicyMultiError is an error wrapping multiple validation errors
// returned by UsernamePolicy.ValidateAll() if the designated constraints
// aren't met.
type UsernamePolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsernamePolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsernamePolicyMultiError) AllErrors() []error { return m }

// UsernamePolicyValidationError is the validation error returned by
// UsernamePolicy.Validate if the designated constraints aren't met.
type UsernamePolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsernamePolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsernamePolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsernamePolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsernamePolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsernamePolicyValidationError) ErrorName() string { return "UsernamePolicyValidationError" }

// Error satisfies the builtin error interface
func (e UsernamePolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsernamePolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsernamePolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsernamePolicyValidationError{}

// Validate checks the field values on PasswordPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PasswordPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PasswordPolicyMultiError,
// or nil if none found.
func (m *PasswordPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Template

	if all {
		switch v := interface{}(m.GetMinimumLength()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordPolicyValidationError{
					field:  "MinimumLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordPolicyValidationError{
					field:  "MinimumLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinimumLength()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordPolicyValidationError{
				field:  "MinimumLength",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PasswordPolicyMultiError(errors)
	}

	return nil
}

// PasswordPolicyMultiError is an error wrapping multiple validation errors
// returned by PasswordPolicy.ValidateAll() if the designated constraints
// aren't met.
type PasswordPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordPolicyMultiError) AllErrors() []error { return m }

// PasswordPolicyValidationError is the validation error returned by
// PasswordPolicy.Validate if the designated constraints aren't met.
type PasswordPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordPolicyValidationError) ErrorName() string { return "PasswordPolicyValidationError" }

// Error satisfies the builtin error interface
func (e PasswordPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordPolicyValidationError{}

// Validate checks the field values on IngestMappingConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestMappingConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestMappingConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngestMappingConfigMultiError, or nil if none found.
func (m *IngestMappingConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestMappingConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.IngestType.(type) {

	case *IngestMappingConfig_Upsert:

		if all {
			switch v := interface{}(m.GetUpsert()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngestMappingConfigValidationError{
						field:  "Upsert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngestMappingConfigValidationError{
						field:  "Upsert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpsert()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngestMappingConfigValidationError{
					field:  "Upsert",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := IngestMappingConfigValidationError{
			field:  "IngestType",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return IngestMappingConfigMultiError(errors)
	}

	return nil
}

// IngestMappingConfigMultiError is an error wrapping multiple validation
// errors returned by IngestMappingConfig.ValidateAll() if the designated
// constraints aren't met.
type IngestMappingConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestMappingConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestMappingConfigMultiError) AllErrors() []error { return m }

// IngestMappingConfigValidationError is the validation error returned by
// IngestMappingConfig.Validate if the designated constraints aren't met.
type IngestMappingConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestMappingConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestMappingConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestMappingConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestMappingConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestMappingConfigValidationError) ErrorName() string {
	return "IngestMappingConfigValidationError"
}

// Error satisfies the builtin error interface
func (e IngestMappingConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestMappingConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestMappingConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestMappingConfigValidationError{}

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPolicy() == nil {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Policy",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Policy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorizationPolicyConfigValidationError{
				field:  "Policy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

// Validate checks the field values on KnowledgeGraphSchemaConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KnowledgeGraphSchemaConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KnowledgeGraphSchemaConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KnowledgeGraphSchemaConfigMultiError, or nil if none found.
func (m *KnowledgeGraphSchemaConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KnowledgeGraphSchemaConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSchema()) < 1 {
		err := KnowledgeGraphSchemaConfigValidationError{
			field:  "Schema",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KnowledgeGraphSchemaConfigMultiError(errors)
	}

	return nil
}

// KnowledgeGraphSchemaConfigMultiError is an error wrapping multiple
// validation errors returned by KnowledgeGraphSchemaConfig.ValidateAll() if
// the designated constraints aren't met.
type KnowledgeGraphSchemaConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KnowledgeGraphSchemaConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KnowledgeGraphSchemaConfigMultiError) AllErrors() []error { return m }

// KnowledgeGraphSchemaConfigValidationError is the validation error returned
// by KnowledgeGraphSchemaConfig.Validate if the designated constraints aren't met.
type KnowledgeGraphSchemaConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KnowledgeGraphSchemaConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KnowledgeGraphSchemaConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KnowledgeGraphSchemaConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KnowledgeGraphSchemaConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KnowledgeGraphSchemaConfigValidationError) ErrorName() string {
	return "KnowledgeGraphSchemaConfigValidationError"
}

// Error satisfies the builtin error interface
func (e KnowledgeGraphSchemaConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKnowledgeGraphSchemaConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KnowledgeGraphSchemaConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KnowledgeGraphSchemaConfigValidationError{}

// Validate checks the field values on ReadIDProviderConfig_Property with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadIDProviderConfig_Property) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadIDProviderConfig_Property with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReadIDProviderConfig_PropertyMultiError, or nil if none found.
func (m *ReadIDProviderConfig_Property) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadIDProviderConfig_Property) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetExpression()); l < 4 || l > 512 {
		err := ReadIDProviderConfig_PropertyValidationError{
			field:  "Expression",
			reason: "value length must be between 4 and 512 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	if len(errors) > 0 {
		return ReadIDProviderConfig_PropertyMultiError(errors)
	}

	return nil
}

// ReadIDProviderConfig_PropertyMultiError is an error wrapping multiple
// validation errors returned by ReadIDProviderConfig_Property.ValidateAll()
// if the designated constraints aren't met.
type ReadIDProviderConfig_PropertyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadIDProviderConfig_PropertyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadIDProviderConfig_PropertyMultiError) AllErrors() []error { return m }

// ReadIDProviderConfig_PropertyValidationError is the validation error
// returned by ReadIDProviderConfig_Property.Validate if the designated
// constraints aren't met.
type ReadIDProviderConfig_PropertyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadIDProviderConfig_PropertyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadIDProviderConfig_PropertyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadIDProviderConfig_PropertyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadIDProviderConfig_PropertyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadIDProviderConfig_PropertyValidationError) ErrorName() string {
	return "ReadIDProviderConfig_PropertyValidationError"
}

// Error satisfies the builtin error interface
func (e ReadIDProviderConfig_PropertyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadIDProviderConfig_Property.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadIDProviderConfig_PropertyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadIDProviderConfig_PropertyValidationError{}

// Validate checks the field values on IngestMappingConfig_UpsertData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestMappingConfig_UpsertData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestMappingConfig_UpsertData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IngestMappingConfig_UpsertDataMultiError, or nil if none found.
func (m *IngestMappingConfig_UpsertData) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestMappingConfig_UpsertData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetEntities()); l < 1 || l > 10 {
		err := IngestMappingConfig_UpsertDataValidationError{
			field:  "Entities",
			reason: "value must contain between 1 and 10 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngestMappingConfig_UpsertDataValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngestMappingConfig_UpsertDataValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngestMappingConfig_UpsertDataValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IngestMappingConfig_UpsertDataMultiError(errors)
	}

	return nil
}

// IngestMappingConfig_UpsertDataMultiError is an error wrapping multiple
// validation errors returned by IngestMappingConfig_UpsertData.ValidateAll()
// if the designated constraints aren't met.
type IngestMappingConfig_UpsertDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestMappingConfig_UpsertDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestMappingConfig_UpsertDataMultiError) AllErrors() []error { return m }

// IngestMappingConfig_UpsertDataValidationError is the validation error
// returned by IngestMappingConfig_UpsertData.Validate if the designated
// constraints aren't met.
type IngestMappingConfig_UpsertDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestMappingConfig_UpsertDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestMappingConfig_UpsertDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestMappingConfig_UpsertDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestMappingConfig_UpsertDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestMappingConfig_UpsertDataValidationError) ErrorName() string {
	return "IngestMappingConfig_UpsertDataValidationError"
}

// Error satisfies the builtin error interface
func (e IngestMappingConfig_UpsertDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestMappingConfig_UpsertData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestMappingConfig_UpsertDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestMappingConfig_UpsertDataValidationError{}

// Validate checks the field values on IngestMappingConfig_Entity with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestMappingConfig_Entity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestMappingConfig_Entity with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngestMappingConfig_EntityMultiError, or nil if none found.
func (m *IngestMappingConfig_Entity) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestMappingConfig_Entity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTenantId() != "" {

		if l := utf8.RuneCountInString(m.GetTenantId()); l < 22 || l > 254 {
			err := IngestMappingConfig_EntityValidationError{
				field:  "TenantId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_IngestMappingConfig_Entity_TenantId_Pattern.MatchString(m.GetTenantId()) {
			err := IngestMappingConfig_EntityValidationError{
				field:  "TenantId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := len(m.GetLabels()); l < 1 || l > 5 {
		err := IngestMappingConfig_EntityValidationError{
			field:  "Labels",
			reason: "value must contain between 1 and 5 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) > 64 {
			err := IngestMappingConfig_EntityValidationError{
				field:  fmt.Sprintf("Labels[%v]", idx),
				reason: "value length must be at most 64 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_IngestMappingConfig_Entity_Labels_Pattern.MatchString(item) {
			err := IngestMappingConfig_EntityValidationError{
				field:  fmt.Sprintf("Labels[%v]", idx),
				reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetExternalId() == nil {
		err := IngestMappingConfig_EntityValidationError{
			field:  "ExternalId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetExternalId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IngestMappingConfig_EntityValidationError{
					field:  "ExternalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IngestMappingConfig_EntityValidationError{
					field:  "ExternalId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IngestMappingConfig_EntityValidationError{
				field:  "ExternalId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetProperties()) > 20 {
		err := IngestMappingConfig_EntityValidationError{
			field:  "Properties",
			reason: "value must contain no more than 20 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngestMappingConfig_EntityValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngestMappingConfig_EntityValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngestMappingConfig_EntityValidationError{
					field:  fmt.Sprintf("Properties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetRelationships()) > 20 {
		err := IngestMappingConfig_EntityValidationError{
			field:  "Relationships",
			reason: "value must contain no more than 20 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRelationships() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngestMappingConfig_EntityValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngestMappingConfig_EntityValidationError{
						field:  fmt.Sprintf("Relationships[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngestMappingConfig_EntityValidationError{
					field:  fmt.Sprintf("Relationships[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IngestMappingConfig_EntityMultiError(errors)
	}

	return nil
}

// IngestMappingConfig_EntityMultiError is an error wrapping multiple
// validation errors returned by IngestMappingConfig_Entity.ValidateAll() if
// the designated constraints aren't met.
type IngestMappingConfig_EntityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestMappingConfig_EntityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestMappingConfig_EntityMultiError) AllErrors() []error { return m }

// IngestMappingConfig_EntityValidationError is the validation error returned
// by IngestMappingConfig_Entity.Validate if the designated constraints aren't met.
type IngestMappingConfig_EntityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestMappingConfig_EntityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestMappingConfig_EntityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestMappingConfig_EntityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestMappingConfig_EntityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestMappingConfig_EntityValidationError) ErrorName() string {
	return "IngestMappingConfig_EntityValidationError"
}

// Error satisfies the builtin error interface
func (e IngestMappingConfig_EntityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestMappingConfig_Entity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestMappingConfig_EntityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestMappingConfig_EntityValidationError{}

var _IngestMappingConfig_Entity_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _IngestMappingConfig_Entity_Labels_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

// Validate checks the field values on IngestMappingConfig_Property with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestMappingConfig_Property) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestMappingConfig_Property with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngestMappingConfig_PropertyMultiError, or nil if none found.
func (m *IngestMappingConfig_Property) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestMappingConfig_Property) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetSourceName()); l < 1 || l > 256 {
		err := IngestMappingConfig_PropertyValidationError{
			field:  "SourceName",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetMappedName()); l < 1 || l > 256 {
		err := IngestMappingConfig_PropertyValidationError{
			field:  "MappedName",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsRequired

	if len(errors) > 0 {
		return IngestMappingConfig_PropertyMultiError(errors)
	}

	return nil
}

// IngestMappingConfig_PropertyMultiError is an error wrapping multiple
// validation errors returned by IngestMappingConfig_Property.ValidateAll() if
// the designated constraints aren't met.
type IngestMappingConfig_PropertyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestMappingConfig_PropertyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestMappingConfig_PropertyMultiError) AllErrors() []error { return m }

// IngestMappingConfig_PropertyValidationError is the validation error returned
// by IngestMappingConfig_Property.Validate if the designated constraints
// aren't met.
type IngestMappingConfig_PropertyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestMappingConfig_PropertyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestMappingConfig_PropertyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestMappingConfig_PropertyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestMappingConfig_PropertyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestMappingConfig_PropertyValidationError) ErrorName() string {
	return "IngestMappingConfig_PropertyValidationError"
}

// Error satisfies the builtin error interface
func (e IngestMappingConfig_PropertyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestMappingConfig_Property.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestMappingConfig_PropertyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestMappingConfig_PropertyValidationError{}

// Validate checks the field values on IngestMappingConfig_Relationship with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IngestMappingConfig_Relationship) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestMappingConfig_Relationship with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IngestMappingConfig_RelationshipMultiError, or nil if none found.
func (m *IngestMappingConfig_Relationship) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestMappingConfig_Relationship) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetExternalId()); l < 1 || l > 256 {
		err := IngestMappingConfig_RelationshipValidationError{
			field:  "ExternalId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) > 128 {
		err := IngestMappingConfig_RelationshipValidationError{
			field:  "Type",
			reason: "value length must be at most 128 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IngestMappingConfig_Relationship_Type_Pattern.MatchString(m.GetType()) {
		err := IngestMappingConfig_RelationshipValidationError{
			field:  "Type",
			reason: "value does not match regex pattern \"^[A-Z]+(?:_[A-Z]+)*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Direction

	if utf8.RuneCountInString(m.GetMatchLabel()) > 64 {
		err := IngestMappingConfig_RelationshipValidationError{
			field:  "MatchLabel",
			reason: "value length must be at most 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IngestMappingConfig_Relationship_MatchLabel_Pattern.MatchString(m.GetMatchLabel()) {
		err := IngestMappingConfig_RelationshipValidationError{
			field:  "MatchLabel",
			reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IngestMappingConfig_RelationshipMultiError(errors)
	}

	return nil
}

// IngestMappingConfig_RelationshipMultiError is an error wrapping multiple
// validation errors returned by
// IngestMappingConfig_Relationship.ValidateAll() if the designated
// constraints aren't met.
type IngestMappingConfig_RelationshipMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestMappingConfig_RelationshipMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestMappingConfig_RelationshipMultiError) AllErrors() []error { return m }

// IngestMappingConfig_RelationshipValidationError is the validation error
// returned by IngestMappingConfig_Relationship.Validate if the designated
// constraints aren't met.
type IngestMappingConfig_RelationshipValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestMappingConfig_RelationshipValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestMappingConfig_RelationshipValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestMappingConfig_RelationshipValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestMappingConfig_RelationshipValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestMappingConfig_RelationshipValidationError) ErrorName() string {
	return "IngestMappingConfig_RelationshipValidationError"
}

// Error satisfies the builtin error interface
func (e IngestMappingConfig_RelationshipValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestMappingConfig_Relationship.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestMappingConfig_RelationshipValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestMappingConfig_RelationshipValidationError{}

var _IngestMappingConfig_Relationship_Type_Pattern = regexp.MustCompile("^[A-Z]+(?:_[A-Z]+)*$")

var _IngestMappingConfig_Relationship_MatchLabel_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")
