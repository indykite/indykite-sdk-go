// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/config/v1beta1/model.proto

package configv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UniqueNameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UniqueNameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UniqueNameIdentifierMultiError, or nil if none found.
func (m *UniqueNameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *UniqueNameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLocation()); l < 22 || l > 254 {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Location_Pattern.MatchString(m.GetLocation()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Location",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UniqueNameIdentifier_Name_Pattern.MatchString(m.GetName()) {
		err := UniqueNameIdentifierValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UniqueNameIdentifierMultiError(errors)
	}

	return nil
}

// UniqueNameIdentifierMultiError is an error wrapping multiple validation
// errors returned by UniqueNameIdentifier.ValidateAll() if the designated
// constraints aren't met.
type UniqueNameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UniqueNameIdentifierMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UniqueNameIdentifierMultiError) AllErrors() []error { return m }

// UniqueNameIdentifierValidationError is the validation error returned by
// UniqueNameIdentifier.Validate if the designated constraints aren't met.
type UniqueNameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UniqueNameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UniqueNameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UniqueNameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UniqueNameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UniqueNameIdentifierValidationError) ErrorName() string {
	return "UniqueNameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e UniqueNameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUniqueNameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UniqueNameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UniqueNameIdentifierValidationError{}

var _UniqueNameIdentifier_Location_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _UniqueNameIdentifier_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on Customer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Customer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Customer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerMultiError, or nil
// if none found.
func (m *Customer) ValidateAll() error {
	return m.validate(true)
}

func (m *Customer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Id_Pattern.MatchString(m.GetId()) {
		err := CustomerValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Customer_Name_Pattern.MatchString(m.GetName()) {
		err := CustomerValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := CustomerValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := CustomerValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CustomerValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CustomerValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if len(errors) > 0 {
		return CustomerMultiError(errors)
	}

	return nil
}

// CustomerMultiError is an error wrapping multiple validation errors returned
// by Customer.ValidateAll() if the designated constraints aren't met.
type CustomerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerMultiError) AllErrors() []error { return m }

// CustomerValidationError is the validation error returned by
// Customer.Validate if the designated constraints aren't met.
type CustomerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerValidationError) ErrorName() string { return "CustomerValidationError" }

// Error satisfies the builtin error interface
func (e CustomerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerValidationError{}

var _Customer_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Customer_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

// Validate checks the field values on ApplicationSpace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceMultiError, or nil if none found.
func (m *ApplicationSpace) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationSpaceValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationSpaceValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationSpaceValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationSpace_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationSpaceValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IkgStatus

	// no validation rules for Region

	if len(errors) > 0 {
		return ApplicationSpaceMultiError(errors)
	}

	return nil
}

// ApplicationSpaceMultiError is an error wrapping multiple validation errors
// returned by ApplicationSpace.ValidateAll() if the designated constraints
// aren't met.
type ApplicationSpaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceMultiError) AllErrors() []error { return m }

// ApplicationSpaceValidationError is the validation error returned by
// ApplicationSpace.Validate if the designated constraints aren't met.
type ApplicationSpaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceValidationError) ErrorName() string { return "ApplicationSpaceValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationSpaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceValidationError{}

var _ApplicationSpace_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationSpace_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationSpace_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Application_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _Application_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _Application_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentMultiError, or nil if none found.
func (m *ApplicationAgent) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationAgentValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ApplicationAgentValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgent_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentMultiError(errors)
	}

	return nil
}

// ApplicationAgentMultiError is an error wrapping multiple validation errors
// returned by ApplicationAgent.ValidateAll() if the designated constraints
// aren't met.
type ApplicationAgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentMultiError) AllErrors() []error { return m }

// ApplicationAgentValidationError is the validation error returned by
// ApplicationAgent.Validate if the designated constraints aren't met.
type ApplicationAgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentValidationError) ErrorName() string { return "ApplicationAgentValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationAgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentValidationError{}

var _ApplicationAgent_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ApplicationAgent_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgent_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgentCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialMultiError, or nil if none found.
func (m *ApplicationAgentCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetApplicationAgentId()); l < 22 || l > 254 {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApplicationAgentCredential_ApplicationAgentId_Pattern.MatchString(m.GetApplicationAgentId()) {
		err := ApplicationAgentCredentialValidationError{
			field:  "ApplicationAgentId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialMultiError is an error wrapping multiple
// validation errors returned by ApplicationAgentCredential.ValidateAll() if
// the designated constraints aren't met.
type ApplicationAgentCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialValidationError is the validation error returned
// by ApplicationAgentCredential.Validate if the designated constraints aren't met.
type ApplicationAgentCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialValidationError) ErrorName() string {
	return "ApplicationAgentCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialValidationError{}

var _ApplicationAgentCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ApplicationAgentCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ApplicationAgentCredential_ApplicationAgentId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceAccountMultiError,
// or nil if none found.
func (m *ServiceAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_Name_Pattern.MatchString(m.GetName()) {
		err := ServiceAccountValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccount_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccount_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ServiceAccountMultiError(errors)
	}

	return nil
}

// ServiceAccountMultiError is an error wrapping multiple validation errors
// returned by ServiceAccount.ValidateAll() if the designated constraints
// aren't met.
type ServiceAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountMultiError) AllErrors() []error { return m }

// ServiceAccountValidationError is the validation error returned by
// ServiceAccount.Validate if the designated constraints aren't met.
type ServiceAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountValidationError) ErrorName() string { return "ServiceAccountValidationError" }

// Error satisfies the builtin error interface
func (e ServiceAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountValidationError{}

var _ServiceAccount_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ServiceAccount_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccount_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ServiceAccountCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredential with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialMultiError, or nil if none found.
func (m *ServiceAccountCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Id_Pattern.MatchString(m.GetId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKid()); l < 41 || l > 45 {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value length must be between 41 and 45 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_Kid_Pattern.MatchString(m.GetKid()) {
		err := ServiceAccountCredentialValidationError{
			field:  "Kid",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9-_]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppSpaceId() != "" {

		if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value length must be between 22 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_ServiceAccountCredential_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
			err := ServiceAccountCredentialValidationError{
				field:  "AppSpaceId",
				reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetServiceAccountId()); l < 22 || l > 254 {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ServiceAccountCredential_ServiceAccountId_Pattern.MatchString(m.GetServiceAccountId()) {
		err := ServiceAccountCredentialValidationError{
			field:  "ServiceAccountId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialMultiError is an error wrapping multiple validation
// errors returned by ServiceAccountCredential.ValidateAll() if the designated
// constraints aren't met.
type ServiceAccountCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialValidationError is the validation error returned by
// ServiceAccountCredential.Validate if the designated constraints aren't met.
type ServiceAccountCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialValidationError) ErrorName() string {
	return "ServiceAccountCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialValidationError{}

var _ServiceAccountCredential_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_Kid_Pattern = regexp.MustCompile("^[a-zA-Z0-9-_]+$")

var _ServiceAccountCredential_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ServiceAccountCredential_ServiceAccountId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on ConfigNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigNodeMultiError, or
// nil if none found.
func (m *ConfigNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Id_Pattern.MatchString(m.GetId()) {
		err := ConfigNodeValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 2 || l > 63 {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_Name_Pattern.MatchString(m.GetName()) {
		err := ConfigNodeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDisplayName()); l < 2 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "DisplayName",
			reason: "value length must be between 2 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if wrapper := m.GetDescription(); wrapper != nil {

		if l := utf8.RuneCountInString(wrapper.GetValue()); l < 2 || l > 254 {
			err := ConfigNodeValidationError{
				field:  "Description",
				reason: "value length must be between 2 and 254 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	// no validation rules for UpdatedBy

	if all {
		switch v := interface{}(m.GetDestroyTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DestroyTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestroyTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DestroyTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeleteTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigNodeValidationError{
					field:  "DeleteTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeleteTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigNodeValidationError{
				field:  "DeleteTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Etag

	if l := utf8.RuneCountInString(m.GetCustomerId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_CustomerId_Pattern.MatchString(m.GetCustomerId()) {
		err := ConfigNodeValidationError{
			field:  "CustomerId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAppSpaceId()); l < 22 || l > 254 {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConfigNode_AppSpaceId_Pattern.MatchString(m.GetAppSpaceId()) {
		err := ConfigNodeValidationError{
			field:  "AppSpaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *ConfigNode_EventSinkConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetEventSinkConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "EventSinkConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEventSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EventSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EventSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "EventSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetAuthorizationPolicyConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "AuthorizationPolicyConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_ConsentConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetConsentConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "ConsentConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_TokenIntrospectConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetTokenIntrospectConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "TokenIntrospectConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenIntrospectConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenIntrospectConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "TokenIntrospectConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_IngestPipelineConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetIngestPipelineConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "IngestPipelineConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIngestPipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIngestPipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "IngestPipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_EntityMatchingPipelineConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetEntityMatchingPipelineConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "EntityMatchingPipelineConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEntityMatchingPipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EntityMatchingPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "EntityMatchingPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEntityMatchingPipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "EntityMatchingPipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_ExternalDataResolverConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetExternalDataResolverConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "ExternalDataResolverConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExternalDataResolverConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ExternalDataResolverConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "ExternalDataResolverConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExternalDataResolverConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "ExternalDataResolverConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_TrustScoreProfileConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetTrustScoreProfileConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "TrustScoreProfileConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrustScoreProfileConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TrustScoreProfileConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "TrustScoreProfileConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrustScoreProfileConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "TrustScoreProfileConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_KnowledgeQueryConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetKnowledgeQueryConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "KnowledgeQueryConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKnowledgeQueryConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "KnowledgeQueryConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "KnowledgeQueryConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKnowledgeQueryConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "KnowledgeQueryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_CapturePipelineConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetCapturePipelineConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "CapturePipelineConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCapturePipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "CapturePipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "CapturePipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCapturePipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "CapturePipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigNode_CapturePipelineTopicConfig:
		if v == nil {
			err := ConfigNodeValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if m.GetCapturePipelineTopicConfig() == nil {
			err := ConfigNodeValidationError{
				field:  "CapturePipelineTopicConfig",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCapturePipelineTopicConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "CapturePipelineTopicConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigNodeValidationError{
						field:  "CapturePipelineTopicConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCapturePipelineTopicConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigNodeValidationError{
					field:  "CapturePipelineTopicConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := ConfigNodeValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigNodeMultiError(errors)
	}

	return nil
}

// ConfigNodeMultiError is an error wrapping multiple validation errors
// returned by ConfigNode.ValidateAll() if the designated constraints aren't met.
type ConfigNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigNodeMultiError) AllErrors() []error { return m }

// ConfigNodeValidationError is the validation error returned by
// ConfigNode.Validate if the designated constraints aren't met.
type ConfigNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigNodeValidationError) ErrorName() string { return "ConfigNodeValidationError" }

// Error satisfies the builtin error interface
func (e ConfigNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigNodeValidationError{}

var _ConfigNode_Id_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_Name_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _ConfigNode_CustomerId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

var _ConfigNode_AppSpaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPolicy()) > 512000 {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Policy",
			reason: "value length must be at most 512000 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := AuthorizationPolicyConfig_Status_name[int32(m.GetStatus())]; !ok {
		err := AuthorizationPolicyConfigValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTags()) > 0 {

		_AuthorizationPolicyConfig_Tags_Unique := make(map[string]struct{}, len(m.GetTags()))

		for idx, item := range m.GetTags() {
			_, _ = idx, item

			if _, exists := _AuthorizationPolicyConfig_Tags_Unique[item]; exists {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_AuthorizationPolicyConfig_Tags_Unique[item] = struct{}{}
			}

			if l := utf8.RuneCountInString(item); l < 1 || l > 20 {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value length must be between 1 and 20 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_AuthorizationPolicyConfig_Tags_Pattern.MatchString(item) {
				err := AuthorizationPolicyConfigValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if all {
		switch v := interface{}(m.GetBuilder()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthorizationPolicyConfigValidationError{
					field:  "Builder",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuilder()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthorizationPolicyConfigValidationError{
				field:  "Builder",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

var _AuthorizationPolicyConfig_Tags_Pattern = regexp.MustCompile("^[a-zA-Z0-9]+$")

// Validate checks the field values on EventSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfigMultiError, or nil if none found.
func (m *EventSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetProviders()))
		i := 0
		for key := range m.GetProviders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProviders()[key]
			_ = val

			// no validation rules for Providers[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EventSinkConfigValidationError{
							field:  fmt.Sprintf("Providers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EventSinkConfigValidationError{
							field:  fmt.Sprintf("Providers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EventSinkConfigValidationError{
						field:  fmt.Sprintf("Providers[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventSinkConfigMultiError(errors)
	}

	return nil
}

// EventSinkConfigMultiError is an error wrapping multiple validation errors
// returned by EventSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type EventSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfigMultiError) AllErrors() []error { return m }

// EventSinkConfigValidationError is the validation error returned by
// EventSinkConfig.Validate if the designated constraints aren't met.
type EventSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfigValidationError) ErrorName() string { return "EventSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e EventSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfigValidationError{}

// Validate checks the field values on KafkaSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *KafkaSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KafkaSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KafkaSinkConfigMultiError, or nil if none found.
func (m *KafkaSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KafkaSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetBrokers()) > 0 {

		_KafkaSinkConfig_Brokers_Unique := make(map[string]struct{}, len(m.GetBrokers()))

		for idx, item := range m.GetBrokers() {
			_, _ = idx, item

			if _, exists := _KafkaSinkConfig_Brokers_Unique[item]; exists {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "repeated value must contain unique items",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			} else {
				_KafkaSinkConfig_Brokers_Unique[item] = struct{}{}
			}

			if utf8.RuneCountInString(item) < 8 {
				err := KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value length must be at least 8 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if _, err := url.Parse(item); err != nil {
				err = KafkaSinkConfigValidationError{
					field:  fmt.Sprintf("Brokers[%v]", idx),
					reason: "value must be a valid URI",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if l := utf8.RuneCountInString(m.GetTopic()); l < 1 || l > 249 {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value length must be between 1 and 249 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_KafkaSinkConfig_Topic_Pattern.MatchString(m.GetTopic()) {
		err := KafkaSinkConfigValidationError{
			field:  "Topic",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9._-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return KafkaSinkConfigMultiError(errors)
	}

	return nil
}

// KafkaSinkConfigMultiError is an error wrapping multiple validation errors
// returned by KafkaSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type KafkaSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KafkaSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KafkaSinkConfigMultiError) AllErrors() []error { return m }

// KafkaSinkConfigValidationError is the validation error returned by
// KafkaSinkConfig.Validate if the designated constraints aren't met.
type KafkaSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KafkaSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KafkaSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KafkaSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KafkaSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KafkaSinkConfigValidationError) ErrorName() string { return "KafkaSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e KafkaSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKafkaSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KafkaSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KafkaSinkConfigValidationError{}

var _KafkaSinkConfig_Topic_Pattern = regexp.MustCompile("^[a-zA-Z0-9._-]+$")

// Validate checks the field values on AzureEventGridSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AzureEventGridSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AzureEventGridSinkConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AzureEventGridSinkConfigMultiError, or nil if none found.
func (m *AzureEventGridSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AzureEventGridSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetTopicEndpoint()); l < 1 || l > 1024 {
		err := AzureEventGridSinkConfigValidationError{
			field:  "TopicEndpoint",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if uri, err := url.Parse(m.GetTopicEndpoint()); err != nil {
		err = AzureEventGridSinkConfigValidationError{
			field:  "TopicEndpoint",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := AzureEventGridSinkConfigValidationError{
			field:  "TopicEndpoint",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAccessKey()); l < 1 || l > 1024 {
		err := AzureEventGridSinkConfigValidationError{
			field:  "AccessKey",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AzureEventGridSinkConfigMultiError(errors)
	}

	return nil
}

// AzureEventGridSinkConfigMultiError is an error wrapping multiple validation
// errors returned by AzureEventGridSinkConfig.ValidateAll() if the designated
// constraints aren't met.
type AzureEventGridSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzureEventGridSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzureEventGridSinkConfigMultiError) AllErrors() []error { return m }

// AzureEventGridSinkConfigValidationError is the validation error returned by
// AzureEventGridSinkConfig.Validate if the designated constraints aren't met.
type AzureEventGridSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzureEventGridSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzureEventGridSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzureEventGridSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzureEventGridSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzureEventGridSinkConfigValidationError) ErrorName() string {
	return "AzureEventGridSinkConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AzureEventGridSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzureEventGridSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzureEventGridSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzureEventGridSinkConfigValidationError{}

// Validate checks the field values on AzureServiceBusSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AzureServiceBusSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AzureServiceBusSinkConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AzureServiceBusSinkConfigMultiError, or nil if none found.
func (m *AzureServiceBusSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AzureServiceBusSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetConnectionString()); l < 1 || l > 1024 {
		err := AzureServiceBusSinkConfigValidationError{
			field:  "ConnectionString",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetQueueOrTopicName()); l < 1 || l > 1024 {
		err := AzureServiceBusSinkConfigValidationError{
			field:  "QueueOrTopicName",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AzureServiceBusSinkConfigMultiError(errors)
	}

	return nil
}

// AzureServiceBusSinkConfigMultiError is an error wrapping multiple validation
// errors returned by AzureServiceBusSinkConfig.ValidateAll() if the
// designated constraints aren't met.
type AzureServiceBusSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzureServiceBusSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzureServiceBusSinkConfigMultiError) AllErrors() []error { return m }

// AzureServiceBusSinkConfigValidationError is the validation error returned by
// AzureServiceBusSinkConfig.Validate if the designated constraints aren't met.
type AzureServiceBusSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzureServiceBusSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzureServiceBusSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzureServiceBusSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzureServiceBusSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzureServiceBusSinkConfigValidationError) ErrorName() string {
	return "AzureServiceBusSinkConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AzureServiceBusSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzureServiceBusSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzureServiceBusSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzureServiceBusSinkConfigValidationError{}

// Validate checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentConfigurationMultiError, or nil if none found.
func (m *ConsentConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPurpose()) > 1024 {
		err := ConsentConfigurationValidationError{
			field:  "Purpose",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDataPoints()) < 1 {
		err := ConsentConfigurationValidationError{
			field:  "DataPoints",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_ConsentConfiguration_DataPoints_Unique := make(map[string]struct{}, len(m.GetDataPoints()))

	for idx, item := range m.GetDataPoints() {
		_, _ = idx, item

		if _, exists := _ConsentConfiguration_DataPoints_Unique[item]; exists {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ConsentConfiguration_DataPoints_Unique[item] = struct{}{}
		}

		if l := utf8.RuneCountInString(item); l < 1 || l > 1024 {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value length must be between 1 and 1024 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !strings.HasPrefix(item, "{") {
			err := ConsentConfigurationValidationError{
				field:  fmt.Sprintf("DataPoints[%v]", idx),
				reason: "value does not have prefix \"{\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if l := utf8.RuneCountInString(m.GetApplicationId()); l < 22 || l > 254 {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ConsentConfiguration_ApplicationId_Pattern.MatchString(m.GetApplicationId()) {
		err := ConsentConfigurationValidationError{
			field:  "ApplicationId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetValidityPeriod(); val < 86400 || val > 63072000 {
		err := ConsentConfigurationValidationError{
			field:  "ValidityPeriod",
			reason: "value must be inside range [86400, 63072000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RevokeAfterUse

	// no validation rules for TokenStatus

	if len(errors) > 0 {
		return ConsentConfigurationMultiError(errors)
	}

	return nil
}

// ConsentConfigurationMultiError is an error wrapping multiple validation
// errors returned by ConsentConfiguration.ValidateAll() if the designated
// constraints aren't met.
type ConsentConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentConfigurationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentConfigurationMultiError) AllErrors() []error { return m }

// ConsentConfigurationValidationError is the validation error returned by
// ConsentConfiguration.Validate if the designated constraints aren't met.
type ConsentConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentConfigurationValidationError) ErrorName() string {
	return "ConsentConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentConfigurationValidationError{}

var _ConsentConfiguration_ApplicationId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfigMultiError, or nil if none found.
func (m *TokenIntrospectConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			if utf8.RuneCountInString(key) > 256 {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value length must be at most 256 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_TokenIntrospectConfig_ClaimsMapping_Pattern.MatchString(key) {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z_][a-zA-Z0-9_]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if val == nil {
				err := TokenIntrospectConfigValidationError{
					field:  fmt.Sprintf("ClaimsMapping[%v]", key),
					reason: "value is required",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenIntrospectConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetSubClaim()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenIntrospectConfigValidationError{
					field:  "SubClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenIntrospectConfigValidationError{
					field:  "SubClaim",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubClaim()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenIntrospectConfigValidationError{
				field:  "SubClaim",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetIkgNodeType()); l < 2 || l > 64 {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value length must be between 2 and 64 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_TokenIntrospectConfig_IkgNodeType_Pattern.MatchString(m.GetIkgNodeType()) {
		err := TokenIntrospectConfigValidationError{
			field:  "IkgNodeType",
			reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PerformUpsert

	oneofTokenMatcherPresent := false
	switch v := m.TokenMatcher.(type) {
	case *TokenIntrospectConfig_Jwt:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetJwt() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Jwt",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Opaque_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofTokenMatcherPresent = true

		if m.GetOpaque() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Opaque",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpaque()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofTokenMatcherPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "TokenMatcher",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}
	oneofValidationPresent := false
	switch v := m.Validation.(type) {
	case *TokenIntrospectConfig_Offline_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOffline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Offline",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Online_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofValidationPresent = true

		if m.GetOnline() == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Online",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Online",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofValidationPresent {
		err := TokenIntrospectConfigValidationError{
			field:  "Validation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfigMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfigMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfigMultiError) AllErrors() []error { return m }

// TokenIntrospectConfigValidationError is the validation error returned by
// TokenIntrospectConfig.Validate if the designated constraints aren't met.
type TokenIntrospectConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfigValidationError) ErrorName() string {
	return "TokenIntrospectConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfigValidationError{}

var _TokenIntrospectConfig_ClaimsMapping_Pattern = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_]+$")

var _TokenIntrospectConfig_IkgNodeType_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

// Validate checks the field values on ConsentDataPoint with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPointMultiError, or nil if none found.
func (m *ConsentDataPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuery()) > 1024 {
		err := ConsentDataPointValidationError{
			field:  "Query",
			reason: "value length must be at most 1024 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetReturns()); l < 1 || l > 20 {
		err := ConsentDataPointValidationError{
			field:  "Returns",
			reason: "value must contain between 1 and 20 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetReturns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConsentDataPointValidationError{
						field:  fmt.Sprintf("Returns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConsentDataPointValidationError{
					field:  fmt.Sprintf("Returns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConsentDataPointMultiError(errors)
	}

	return nil
}

// ConsentDataPointMultiError is an error wrapping multiple validation errors
// returned by ConsentDataPoint.ValidateAll() if the designated constraints
// aren't met.
type ConsentDataPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPointMultiError) AllErrors() []error { return m }

// ConsentDataPointValidationError is the validation error returned by
// ConsentDataPoint.Validate if the designated constraints aren't met.
type ConsentDataPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPointValidationError) ErrorName() string { return "ConsentDataPointValidationError" }

// Error satisfies the builtin error interface
func (e ConsentDataPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPointValidationError{}

// Validate checks the field values on IngestPipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestPipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestPipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngestPipelineConfigMultiError, or nil if none found.
func (m *IngestPipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestPipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSources()); l < 1 || l > 10 {
		err := IngestPipelineConfigValidationError{
			field:  "Sources",
			reason: "value must contain between 1 and 10 items, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSources() {
		_, _ = idx, item

		if !_IngestPipelineConfig_Sources_Pattern.MatchString(item) {
			err := IngestPipelineConfigValidationError{
				field:  fmt.Sprintf("Sources[%v]", idx),
				reason: "value does not match regex pattern \"^[a-zA-Z0-9._-]{1,227}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetOperations()) > 6 {
		err := IngestPipelineConfigValidationError{
			field:  "Operations",
			reason: "value must contain no more than 6 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_IngestPipelineConfig_AppAgentToken_Pattern.MatchString(m.GetAppAgentToken()) {
		err := IngestPipelineConfigValidationError{
			field:  "AppAgentToken",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_]+?\\\\.[A-Za-z0-9-_]+?\\\\.[A-Za-z0-9-_]+?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IngestPipelineConfigMultiError(errors)
	}

	return nil
}

// IngestPipelineConfigMultiError is an error wrapping multiple validation
// errors returned by IngestPipelineConfig.ValidateAll() if the designated
// constraints aren't met.
type IngestPipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestPipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestPipelineConfigMultiError) AllErrors() []error { return m }

// IngestPipelineConfigValidationError is the validation error returned by
// IngestPipelineConfig.Validate if the designated constraints aren't met.
type IngestPipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestPipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestPipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestPipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestPipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestPipelineConfigValidationError) ErrorName() string {
	return "IngestPipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e IngestPipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestPipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestPipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestPipelineConfigValidationError{}

var _IngestPipelineConfig_Sources_Pattern = regexp.MustCompile("^[a-zA-Z0-9._-]{1,227}$")

var _IngestPipelineConfig_AppAgentToken_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?$")

// Validate checks the field values on EntityMatchingPipelineConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EntityMatchingPipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntityMatchingPipelineConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntityMatchingPipelineConfigMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "NodeFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "NodeFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "NodeFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetSimilarityScoreCutoff(); val < 0 || val > 1 {
		err := EntityMatchingPipelineConfigValidationError{
			field:  "SimilarityScoreCutoff",
			reason: "value must be inside range [0, 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := EntityMatchingPipelineConfig_Status_name[int32(m.GetPropertyMappingStatus())]; !ok {
		err := EntityMatchingPipelineConfigValidationError{
			field:  "PropertyMappingStatus",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPropertyMappingMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "PropertyMappingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "PropertyMappingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPropertyMappingMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "PropertyMappingMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := EntityMatchingPipelineConfig_Status_name[int32(m.GetEntityMatchingStatus())]; !ok {
		err := EntityMatchingPipelineConfigValidationError{
			field:  "EntityMatchingStatus",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEntityMatchingMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "EntityMatchingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "EntityMatchingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntityMatchingMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "EntityMatchingMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPropertyMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityMatchingPipelineConfigValidationError{
						field:  fmt.Sprintf("PropertyMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityMatchingPipelineConfigValidationError{
						field:  fmt.Sprintf("PropertyMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityMatchingPipelineConfigValidationError{
					field:  fmt.Sprintf("PropertyMappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RerunInterval

	if all {
		switch v := interface{}(m.GetLastRunTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "LastRunTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "LastRunTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastRunTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "LastRunTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportUrl()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportUrl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportUrl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportUrl()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "ReportUrl",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "ReportType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EntityMatchingPipelineConfigMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfigMultiError is an error wrapping multiple
// validation errors returned by EntityMatchingPipelineConfig.ValidateAll() if
// the designated constraints aren't met.
type EntityMatchingPipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfigMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfigValidationError is the validation error returned
// by EntityMatchingPipelineConfig.Validate if the designated constraints
// aren't met.
type EntityMatchingPipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfigValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfigValidationError{}

// Validate checks the field values on ExternalDataResolverConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExternalDataResolverConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExternalDataResolverConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExternalDataResolverConfigMultiError, or nil if none found.
func (m *ExternalDataResolverConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ExternalDataResolverConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetUrl()); err != nil {
		err = ExternalDataResolverConfigValidationError{
			field:  "Url",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := ExternalDataResolverConfigValidationError{
			field:  "Url",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ExternalDataResolverConfig_Method_InLookup[m.GetMethod()]; !ok {
		err := ExternalDataResolverConfigValidationError{
			field:  "Method",
			reason: "value must be in list [GET POST PUT PATCH]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetHeaders()))
		i := 0
		for key := range m.GetHeaders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetHeaders()[key]
			_ = val

			if l := utf8.RuneCountInString(key); l < 1 || l > 255 {
				err := ExternalDataResolverConfigValidationError{
					field:  fmt.Sprintf("Headers[%v]", key),
					reason: "value length must be between 1 and 255 runes, inclusive",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if !_ExternalDataResolverConfig_Headers_Pattern.MatchString(key) {
				err := ExternalDataResolverConfigValidationError{
					field:  fmt.Sprintf("Headers[%v]", key),
					reason: "value does not match regex pattern \"^[a-zA-Z0-9-]+$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if val == nil {
				err := ExternalDataResolverConfigValidationError{
					field:  fmt.Sprintf("Headers[%v]", key),
					reason: "value is required",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ExternalDataResolverConfigValidationError{
							field:  fmt.Sprintf("Headers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ExternalDataResolverConfigValidationError{
							field:  fmt.Sprintf("Headers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ExternalDataResolverConfigValidationError{
						field:  fmt.Sprintf("Headers[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if _, ok := _ExternalDataResolverConfig_RequestType_NotInLookup[m.GetRequestType()]; ok {
		err := ExternalDataResolverConfigValidationError{
			field:  "RequestType",
			reason: "value must not be in list [CONTENT_TYPE_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ExternalDataResolverConfig_ContentType_name[int32(m.GetRequestType())]; !ok {
		err := ExternalDataResolverConfigValidationError{
			field:  "RequestType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RequestPayload

	if _, ok := _ExternalDataResolverConfig_ResponseType_NotInLookup[m.GetResponseType()]; ok {
		err := ExternalDataResolverConfigValidationError{
			field:  "ResponseType",
			reason: "value must not be in list [CONTENT_TYPE_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ExternalDataResolverConfig_ContentType_name[int32(m.GetResponseType())]; !ok {
		err := ExternalDataResolverConfigValidationError{
			field:  "ResponseType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetResponseSelector()); l < 1 || l > 255 {
		err := ExternalDataResolverConfigValidationError{
			field:  "ResponseSelector",
			reason: "value length must be between 1 and 255 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExternalDataResolverConfigMultiError(errors)
	}

	return nil
}

// ExternalDataResolverConfigMultiError is an error wrapping multiple
// validation errors returned by ExternalDataResolverConfig.ValidateAll() if
// the designated constraints aren't met.
type ExternalDataResolverConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExternalDataResolverConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExternalDataResolverConfigMultiError) AllErrors() []error { return m }

// ExternalDataResolverConfigValidationError is the validation error returned
// by ExternalDataResolverConfig.Validate if the designated constraints aren't met.
type ExternalDataResolverConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExternalDataResolverConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExternalDataResolverConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExternalDataResolverConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExternalDataResolverConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExternalDataResolverConfigValidationError) ErrorName() string {
	return "ExternalDataResolverConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ExternalDataResolverConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExternalDataResolverConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExternalDataResolverConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExternalDataResolverConfigValidationError{}

var _ExternalDataResolverConfig_Method_InLookup = map[string]struct{}{
	"GET":   {},
	"POST":  {},
	"PUT":   {},
	"PATCH": {},
}

var _ExternalDataResolverConfig_Headers_Pattern = regexp.MustCompile("^[a-zA-Z0-9-]+$")

var _ExternalDataResolverConfig_RequestType_NotInLookup = map[ExternalDataResolverConfig_ContentType]struct{}{
	0: {},
}

var _ExternalDataResolverConfig_ResponseType_NotInLookup = map[ExternalDataResolverConfig_ContentType]struct{}{
	0: {},
}

// Validate checks the field values on TrustScoreDimension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrustScoreDimension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrustScoreDimension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrustScoreDimensionMultiError, or nil if none found.
func (m *TrustScoreDimension) ValidateAll() error {
	return m.validate(true)
}

func (m *TrustScoreDimension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _TrustScoreDimension_Name_NotInLookup[m.GetName()]; ok {
		err := TrustScoreDimensionValidationError{
			field:  "Name",
			reason: "value must not be in list [NAME_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TrustScoreDimension_Name_name[int32(m.GetName())]; !ok {
		err := TrustScoreDimensionValidationError{
			field:  "Name",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetWeight(); val < 0 || val > 1 {
		err := TrustScoreDimensionValidationError{
			field:  "Weight",
			reason: "value must be inside range [0, 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TrustScoreDimensionMultiError(errors)
	}

	return nil
}

// TrustScoreDimensionMultiError is an error wrapping multiple validation
// errors returned by TrustScoreDimension.ValidateAll() if the designated
// constraints aren't met.
type TrustScoreDimensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrustScoreDimensionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrustScoreDimensionMultiError) AllErrors() []error { return m }

// TrustScoreDimensionValidationError is the validation error returned by
// TrustScoreDimension.Validate if the designated constraints aren't met.
type TrustScoreDimensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrustScoreDimensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrustScoreDimensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrustScoreDimensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrustScoreDimensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrustScoreDimensionValidationError) ErrorName() string {
	return "TrustScoreDimensionValidationError"
}

// Error satisfies the builtin error interface
func (e TrustScoreDimensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrustScoreDimension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrustScoreDimensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrustScoreDimensionValidationError{}

var _TrustScoreDimension_Name_NotInLookup = map[TrustScoreDimension_Name]struct{}{
	0: {},
}

// Validate checks the field values on TrustScoreProfileConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrustScoreProfileConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrustScoreProfileConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrustScoreProfileConfigMultiError, or nil if none found.
func (m *TrustScoreProfileConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TrustScoreProfileConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNodeClassification() != "" {

		if !_TrustScoreProfileConfig_NodeClassification_Pattern.MatchString(m.GetNodeClassification()) {
			err := TrustScoreProfileConfigValidationError{
				field:  "NodeClassification",
				reason: "value does not match regex pattern \"^([A-Z][a-z]+)+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrustScoreProfileConfigValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrustScoreProfileConfigValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrustScoreProfileConfigValidationError{
					field:  fmt.Sprintf("Dimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if _, ok := _TrustScoreProfileConfig_Schedule_NotInLookup[m.GetSchedule()]; ok {
		err := TrustScoreProfileConfigValidationError{
			field:  "Schedule",
			reason: "value must not be in list [UPDATE_FREQUENCY_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TrustScoreProfileConfig_UpdateFrequency_name[int32(m.GetSchedule())]; !ok {
		err := TrustScoreProfileConfigValidationError{
			field:  "Schedule",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TrustScoreProfileConfigMultiError(errors)
	}

	return nil
}

// TrustScoreProfileConfigMultiError is an error wrapping multiple validation
// errors returned by TrustScoreProfileConfig.ValidateAll() if the designated
// constraints aren't met.
type TrustScoreProfileConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrustScoreProfileConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrustScoreProfileConfigMultiError) AllErrors() []error { return m }

// TrustScoreProfileConfigValidationError is the validation error returned by
// TrustScoreProfileConfig.Validate if the designated constraints aren't met.
type TrustScoreProfileConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrustScoreProfileConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrustScoreProfileConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrustScoreProfileConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrustScoreProfileConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrustScoreProfileConfigValidationError) ErrorName() string {
	return "TrustScoreProfileConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TrustScoreProfileConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrustScoreProfileConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrustScoreProfileConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrustScoreProfileConfigValidationError{}

var _TrustScoreProfileConfig_NodeClassification_Pattern = regexp.MustCompile("^([A-Z][a-z]+)+$")

var _TrustScoreProfileConfig_Schedule_NotInLookup = map[TrustScoreProfileConfig_UpdateFrequency]struct{}{
	0: {},
}

// Validate checks the field values on KnowledgeQueryConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KnowledgeQueryConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KnowledgeQueryConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KnowledgeQueryConfigMultiError, or nil if none found.
func (m *KnowledgeQueryConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KnowledgeQueryConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetQuery()) > 512000 {
		err := KnowledgeQueryConfigValidationError{
			field:  "Query",
			reason: "value length must be at most 512000 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _KnowledgeQueryConfig_Status_NotInLookup[m.GetStatus()]; ok {
		err := KnowledgeQueryConfigValidationError{
			field:  "Status",
			reason: "value must not be in list [STATUS_INVALID]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := KnowledgeQueryConfig_Status_name[int32(m.GetStatus())]; !ok {
		err := KnowledgeQueryConfigValidationError{
			field:  "Status",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPolicyId()); l < 22 || l > 254 {
		err := KnowledgeQueryConfigValidationError{
			field:  "PolicyId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_KnowledgeQueryConfig_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := KnowledgeQueryConfigValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KnowledgeQueryConfigMultiError(errors)
	}

	return nil
}

// KnowledgeQueryConfigMultiError is an error wrapping multiple validation
// errors returned by KnowledgeQueryConfig.ValidateAll() if the designated
// constraints aren't met.
type KnowledgeQueryConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KnowledgeQueryConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KnowledgeQueryConfigMultiError) AllErrors() []error { return m }

// KnowledgeQueryConfigValidationError is the validation error returned by
// KnowledgeQueryConfig.Validate if the designated constraints aren't met.
type KnowledgeQueryConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KnowledgeQueryConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KnowledgeQueryConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KnowledgeQueryConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KnowledgeQueryConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KnowledgeQueryConfigValidationError) ErrorName() string {
	return "KnowledgeQueryConfigValidationError"
}

// Error satisfies the builtin error interface
func (e KnowledgeQueryConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKnowledgeQueryConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KnowledgeQueryConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KnowledgeQueryConfigValidationError{}

var _KnowledgeQueryConfig_Status_NotInLookup = map[KnowledgeQueryConfig_Status]struct{}{
	0: {},
}

var _KnowledgeQueryConfig_PolicyId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on RegisterCapturePipelineConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterCapturePipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterCapturePipelineConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RegisterCapturePipelineConfigMultiError, or nil if none found.
func (m *RegisterCapturePipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterCapturePipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RegisterCapturePipelineConfig_AppAgentToken_Pattern.MatchString(m.GetAppAgentToken()) {
		err := RegisterCapturePipelineConfigValidationError{
			field:  "AppAgentToken",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_]+?\\\\.[A-Za-z0-9-_]+?\\\\.[A-Za-z0-9-_]+?$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterCapturePipelineConfigMultiError(errors)
	}

	return nil
}

// RegisterCapturePipelineConfigMultiError is an error wrapping multiple
// validation errors returned by RegisterCapturePipelineConfig.ValidateAll()
// if the designated constraints aren't met.
type RegisterCapturePipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterCapturePipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterCapturePipelineConfigMultiError) AllErrors() []error { return m }

// RegisterCapturePipelineConfigValidationError is the validation error
// returned by RegisterCapturePipelineConfig.Validate if the designated
// constraints aren't met.
type RegisterCapturePipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterCapturePipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterCapturePipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterCapturePipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterCapturePipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterCapturePipelineConfigValidationError) ErrorName() string {
	return "RegisterCapturePipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterCapturePipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterCapturePipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterCapturePipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterCapturePipelineConfigValidationError{}

var _RegisterCapturePipelineConfig_AppAgentToken_Pattern = regexp.MustCompile("^[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?\\.[A-Za-z0-9-_]+?$")

// Validate checks the field values on CapturePipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CapturePipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CapturePipelineConfigMultiError, or nil if none found.
func (m *CapturePipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetApiKeyId()) < 1 {
		err := CapturePipelineConfigValidationError{
			field:  "ApiKeyId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetApiKeySecret()) < 1 {
		err := CapturePipelineConfigValidationError{
			field:  "ApiKeySecret",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CapturePipelineConfigMultiError(errors)
	}

	return nil
}

// CapturePipelineConfigMultiError is an error wrapping multiple validation
// errors returned by CapturePipelineConfig.ValidateAll() if the designated
// constraints aren't met.
type CapturePipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineConfigMultiError) AllErrors() []error { return m }

// CapturePipelineConfigValidationError is the validation error returned by
// CapturePipelineConfig.Validate if the designated constraints aren't met.
type CapturePipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineConfigValidationError) ErrorName() string {
	return "CapturePipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineConfigValidationError{}

// Validate checks the field values on RegisterCapturePipelineTopicConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *RegisterCapturePipelineTopicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterCapturePipelineTopicConfig
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// RegisterCapturePipelineTopicConfigMultiError, or nil if none found.
func (m *RegisterCapturePipelineTopicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterCapturePipelineTopicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCapturePipelineId()); l < 22 || l > 254 {
		err := RegisterCapturePipelineTopicConfigValidationError{
			field:  "CapturePipelineId",
			reason: "value length must be between 22 and 254 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterCapturePipelineTopicConfig_CapturePipelineId_Pattern.MatchString(m.GetCapturePipelineId()) {
		err := RegisterCapturePipelineTopicConfigValidationError{
			field:  "CapturePipelineId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9-_:]{22,254}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterCapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterCapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterCapturePipelineTopicConfigValidationError{
				field:  "Script",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterCapturePipelineTopicConfigMultiError(errors)
	}

	return nil
}

// RegisterCapturePipelineTopicConfigMultiError is an error wrapping multiple
// validation errors returned by
// RegisterCapturePipelineTopicConfig.ValidateAll() if the designated
// constraints aren't met.
type RegisterCapturePipelineTopicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterCapturePipelineTopicConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterCapturePipelineTopicConfigMultiError) AllErrors() []error { return m }

// RegisterCapturePipelineTopicConfigValidationError is the validation error
// returned by RegisterCapturePipelineTopicConfig.Validate if the designated
// constraints aren't met.
type RegisterCapturePipelineTopicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterCapturePipelineTopicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterCapturePipelineTopicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterCapturePipelineTopicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterCapturePipelineTopicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterCapturePipelineTopicConfigValidationError) ErrorName() string {
	return "RegisterCapturePipelineTopicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterCapturePipelineTopicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterCapturePipelineTopicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterCapturePipelineTopicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterCapturePipelineTopicConfigValidationError{}

var _RegisterCapturePipelineTopicConfig_CapturePipelineId_Pattern = regexp.MustCompile("^[A-Za-z0-9-_:]{22,254}$")

// Validate checks the field values on CapturePipelineTopicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CapturePipelineTopicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineTopicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CapturePipelineTopicConfigMultiError, or nil if none found.
func (m *CapturePipelineTopicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineTopicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TopicInputName

	// no validation rules for TopicInputEndpoint

	// no validation rules for TopicErrorName

	// no validation rules for TopicSuccessName

	if all {
		switch v := interface{}(m.GetScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CapturePipelineTopicConfigValidationError{
				field:  "Script",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CapturePipelineTopicConfigMultiError(errors)
	}

	return nil
}

// CapturePipelineTopicConfigMultiError is an error wrapping multiple
// validation errors returned by CapturePipelineTopicConfig.ValidateAll() if
// the designated constraints aren't met.
type CapturePipelineTopicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineTopicConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineTopicConfigMultiError) AllErrors() []error { return m }

// CapturePipelineTopicConfigValidationError is the validation error returned
// by CapturePipelineTopicConfig.Validate if the designated constraints aren't met.
type CapturePipelineTopicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineTopicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineTopicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineTopicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineTopicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineTopicConfigValidationError) ErrorName() string {
	return "CapturePipelineTopicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineTopicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineTopicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineTopicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineTopicConfigValidationError{}

// Validate checks the field values on CapturePipelineTopicScriptConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CapturePipelineTopicScriptConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineTopicScriptConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CapturePipelineTopicScriptConfigMultiError, or nil if none found.
func (m *CapturePipelineTopicScriptConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineTopicScriptConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return CapturePipelineTopicScriptConfigMultiError(errors)
	}

	return nil
}

// CapturePipelineTopicScriptConfigMultiError is an error wrapping multiple
// validation errors returned by
// CapturePipelineTopicScriptConfig.ValidateAll() if the designated
// constraints aren't met.
type CapturePipelineTopicScriptConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineTopicScriptConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineTopicScriptConfigMultiError) AllErrors() []error { return m }

// CapturePipelineTopicScriptConfigValidationError is the validation error
// returned by CapturePipelineTopicScriptConfig.Validate if the designated
// constraints aren't met.
type CapturePipelineTopicScriptConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineTopicScriptConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineTopicScriptConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineTopicScriptConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineTopicScriptConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineTopicScriptConfigValidationError) ErrorName() string {
	return "CapturePipelineTopicScriptConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineTopicScriptConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineTopicScriptConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineTopicScriptConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineTopicScriptConfigValidationError{}

// Validate checks the field values on EventSinkConfig_Provider with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Provider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Provider with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfig_ProviderMultiError, or nil if none found.
func (m *EventSinkConfig_Provider) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Provider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofProviderPresent := false
	switch v := m.Provider.(type) {
	case *EventSinkConfig_Provider_Kafka:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProviderPresent = true

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventSinkConfig_Provider_AzureEventGrid:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProviderPresent = true

		if all {
			switch v := interface{}(m.GetAzureEventGrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureEventGrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureEventGrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzureEventGrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "AzureEventGrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventSinkConfig_Provider_AzureServiceBus:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofProviderPresent = true

		if all {
			switch v := interface{}(m.GetAzureServiceBus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureServiceBus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureServiceBus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzureServiceBus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "AzureServiceBus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofProviderPresent {
		err := EventSinkConfig_ProviderValidationError{
			field:  "Provider",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EventSinkConfig_ProviderMultiError(errors)
	}

	return nil
}

// EventSinkConfig_ProviderMultiError is an error wrapping multiple validation
// errors returned by EventSinkConfig_Provider.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_ProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_ProviderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_ProviderMultiError) AllErrors() []error { return m }

// EventSinkConfig_ProviderValidationError is the validation error returned by
// EventSinkConfig_Provider.Validate if the designated constraints aren't met.
type EventSinkConfig_ProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_ProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_ProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_ProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_ProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_ProviderValidationError) ErrorName() string {
	return "EventSinkConfig_ProviderValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_ProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Provider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_ProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_ProviderValidationError{}

// Validate checks the field values on EventSinkConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Route) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfig_RouteMultiError, or nil if none found.
func (m *EventSinkConfig_Route) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Route) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetProviderId()); l < 2 || l > 63 {
		err := EventSinkConfig_RouteValidationError{
			field:  "ProviderId",
			reason: "value length must be between 2 and 63 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EventSinkConfig_Route_ProviderId_Pattern.MatchString(m.GetProviderId()) {
		err := EventSinkConfig_RouteValidationError{
			field:  "ProviderId",
			reason: "value does not match regex pattern \"^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StopProcessing

	oneofFilterPresent := false
	switch v := m.Filter.(type) {
	case *EventSinkConfig_Route_EventType:
		if v == nil {
			err := EventSinkConfig_RouteValidationError{
				field:  "Filter",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofFilterPresent = true

		if utf8.RuneCountInString(m.GetEventType()) < 1 {
			err := EventSinkConfig_RouteValidationError{
				field:  "EventType",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_EventSinkConfig_Route_EventType_Pattern.MatchString(m.GetEventType()) {
			err := EventSinkConfig_RouteValidationError{
				field:  "EventType",
				reason: "value does not match regex pattern \"^[a-zA-Z0-9_*\\\\.]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *EventSinkConfig_Route_ContextKeyValue:
		if v == nil {
			err := EventSinkConfig_RouteValidationError{
				field:  "Filter",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofFilterPresent = true

		if all {
			switch v := interface{}(m.GetContextKeyValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_RouteValidationError{
						field:  "ContextKeyValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_RouteValidationError{
						field:  "ContextKeyValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContextKeyValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_RouteValidationError{
					field:  "ContextKeyValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofFilterPresent {
		err := EventSinkConfig_RouteValidationError{
			field:  "Filter",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EventSinkConfig_RouteMultiError(errors)
	}

	return nil
}

// EventSinkConfig_RouteMultiError is an error wrapping multiple validation
// errors returned by EventSinkConfig_Route.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_RouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_RouteMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_RouteMultiError) AllErrors() []error { return m }

// EventSinkConfig_RouteValidationError is the validation error returned by
// EventSinkConfig_Route.Validate if the designated constraints aren't met.
type EventSinkConfig_RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_RouteValidationError) ErrorName() string {
	return "EventSinkConfig_RouteValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Route.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_RouteValidationError{}

var _EventSinkConfig_Route_ProviderId_Pattern = regexp.MustCompile("^[a-z](?:[-a-z0-9]{0,61}[a-z0-9])$")

var _EventSinkConfig_Route_EventType_Pattern = regexp.MustCompile("^[a-zA-Z0-9_*\\.]+$")

// Validate checks the field values on EventSinkConfig_Route_KeyValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Route_KeyValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Route_KeyValue with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventSinkConfig_Route_KeyValueMultiError, or nil if none found.
func (m *EventSinkConfig_Route_KeyValue) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Route_KeyValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetKey()) < 1 {
		err := EventSinkConfig_Route_KeyValueValidationError{
			field:  "Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_EventSinkConfig_Route_KeyValue_Key_Pattern.MatchString(m.GetKey()) {
		err := EventSinkConfig_Route_KeyValueValidationError{
			field:  "Key",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9*]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetValue()) < 1 {
		err := EventSinkConfig_Route_KeyValueValidationError{
			field:  "Value",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return EventSinkConfig_Route_KeyValueMultiError(errors)
	}

	return nil
}

// EventSinkConfig_Route_KeyValueMultiError is an error wrapping multiple
// validation errors returned by EventSinkConfig_Route_KeyValue.ValidateAll()
// if the designated constraints aren't met.
type EventSinkConfig_Route_KeyValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_Route_KeyValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_Route_KeyValueMultiError) AllErrors() []error { return m }

// EventSinkConfig_Route_KeyValueValidationError is the validation error
// returned by EventSinkConfig_Route_KeyValue.Validate if the designated
// constraints aren't met.
type EventSinkConfig_Route_KeyValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_Route_KeyValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_Route_KeyValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_Route_KeyValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_Route_KeyValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_Route_KeyValueValidationError) ErrorName() string {
	return "EventSinkConfig_Route_KeyValueValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_Route_KeyValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Route_KeyValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_Route_KeyValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_Route_KeyValueValidationError{}

var _EventSinkConfig_Route_KeyValue_Key_Pattern = regexp.MustCompile("^[a-zA-Z0-9*]+$")

// Validate checks the field values on TokenIntrospectConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_JWTMultiError, or nil if none found.
func (m *TokenIntrospectConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetIssuer()); err != nil {
		err = TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Issuer",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetAudience()); l < 1 || l > 150 {
		err := TokenIntrospectConfig_JWTValidationError{
			field:  "Audience",
			reason: "value length must be between 1 and 150 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig_JWT.ValidateAll() if the
// designated constraints aren't met.
type TokenIntrospectConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_JWTMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_JWTMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_JWTValidationError is the validation error returned by
// TokenIntrospectConfig_JWT.Validate if the designated constraints aren't met.
type TokenIntrospectConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_JWTValidationError) ErrorName() string {
	return "TokenIntrospectConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_JWTValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Opaque) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OpaqueMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Opaque) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Opaque) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHint()); l < 1 || l > 50 {
		err := TokenIntrospectConfig_OpaqueValidationError{
			field:  "Hint",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OpaqueMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OpaqueMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Opaque.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OpaqueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OpaqueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OpaqueMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OpaqueValidationError is the validation error returned
// by TokenIntrospectConfig_Opaque.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OpaqueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OpaqueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OpaqueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OpaqueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OpaqueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OpaqueValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OpaqueValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OpaqueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Opaque.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OpaqueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OpaqueValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Offline with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OfflineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPublicJwks()) > 10 {
		err := TokenIntrospectConfig_OfflineValidationError{
			field:  "PublicJwks",
			reason: "value must contain no more than 10 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPublicJwks() {
		_, _ = idx, item

		if l := len(item); l < 96 || l > 8192 {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value length must be between 96 and 8192 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasPrefix(item, []uint8{0x7B}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have prefix \"\\x7B\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !bytes.HasSuffix(item, []uint8{0x7D}) {
			err := TokenIntrospectConfig_OfflineValidationError{
				field:  fmt.Sprintf("PublicJwks[%v]", idx),
				reason: "value does not have suffix \"\\x7D\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Offline.ValidateAll()
// if the designated constraints aren't met.
type TokenIntrospectConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OfflineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OfflineValidationError is the validation error
// returned by TokenIntrospectConfig_Offline.Validate if the designated
// constraints aren't met.
type TokenIntrospectConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OfflineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OfflineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Online) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OnlineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Online) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Online) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserinfoEndpoint() != "" {

		if uri, err := url.Parse(m.GetUserinfoEndpoint()); err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be a valid URI",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else if !uri.IsAbs() {
			err := TokenIntrospectConfig_OnlineValidationError{
				field:  "UserinfoEndpoint",
				reason: "value must be absolute",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if d := m.GetCacheTtl(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = TokenIntrospectConfig_OnlineValidationError{
				field:  "CacheTtl",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(3600*time.Second + 0*time.Nanosecond)

			if dur > lte {
				err := TokenIntrospectConfig_OnlineValidationError{
					field:  "CacheTtl",
					reason: "value must be less than or equal to 1h0m0s",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OnlineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OnlineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Online.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OnlineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OnlineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OnlineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OnlineValidationError is the validation error returned
// by TokenIntrospectConfig_Online.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OnlineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OnlineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OnlineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OnlineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OnlineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OnlineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OnlineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OnlineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Online.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OnlineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OnlineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_ClaimMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetSelector()); l < 1 || l > 200 {
		err := TokenIntrospectConfig_ClaimValidationError{
			field:  "Selector",
			reason: "value length must be between 1 and 200 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_ClaimMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Claim.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_ClaimMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_ClaimValidationError is the validation error returned
// by TokenIntrospectConfig_Claim.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_ClaimValidationError) ErrorName() string {
	return "TokenIntrospectConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_ClaimValidationError{}

// Validate checks the field values on ConsentDataPoint_Return with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentDataPoint_Return) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentDataPoint_Return with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentDataPoint_ReturnMultiError, or nil if none found.
func (m *ConsentDataPoint_Return) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentDataPoint_Return) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetVariable()) > 32 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Variable",
			reason: "value length must be at most 32 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetProperties()) > 50 {
		err := ConsentDataPoint_ReturnValidationError{
			field:  "Properties",
			reason: "value must contain no more than 50 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConsentDataPoint_ReturnMultiError(errors)
	}

	return nil
}

// ConsentDataPoint_ReturnMultiError is an error wrapping multiple validation
// errors returned by ConsentDataPoint_Return.ValidateAll() if the designated
// constraints aren't met.
type ConsentDataPoint_ReturnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentDataPoint_ReturnMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentDataPoint_ReturnMultiError) AllErrors() []error { return m }

// ConsentDataPoint_ReturnValidationError is the validation error returned by
// ConsentDataPoint_Return.Validate if the designated constraints aren't met.
type ConsentDataPoint_ReturnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentDataPoint_ReturnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentDataPoint_ReturnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentDataPoint_ReturnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentDataPoint_ReturnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentDataPoint_ReturnValidationError) ErrorName() string {
	return "ConsentDataPoint_ReturnValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentDataPoint_ReturnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentDataPoint_Return.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentDataPoint_ReturnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentDataPoint_ReturnValidationError{}

// Validate checks the field values on EntityMatchingPipelineConfig_NodeFilter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *EntityMatchingPipelineConfig_NodeFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EntityMatchingPipelineConfig_NodeFilter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// EntityMatchingPipelineConfig_NodeFilterMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig_NodeFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig_NodeFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSourceNodeTypes()) < 1 {
		err := EntityMatchingPipelineConfig_NodeFilterValidationError{
			field:  "SourceNodeTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_EntityMatchingPipelineConfig_NodeFilter_SourceNodeTypes_Unique := make(map[string]struct{}, len(m.GetSourceNodeTypes()))

	for idx, item := range m.GetSourceNodeTypes() {
		_, _ = idx, item

		if _, exists := _EntityMatchingPipelineConfig_NodeFilter_SourceNodeTypes_Unique[item]; exists {
			err := EntityMatchingPipelineConfig_NodeFilterValidationError{
				field:  fmt.Sprintf("SourceNodeTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_EntityMatchingPipelineConfig_NodeFilter_SourceNodeTypes_Unique[item] = struct{}{}
		}

		// no validation rules for SourceNodeTypes[idx]
	}

	if len(m.GetTargetNodeTypes()) < 1 {
		err := EntityMatchingPipelineConfig_NodeFilterValidationError{
			field:  "TargetNodeTypes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_EntityMatchingPipelineConfig_NodeFilter_TargetNodeTypes_Unique := make(map[string]struct{}, len(m.GetTargetNodeTypes()))

	for idx, item := range m.GetTargetNodeTypes() {
		_, _ = idx, item

		if _, exists := _EntityMatchingPipelineConfig_NodeFilter_TargetNodeTypes_Unique[item]; exists {
			err := EntityMatchingPipelineConfig_NodeFilterValidationError{
				field:  fmt.Sprintf("TargetNodeTypes[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_EntityMatchingPipelineConfig_NodeFilter_TargetNodeTypes_Unique[item] = struct{}{}
		}

		// no validation rules for TargetNodeTypes[idx]
	}

	if len(errors) > 0 {
		return EntityMatchingPipelineConfig_NodeFilterMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfig_NodeFilterMultiError is an error wrapping
// multiple validation errors returned by
// EntityMatchingPipelineConfig_NodeFilter.ValidateAll() if the designated
// constraints aren't met.
type EntityMatchingPipelineConfig_NodeFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfig_NodeFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfig_NodeFilterMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfig_NodeFilterValidationError is the validation
// error returned by EntityMatchingPipelineConfig_NodeFilter.Validate if the
// designated constraints aren't met.
type EntityMatchingPipelineConfig_NodeFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfig_NodeFilterValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig_NodeFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfig_NodeFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfig_NodeFilterValidationError{}

// Validate checks the field values on
// EntityMatchingPipelineConfig_PropertyMapping with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EntityMatchingPipelineConfig_PropertyMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EntityMatchingPipelineConfig_PropertyMapping with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// EntityMatchingPipelineConfig_PropertyMappingMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig_PropertyMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig_PropertyMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceNodeType

	// no validation rules for SourceNodeProperty

	// no validation rules for TargetNodeType

	// no validation rules for TargetNodeProperty

	if m.GetSimilarityScoreCutoff() != 0 {

		if val := m.GetSimilarityScoreCutoff(); val < 0 || val > 1 {
			err := EntityMatchingPipelineConfig_PropertyMappingValidationError{
				field:  "SimilarityScoreCutoff",
				reason: "value must be inside range [0, 1]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return EntityMatchingPipelineConfig_PropertyMappingMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfig_PropertyMappingMultiError is an error wrapping
// multiple validation errors returned by
// EntityMatchingPipelineConfig_PropertyMapping.ValidateAll() if the
// designated constraints aren't met.
type EntityMatchingPipelineConfig_PropertyMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfig_PropertyMappingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfig_PropertyMappingMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfig_PropertyMappingValidationError is the
// validation error returned by
// EntityMatchingPipelineConfig_PropertyMapping.Validate if the designated
// constraints aren't met.
type EntityMatchingPipelineConfig_PropertyMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfig_PropertyMappingValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig_PropertyMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfig_PropertyMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfig_PropertyMappingValidationError{}

// Validate checks the field values on ExternalDataResolverConfig_Header with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ExternalDataResolverConfig_Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExternalDataResolverConfig_Header
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ExternalDataResolverConfig_HeaderMultiError, or nil if none found.
func (m *ExternalDataResolverConfig_Header) ValidateAll() error {
	return m.validate(true)
}

func (m *ExternalDataResolverConfig_Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValues()) < 1 {
		err := ExternalDataResolverConfig_HeaderValidationError{
			field:  "Values",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if l := utf8.RuneCountInString(item); l < 1 || l > 255 {
			err := ExternalDataResolverConfig_HeaderValidationError{
				field:  fmt.Sprintf("Values[%v]", idx),
				reason: "value length must be between 1 and 255 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ExternalDataResolverConfig_HeaderMultiError(errors)
	}

	return nil
}

// ExternalDataResolverConfig_HeaderMultiError is an error wrapping multiple
// validation errors returned by
// ExternalDataResolverConfig_Header.ValidateAll() if the designated
// constraints aren't met.
type ExternalDataResolverConfig_HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExternalDataResolverConfig_HeaderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExternalDataResolverConfig_HeaderMultiError) AllErrors() []error { return m }

// ExternalDataResolverConfig_HeaderValidationError is the validation error
// returned by ExternalDataResolverConfig_Header.Validate if the designated
// constraints aren't met.
type ExternalDataResolverConfig_HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExternalDataResolverConfig_HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExternalDataResolverConfig_HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExternalDataResolverConfig_HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExternalDataResolverConfig_HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExternalDataResolverConfig_HeaderValidationError) ErrorName() string {
	return "ExternalDataResolverConfig_HeaderValidationError"
}

// Error satisfies the builtin error interface
func (e ExternalDataResolverConfig_HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExternalDataResolverConfig_Header.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExternalDataResolverConfig_HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExternalDataResolverConfig_HeaderValidationError{}

// Validate checks the field values on
// RegisterCapturePipelineTopicConfig_Script with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterCapturePipelineTopicConfig_Script) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// RegisterCapturePipelineTopicConfig_Script with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// RegisterCapturePipelineTopicConfig_ScriptMultiError, or nil if none found.
func (m *RegisterCapturePipelineTopicConfig_Script) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterCapturePipelineTopicConfig_Script) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return RegisterCapturePipelineTopicConfig_ScriptMultiError(errors)
	}

	return nil
}

// RegisterCapturePipelineTopicConfig_ScriptMultiError is an error wrapping
// multiple validation errors returned by
// RegisterCapturePipelineTopicConfig_Script.ValidateAll() if the designated
// constraints aren't met.
type RegisterCapturePipelineTopicConfig_ScriptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterCapturePipelineTopicConfig_ScriptMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterCapturePipelineTopicConfig_ScriptMultiError) AllErrors() []error { return m }

// RegisterCapturePipelineTopicConfig_ScriptValidationError is the validation
// error returned by RegisterCapturePipelineTopicConfig_Script.Validate if the
// designated constraints aren't met.
type RegisterCapturePipelineTopicConfig_ScriptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) ErrorName() string {
	return "RegisterCapturePipelineTopicConfig_ScriptValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterCapturePipelineTopicConfig_ScriptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterCapturePipelineTopicConfig_Script.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterCapturePipelineTopicConfig_ScriptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterCapturePipelineTopicConfig_ScriptValidationError{}
