// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/auditsink/v1beta1/config.proto

package auditsinkv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ContainersPath with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainersPath) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainersPath with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainersPathMultiError,
// or nil if none found.
func (m *ContainersPath) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainersPath) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomerId

	// no validation rules for ApplicationSpaceId

	if len(errors) > 0 {
		return ContainersPathMultiError(errors)
	}

	return nil
}

// ContainersPathMultiError is an error wrapping multiple validation errors
// returned by ContainersPath.ValidateAll() if the designated constraints
// aren't met.
type ContainersPathMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainersPathMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainersPathMultiError) AllErrors() []error { return m }

// ContainersPathValidationError is the validation error returned by
// ContainersPath.Validate if the designated constraints aren't met.
type ContainersPathValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainersPathValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainersPathValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainersPathValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainersPathValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainersPathValidationError) ErrorName() string { return "ContainersPathValidationError" }

// Error satisfies the builtin error interface
func (e ContainersPathValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainersPath.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainersPathValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainersPathValidationError{}

// Validate checks the field values on CreatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatedConfigMultiError, or
// nil if none found.
func (m *CreatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatedConfigMultiError(errors)
	}

	return nil
}

// CreatedConfigMultiError is an error wrapping multiple validation errors
// returned by CreatedConfig.ValidateAll() if the designated constraints
// aren't met.
type CreatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfigMultiError) AllErrors() []error { return m }

// CreatedConfigValidationError is the validation error returned by
// CreatedConfig.Validate if the designated constraints aren't met.
type CreatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfigValidationError) ErrorName() string { return "CreatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e CreatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfigValidationError{}

// Validate checks the field values on ReadConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadConfigMultiError, or
// nil if none found.
func (m *ReadConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	switch v := m.Identifier.(type) {
	case *ReadConfig_Id:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Id
	case *ReadConfig_Name:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadConfigValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReadConfigMultiError(errors)
	}

	return nil
}

// ReadConfigMultiError is an error wrapping multiple validation errors
// returned by ReadConfig.ValidateAll() if the designated constraints aren't met.
type ReadConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfigMultiError) AllErrors() []error { return m }

// ReadConfigValidationError is the validation error returned by
// ReadConfig.Validate if the designated constraints aren't met.
type ReadConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfigValidationError) ErrorName() string { return "ReadConfigValidationError" }

// Error satisfies the builtin error interface
func (e ReadConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfigValidationError{}

// Validate checks the field values on UpdatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatedConfigMultiError, or
// nil if none found.
func (m *UpdatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "Before",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "After",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatedConfigMultiError(errors)
	}

	return nil
}

// UpdatedConfigMultiError is an error wrapping multiple validation errors
// returned by UpdatedConfig.ValidateAll() if the designated constraints
// aren't met.
type UpdatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatedConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatedConfigMultiError) AllErrors() []error { return m }

// UpdatedConfigValidationError is the validation error returned by
// UpdatedConfig.Validate if the designated constraints aren't met.
type UpdatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatedConfigValidationError) ErrorName() string { return "UpdatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e UpdatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatedConfigValidationError{}

// Validate checks the field values on DeletedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletedConfigMultiError, or
// nil if none found.
func (m *DeletedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeletedConfigMultiError(errors)
	}

	return nil
}

// DeletedConfigMultiError is an error wrapping multiple validation errors
// returned by DeletedConfig.ValidateAll() if the designated constraints
// aren't met.
type DeletedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletedConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletedConfigMultiError) AllErrors() []error { return m }

// DeletedConfigValidationError is the validation error returned by
// DeletedConfig.Validate if the designated constraints aren't met.
type DeletedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletedConfigValidationError) ErrorName() string { return "DeletedConfigValidationError" }

// Error satisfies the builtin error interface
func (e DeletedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletedConfigValidationError{}

// Validate checks the field values on ConfigDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigDetailMultiError, or
// nil if none found.
func (m *ConfigDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	switch v := m.Configuration.(type) {
	case *ConfigDetail_ApplicationSpace:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationSpace()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationSpace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationSpace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationSpace()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationSpace",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ApplicationAgent:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationAgent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationAgent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationAgent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ApplicationAgentCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationAgentCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationAgentCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationAgentCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ServiceAccountCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceAccountCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceAccountCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ServiceAccountCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_EventSinkConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEventSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EventSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EventSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEventSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "EventSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_TokenIntrospectConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenIntrospectConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenIntrospectConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "TokenIntrospectConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ExternalDataResolverConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExternalDataResolverConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ExternalDataResolverConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ExternalDataResolverConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExternalDataResolverConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ExternalDataResolverConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_TrustScoreProfileConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrustScoreProfileConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TrustScoreProfileConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TrustScoreProfileConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrustScoreProfileConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "TrustScoreProfileConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ConsentConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_IngestPipelineConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIngestPipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIngestPipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "IngestPipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_EntityMatchingPipelineConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEntityMatchingPipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EntityMatchingPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EntityMatchingPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEntityMatchingPipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "EntityMatchingPipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_KnowledgeQueryConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKnowledgeQueryConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "KnowledgeQueryConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "KnowledgeQueryConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKnowledgeQueryConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "KnowledgeQueryConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_CapturePipelineConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCapturePipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CapturePipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CapturePipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCapturePipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "CapturePipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_CapturePipelineTopicConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCapturePipelineTopicConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CapturePipelineTopicConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CapturePipelineTopicConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCapturePipelineTopicConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "CapturePipelineTopicConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConfigDetailMultiError(errors)
	}

	return nil
}

// ConfigDetailMultiError is an error wrapping multiple validation errors
// returned by ConfigDetail.ValidateAll() if the designated constraints aren't met.
type ConfigDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigDetailMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigDetailMultiError) AllErrors() []error { return m }

// ConfigDetailValidationError is the validation error returned by
// ConfigDetail.Validate if the designated constraints aren't met.
type ConfigDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigDetailValidationError) ErrorName() string { return "ConfigDetailValidationError" }

// Error satisfies the builtin error interface
func (e ConfigDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigDetailValidationError{}

// Validate checks the field values on DBConnection with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DBConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DBConnection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DBConnectionMultiError, or
// nil if none found.
func (m *DBConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *DBConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Name

	if len(errors) > 0 {
		return DBConnectionMultiError(errors)
	}

	return nil
}

// DBConnectionMultiError is an error wrapping multiple validation errors
// returned by DBConnection.ValidateAll() if the designated constraints aren't met.
type DBConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DBConnectionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DBConnectionMultiError) AllErrors() []error { return m }

// DBConnectionValidationError is the validation error returned by
// DBConnection.Validate if the designated constraints aren't met.
type DBConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DBConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DBConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DBConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DBConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DBConnectionValidationError) ErrorName() string { return "DBConnectionValidationError" }

// Error satisfies the builtin error interface
func (e DBConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDBConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DBConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DBConnectionValidationError{}

// Validate checks the field values on ApplicationSpaceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpaceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpaceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceConfigMultiError, or nil if none found.
func (m *ApplicationSpaceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpaceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for IkgSize

	// no validation rules for ReplicaRegion

	if all {
		switch v := interface{}(m.GetDbConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceConfigValidationError{
					field:  "DbConnection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceConfigValidationError{
					field:  "DbConnection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDbConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceConfigValidationError{
				field:  "DbConnection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationSpaceConfigMultiError(errors)
	}

	return nil
}

// ApplicationSpaceConfigMultiError is an error wrapping multiple validation
// errors returned by ApplicationSpaceConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationSpaceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceConfigMultiError) AllErrors() []error { return m }

// ApplicationSpaceConfigValidationError is the validation error returned by
// ApplicationSpaceConfig.Validate if the designated constraints aren't met.
type ApplicationSpaceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceConfigValidationError) ErrorName() string {
	return "ApplicationSpaceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationSpaceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpaceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceConfigValidationError{}

// Validate checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplicationAgentCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialConfigMultiError, or nil if none found.
func (m *ApplicationAgentCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialConfigMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by
// ApplicationAgentCredentialConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialConfigMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialConfigValidationError is the validation error
// returned by ApplicationAgentCredentialConfig.Validate if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialConfigValidationError) ErrorName() string {
	return "ApplicationAgentCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialConfigValidationError{}

// Validate checks the field values on ApplicationAgentConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationAgentConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationAgentConfigMultiError, or nil if none found.
func (m *ApplicationAgentConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplicationAgentConfigMultiError(errors)
	}

	return nil
}

// ApplicationAgentConfigMultiError is an error wrapping multiple validation
// errors returned by ApplicationAgentConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationAgentConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentConfigMultiError) AllErrors() []error { return m }

// ApplicationAgentConfigValidationError is the validation error returned by
// ApplicationAgentConfig.Validate if the designated constraints aren't met.
type ApplicationAgentConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentConfigValidationError) ErrorName() string {
	return "ApplicationAgentConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentConfigValidationError{}

// Validate checks the field values on ServiceAccountCredentialConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialConfigMultiError, or nil if none found.
func (m *ServiceAccountCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialConfigMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by ServiceAccountCredentialConfig.ValidateAll()
// if the designated constraints aren't met.
type ServiceAccountCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialConfigMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialConfigValidationError is the validation error
// returned by ServiceAccountCredentialConfig.Validate if the designated
// constraints aren't met.
type ServiceAccountCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialConfigValidationError) ErrorName() string {
	return "ServiceAccountCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialConfigValidationError{}

// Validate checks the field values on EventSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfigMultiError, or nil if none found.
func (m *EventSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetProviders()))
		i := 0
		for key := range m.GetProviders() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProviders()[key]
			_ = val

			// no validation rules for Providers[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EventSinkConfigValidationError{
							field:  fmt.Sprintf("Providers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EventSinkConfigValidationError{
							field:  fmt.Sprintf("Providers[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EventSinkConfigValidationError{
						field:  fmt.Sprintf("Providers[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfigValidationError{
						field:  fmt.Sprintf("Routes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfigValidationError{
					field:  fmt.Sprintf("Routes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EventSinkConfigMultiError(errors)
	}

	return nil
}

// EventSinkConfigMultiError is an error wrapping multiple validation errors
// returned by EventSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type EventSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfigMultiError) AllErrors() []error { return m }

// EventSinkConfigValidationError is the validation error returned by
// EventSinkConfig.Validate if the designated constraints aren't met.
type EventSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfigValidationError) ErrorName() string { return "EventSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e EventSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfigValidationError{}

// Validate checks the field values on ExternalDataResolverConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExternalDataResolverConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExternalDataResolverConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExternalDataResolverConfigMultiError, or nil if none found.
func (m *ExternalDataResolverConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ExternalDataResolverConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Method

	// no validation rules for Headers

	// no validation rules for RequestType

	// no validation rules for RequestPayload

	// no validation rules for ResponseType

	// no validation rules for ResponseSelector

	if len(errors) > 0 {
		return ExternalDataResolverConfigMultiError(errors)
	}

	return nil
}

// ExternalDataResolverConfigMultiError is an error wrapping multiple
// validation errors returned by ExternalDataResolverConfig.ValidateAll() if
// the designated constraints aren't met.
type ExternalDataResolverConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExternalDataResolverConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExternalDataResolverConfigMultiError) AllErrors() []error { return m }

// ExternalDataResolverConfigValidationError is the validation error returned
// by ExternalDataResolverConfig.Validate if the designated constraints aren't met.
type ExternalDataResolverConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExternalDataResolverConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExternalDataResolverConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExternalDataResolverConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExternalDataResolverConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExternalDataResolverConfigValidationError) ErrorName() string {
	return "ExternalDataResolverConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ExternalDataResolverConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExternalDataResolverConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExternalDataResolverConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExternalDataResolverConfigValidationError{}

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Policy

	// no validation rules for Status

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

// Validate checks the field values on AssignConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssignConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssignConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssignConfigPermissionsMultiError, or nil if none found.
func (m *AssignConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *AssignConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return AssignConfigPermissionsMultiError(errors)
	}

	return nil
}

// AssignConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by AssignConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type AssignConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssignConfigPermissionsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssignConfigPermissionsMultiError) AllErrors() []error { return m }

// AssignConfigPermissionsValidationError is the validation error returned by
// AssignConfigPermissions.Validate if the designated constraints aren't met.
type AssignConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssignConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssignConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssignConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssignConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssignConfigPermissionsValidationError) ErrorName() string {
	return "AssignConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e AssignConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssignConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssignConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssignConfigPermissionsValidationError{}

// Validate checks the field values on RevokeConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeConfigPermissionsMultiError, or nil if none found.
func (m *RevokeConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return RevokeConfigPermissionsMultiError(errors)
	}

	return nil
}

// RevokeConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by RevokeConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type RevokeConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeConfigPermissionsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeConfigPermissionsMultiError) AllErrors() []error { return m }

// RevokeConfigPermissionsValidationError is the validation error returned by
// RevokeConfigPermissions.Validate if the designated constraints aren't met.
type RevokeConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeConfigPermissionsValidationError) ErrorName() string {
	return "RevokeConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeConfigPermissionsValidationError{}

// Validate checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfigMultiError, or nil if none found.
func (m *TokenIntrospectConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			// no validation rules for ClaimsMapping[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenIntrospectConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for IkgNodeType

	// no validation rules for PerformUpsert

	switch v := m.TokenMatcher.(type) {
	case *TokenIntrospectConfig_Jwt:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Opaque_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpaque()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Opaque",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpaque()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Opaque",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Validation.(type) {
	case *TokenIntrospectConfig_Offline_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenIntrospectConfig_Online_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Online",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Online",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TokenIntrospectConfigMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfigMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfigMultiError) AllErrors() []error { return m }

// TokenIntrospectConfigValidationError is the validation error returned by
// TokenIntrospectConfig.Validate if the designated constraints aren't met.
type TokenIntrospectConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfigValidationError) ErrorName() string {
	return "TokenIntrospectConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfigValidationError{}

// Validate checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsentConfiguration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsentConfiguration with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsentConfigurationMultiError, or nil if none found.
func (m *ConsentConfiguration) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsentConfiguration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Purpose

	// no validation rules for ApplicationId

	// no validation rules for ValidityPeriod

	// no validation rules for RevokeAfterUse

	// no validation rules for TokenStatus

	if len(errors) > 0 {
		return ConsentConfigurationMultiError(errors)
	}

	return nil
}

// ConsentConfigurationMultiError is an error wrapping multiple validation
// errors returned by ConsentConfiguration.ValidateAll() if the designated
// constraints aren't met.
type ConsentConfigurationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsentConfigurationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsentConfigurationMultiError) AllErrors() []error { return m }

// ConsentConfigurationValidationError is the validation error returned by
// ConsentConfiguration.Validate if the designated constraints aren't met.
type ConsentConfigurationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsentConfigurationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsentConfigurationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsentConfigurationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsentConfigurationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsentConfigurationValidationError) ErrorName() string {
	return "ConsentConfigurationValidationError"
}

// Error satisfies the builtin error interface
func (e ConsentConfigurationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsentConfiguration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsentConfigurationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsentConfigurationValidationError{}

// Validate checks the field values on IngestPipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IngestPipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IngestPipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IngestPipelineConfigMultiError, or nil if none found.
func (m *IngestPipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *IngestPipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppAgentToken

	if len(errors) > 0 {
		return IngestPipelineConfigMultiError(errors)
	}

	return nil
}

// IngestPipelineConfigMultiError is an error wrapping multiple validation
// errors returned by IngestPipelineConfig.ValidateAll() if the designated
// constraints aren't met.
type IngestPipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngestPipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngestPipelineConfigMultiError) AllErrors() []error { return m }

// IngestPipelineConfigValidationError is the validation error returned by
// IngestPipelineConfig.Validate if the designated constraints aren't met.
type IngestPipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngestPipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngestPipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngestPipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngestPipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngestPipelineConfigValidationError) ErrorName() string {
	return "IngestPipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e IngestPipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngestPipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngestPipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngestPipelineConfigValidationError{}

// Validate checks the field values on EntityMatchingPipelineConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EntityMatchingPipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntityMatchingPipelineConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntityMatchingPipelineConfigMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "NodeFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "NodeFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "NodeFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SimilarityScoreCutoff

	// no validation rules for PropertyMappingStatus

	if all {
		switch v := interface{}(m.GetPropertyMappingMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "PropertyMappingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "PropertyMappingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPropertyMappingMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "PropertyMappingMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EntityMatchingStatus

	if all {
		switch v := interface{}(m.GetEntityMatchingMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "EntityMatchingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "EntityMatchingMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntityMatchingMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "EntityMatchingMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPropertyMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntityMatchingPipelineConfigValidationError{
						field:  fmt.Sprintf("PropertyMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntityMatchingPipelineConfigValidationError{
						field:  fmt.Sprintf("PropertyMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntityMatchingPipelineConfigValidationError{
					field:  fmt.Sprintf("PropertyMappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RerunInterval

	if all {
		switch v := interface{}(m.GetLastRunTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "LastRunTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "LastRunTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastRunTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "LastRunTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportUrl()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportUrl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportUrl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportUrl()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "ReportUrl",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityMatchingPipelineConfigValidationError{
					field:  "ReportType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityMatchingPipelineConfigValidationError{
				field:  "ReportType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EntityMatchingPipelineConfigMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfigMultiError is an error wrapping multiple
// validation errors returned by EntityMatchingPipelineConfig.ValidateAll() if
// the designated constraints aren't met.
type EntityMatchingPipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfigMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfigValidationError is the validation error returned
// by EntityMatchingPipelineConfig.Validate if the designated constraints
// aren't met.
type EntityMatchingPipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfigValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfigValidationError{}

// Validate checks the field values on TrustScoreDimension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrustScoreDimension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrustScoreDimension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrustScoreDimensionMultiError, or nil if none found.
func (m *TrustScoreDimension) ValidateAll() error {
	return m.validate(true)
}

func (m *TrustScoreDimension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Weight

	if len(errors) > 0 {
		return TrustScoreDimensionMultiError(errors)
	}

	return nil
}

// TrustScoreDimensionMultiError is an error wrapping multiple validation
// errors returned by TrustScoreDimension.ValidateAll() if the designated
// constraints aren't met.
type TrustScoreDimensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrustScoreDimensionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrustScoreDimensionMultiError) AllErrors() []error { return m }

// TrustScoreDimensionValidationError is the validation error returned by
// TrustScoreDimension.Validate if the designated constraints aren't met.
type TrustScoreDimensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrustScoreDimensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrustScoreDimensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrustScoreDimensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrustScoreDimensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrustScoreDimensionValidationError) ErrorName() string {
	return "TrustScoreDimensionValidationError"
}

// Error satisfies the builtin error interface
func (e TrustScoreDimensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrustScoreDimension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrustScoreDimensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrustScoreDimensionValidationError{}

// Validate checks the field values on TrustScoreProfileConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TrustScoreProfileConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrustScoreProfileConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrustScoreProfileConfigMultiError, or nil if none found.
func (m *TrustScoreProfileConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TrustScoreProfileConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeClassification

	for idx, item := range m.GetDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrustScoreProfileConfigValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrustScoreProfileConfigValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrustScoreProfileConfigValidationError{
					field:  fmt.Sprintf("Dimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Schedule

	if len(errors) > 0 {
		return TrustScoreProfileConfigMultiError(errors)
	}

	return nil
}

// TrustScoreProfileConfigMultiError is an error wrapping multiple validation
// errors returned by TrustScoreProfileConfig.ValidateAll() if the designated
// constraints aren't met.
type TrustScoreProfileConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrustScoreProfileConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrustScoreProfileConfigMultiError) AllErrors() []error { return m }

// TrustScoreProfileConfigValidationError is the validation error returned by
// TrustScoreProfileConfig.Validate if the designated constraints aren't met.
type TrustScoreProfileConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrustScoreProfileConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrustScoreProfileConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrustScoreProfileConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrustScoreProfileConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrustScoreProfileConfigValidationError) ErrorName() string {
	return "TrustScoreProfileConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TrustScoreProfileConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrustScoreProfileConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrustScoreProfileConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrustScoreProfileConfigValidationError{}

// Validate checks the field values on KnowledgeQueryConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KnowledgeQueryConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KnowledgeQueryConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KnowledgeQueryConfigMultiError, or nil if none found.
func (m *KnowledgeQueryConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *KnowledgeQueryConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Query

	// no validation rules for Status

	// no validation rules for PolicyId

	if len(errors) > 0 {
		return KnowledgeQueryConfigMultiError(errors)
	}

	return nil
}

// KnowledgeQueryConfigMultiError is an error wrapping multiple validation
// errors returned by KnowledgeQueryConfig.ValidateAll() if the designated
// constraints aren't met.
type KnowledgeQueryConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KnowledgeQueryConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KnowledgeQueryConfigMultiError) AllErrors() []error { return m }

// KnowledgeQueryConfigValidationError is the validation error returned by
// KnowledgeQueryConfig.Validate if the designated constraints aren't met.
type KnowledgeQueryConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KnowledgeQueryConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KnowledgeQueryConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KnowledgeQueryConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KnowledgeQueryConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KnowledgeQueryConfigValidationError) ErrorName() string {
	return "KnowledgeQueryConfigValidationError"
}

// Error satisfies the builtin error interface
func (e KnowledgeQueryConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKnowledgeQueryConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KnowledgeQueryConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KnowledgeQueryConfigValidationError{}

// Validate checks the field values on CapturePipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CapturePipelineConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CapturePipelineConfigMultiError, or nil if none found.
func (m *CapturePipelineConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppAgentToken

	if len(errors) > 0 {
		return CapturePipelineConfigMultiError(errors)
	}

	return nil
}

// CapturePipelineConfigMultiError is an error wrapping multiple validation
// errors returned by CapturePipelineConfig.ValidateAll() if the designated
// constraints aren't met.
type CapturePipelineConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineConfigMultiError) AllErrors() []error { return m }

// CapturePipelineConfigValidationError is the validation error returned by
// CapturePipelineConfig.Validate if the designated constraints aren't met.
type CapturePipelineConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineConfigValidationError) ErrorName() string {
	return "CapturePipelineConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineConfigValidationError{}

// Validate checks the field values on CapturePipelineTopicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CapturePipelineTopicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineTopicConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CapturePipelineTopicConfigMultiError, or nil if none found.
func (m *CapturePipelineTopicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineTopicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CapturePipelineId

	if all {
		switch v := interface{}(m.GetScript()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CapturePipelineTopicConfigValidationError{
					field:  "Script",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScript()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CapturePipelineTopicConfigValidationError{
				field:  "Script",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CapturePipelineTopicConfigMultiError(errors)
	}

	return nil
}

// CapturePipelineTopicConfigMultiError is an error wrapping multiple
// validation errors returned by CapturePipelineTopicConfig.ValidateAll() if
// the designated constraints aren't met.
type CapturePipelineTopicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineTopicConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineTopicConfigMultiError) AllErrors() []error { return m }

// CapturePipelineTopicConfigValidationError is the validation error returned
// by CapturePipelineTopicConfig.Validate if the designated constraints aren't met.
type CapturePipelineTopicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineTopicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineTopicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineTopicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineTopicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineTopicConfigValidationError) ErrorName() string {
	return "CapturePipelineTopicConfigValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineTopicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineTopicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineTopicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineTopicConfigValidationError{}

// Validate checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig_Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatedConfig_LocationMultiError, or nil if none found.
func (m *CreatedConfig_Location) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig_Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if len(errors) > 0 {
		return CreatedConfig_LocationMultiError(errors)
	}

	return nil
}

// CreatedConfig_LocationMultiError is an error wrapping multiple validation
// errors returned by CreatedConfig_Location.ValidateAll() if the designated
// constraints aren't met.
type CreatedConfig_LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfig_LocationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfig_LocationMultiError) AllErrors() []error { return m }

// CreatedConfig_LocationValidationError is the validation error returned by
// CreatedConfig_Location.Validate if the designated constraints aren't met.
type CreatedConfig_LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfig_LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfig_LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfig_LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfig_LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfig_LocationValidationError) ErrorName() string {
	return "CreatedConfig_LocationValidationError"
}

// Error satisfies the builtin error interface
func (e CreatedConfig_LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig_Location.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfig_LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfig_LocationValidationError{}

// Validate checks the field values on ReadConfig_NameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadConfig_NameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig_NameIdentifier with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadConfig_NameIdentifierMultiError, or nil if none found.
func (m *ReadConfig_NameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig_NameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LocationId

	// no validation rules for Name

	if m.LocationType != nil {
		// no validation rules for LocationType
	}

	if len(errors) > 0 {
		return ReadConfig_NameIdentifierMultiError(errors)
	}

	return nil
}

// ReadConfig_NameIdentifierMultiError is an error wrapping multiple validation
// errors returned by ReadConfig_NameIdentifier.ValidateAll() if the
// designated constraints aren't met.
type ReadConfig_NameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfig_NameIdentifierMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfig_NameIdentifierMultiError) AllErrors() []error { return m }

// ReadConfig_NameIdentifierValidationError is the validation error returned by
// ReadConfig_NameIdentifier.Validate if the designated constraints aren't met.
type ReadConfig_NameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfig_NameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfig_NameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfig_NameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfig_NameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfig_NameIdentifierValidationError) ErrorName() string {
	return "ReadConfig_NameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e ReadConfig_NameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig_NameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfig_NameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfig_NameIdentifierValidationError{}

// Validate checks the field values on EventSinkConfig_KafkaSinkConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_KafkaSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_KafkaSinkConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventSinkConfig_KafkaSinkConfigMultiError, or nil if none found.
func (m *EventSinkConfig_KafkaSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_KafkaSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Topic

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return EventSinkConfig_KafkaSinkConfigMultiError(errors)
	}

	return nil
}

// EventSinkConfig_KafkaSinkConfigMultiError is an error wrapping multiple
// validation errors returned by EventSinkConfig_KafkaSinkConfig.ValidateAll()
// if the designated constraints aren't met.
type EventSinkConfig_KafkaSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_KafkaSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_KafkaSinkConfigMultiError) AllErrors() []error { return m }

// EventSinkConfig_KafkaSinkConfigValidationError is the validation error
// returned by EventSinkConfig_KafkaSinkConfig.Validate if the designated
// constraints aren't met.
type EventSinkConfig_KafkaSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_KafkaSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_KafkaSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_KafkaSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_KafkaSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_KafkaSinkConfigValidationError) ErrorName() string {
	return "EventSinkConfig_KafkaSinkConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_KafkaSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_KafkaSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_KafkaSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_KafkaSinkConfigValidationError{}

// Validate checks the field values on
// EventSinkConfig_AzureServiceBusSinkConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_AzureServiceBusSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EventSinkConfig_AzureServiceBusSinkConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// EventSinkConfig_AzureServiceBusSinkConfigMultiError, or nil if none found.
func (m *EventSinkConfig_AzureServiceBusSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_AzureServiceBusSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConnectionString

	// no validation rules for QueueOrTopicName

	if len(errors) > 0 {
		return EventSinkConfig_AzureServiceBusSinkConfigMultiError(errors)
	}

	return nil
}

// EventSinkConfig_AzureServiceBusSinkConfigMultiError is an error wrapping
// multiple validation errors returned by
// EventSinkConfig_AzureServiceBusSinkConfig.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_AzureServiceBusSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_AzureServiceBusSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_AzureServiceBusSinkConfigMultiError) AllErrors() []error { return m }

// EventSinkConfig_AzureServiceBusSinkConfigValidationError is the validation
// error returned by EventSinkConfig_AzureServiceBusSinkConfig.Validate if the
// designated constraints aren't met.
type EventSinkConfig_AzureServiceBusSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) ErrorName() string {
	return "EventSinkConfig_AzureServiceBusSinkConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_AzureServiceBusSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_AzureServiceBusSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_AzureServiceBusSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_AzureServiceBusSinkConfigValidationError{}

// Validate checks the field values on EventSinkConfig_AzureEventGridSinkConfig
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *EventSinkConfig_AzureEventGridSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EventSinkConfig_AzureEventGridSinkConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// EventSinkConfig_AzureEventGridSinkConfigMultiError, or nil if none found.
func (m *EventSinkConfig_AzureEventGridSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_AzureEventGridSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TopicEndpoint

	// no validation rules for AccessKey

	if len(errors) > 0 {
		return EventSinkConfig_AzureEventGridSinkConfigMultiError(errors)
	}

	return nil
}

// EventSinkConfig_AzureEventGridSinkConfigMultiError is an error wrapping
// multiple validation errors returned by
// EventSinkConfig_AzureEventGridSinkConfig.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_AzureEventGridSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_AzureEventGridSinkConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_AzureEventGridSinkConfigMultiError) AllErrors() []error { return m }

// EventSinkConfig_AzureEventGridSinkConfigValidationError is the validation
// error returned by EventSinkConfig_AzureEventGridSinkConfig.Validate if the
// designated constraints aren't met.
type EventSinkConfig_AzureEventGridSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) ErrorName() string {
	return "EventSinkConfig_AzureEventGridSinkConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_AzureEventGridSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_AzureEventGridSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_AzureEventGridSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_AzureEventGridSinkConfigValidationError{}

// Validate checks the field values on EventSinkConfig_Provider with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Provider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Provider with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfig_ProviderMultiError, or nil if none found.
func (m *EventSinkConfig_Provider) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Provider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Provider.(type) {
	case *EventSinkConfig_Provider_Kafka:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventSinkConfig_Provider_AzureServiceBus:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzureServiceBus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureServiceBus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureServiceBus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzureServiceBus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "AzureServiceBus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EventSinkConfig_Provider_AzureEventGrid:
		if v == nil {
			err := EventSinkConfig_ProviderValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzureEventGrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureEventGrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_ProviderValidationError{
						field:  "AzureEventGrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzureEventGrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_ProviderValidationError{
					field:  "AzureEventGrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EventSinkConfig_ProviderMultiError(errors)
	}

	return nil
}

// EventSinkConfig_ProviderMultiError is an error wrapping multiple validation
// errors returned by EventSinkConfig_Provider.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_ProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_ProviderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_ProviderMultiError) AllErrors() []error { return m }

// EventSinkConfig_ProviderValidationError is the validation error returned by
// EventSinkConfig_Provider.Validate if the designated constraints aren't met.
type EventSinkConfig_ProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_ProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_ProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_ProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_ProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_ProviderValidationError) ErrorName() string {
	return "EventSinkConfig_ProviderValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_ProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Provider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_ProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_ProviderValidationError{}

// Validate checks the field values on EventSinkConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Route) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Route with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventSinkConfig_RouteMultiError, or nil if none found.
func (m *EventSinkConfig_Route) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Route) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderId

	// no validation rules for StopProcessing

	switch v := m.Filter.(type) {
	case *EventSinkConfig_Route_EventType:
		if v == nil {
			err := EventSinkConfig_RouteValidationError{
				field:  "Filter",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for EventType
	case *EventSinkConfig_Route_ContextKeyValue:
		if v == nil {
			err := EventSinkConfig_RouteValidationError{
				field:  "Filter",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetContextKeyValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EventSinkConfig_RouteValidationError{
						field:  "ContextKeyValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EventSinkConfig_RouteValidationError{
						field:  "ContextKeyValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetContextKeyValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EventSinkConfig_RouteValidationError{
					field:  "ContextKeyValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EventSinkConfig_RouteMultiError(errors)
	}

	return nil
}

// EventSinkConfig_RouteMultiError is an error wrapping multiple validation
// errors returned by EventSinkConfig_Route.ValidateAll() if the designated
// constraints aren't met.
type EventSinkConfig_RouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_RouteMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_RouteMultiError) AllErrors() []error { return m }

// EventSinkConfig_RouteValidationError is the validation error returned by
// EventSinkConfig_Route.Validate if the designated constraints aren't met.
type EventSinkConfig_RouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_RouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_RouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_RouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_RouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_RouteValidationError) ErrorName() string {
	return "EventSinkConfig_RouteValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_RouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Route.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_RouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_RouteValidationError{}

// Validate checks the field values on EventSinkConfig_Route_KeyValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventSinkConfig_Route_KeyValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventSinkConfig_Route_KeyValue with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EventSinkConfig_Route_KeyValueMultiError, or nil if none found.
func (m *EventSinkConfig_Route_KeyValue) ValidateAll() error {
	return m.validate(true)
}

func (m *EventSinkConfig_Route_KeyValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return EventSinkConfig_Route_KeyValueMultiError(errors)
	}

	return nil
}

// EventSinkConfig_Route_KeyValueMultiError is an error wrapping multiple
// validation errors returned by EventSinkConfig_Route_KeyValue.ValidateAll()
// if the designated constraints aren't met.
type EventSinkConfig_Route_KeyValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventSinkConfig_Route_KeyValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventSinkConfig_Route_KeyValueMultiError) AllErrors() []error { return m }

// EventSinkConfig_Route_KeyValueValidationError is the validation error
// returned by EventSinkConfig_Route_KeyValue.Validate if the designated
// constraints aren't met.
type EventSinkConfig_Route_KeyValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventSinkConfig_Route_KeyValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventSinkConfig_Route_KeyValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventSinkConfig_Route_KeyValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventSinkConfig_Route_KeyValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventSinkConfig_Route_KeyValueValidationError) ErrorName() string {
	return "EventSinkConfig_Route_KeyValueValidationError"
}

// Error satisfies the builtin error interface
func (e EventSinkConfig_Route_KeyValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventSinkConfig_Route_KeyValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventSinkConfig_Route_KeyValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventSinkConfig_Route_KeyValueValidationError{}

// Validate checks the field values on TokenIntrospectConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_JWTMultiError, or nil if none found.
func (m *TokenIntrospectConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Issuer

	// no validation rules for Audience

	if len(errors) > 0 {
		return TokenIntrospectConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig_JWT.ValidateAll() if the
// designated constraints aren't met.
type TokenIntrospectConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_JWTMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_JWTMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_JWTValidationError is the validation error returned by
// TokenIntrospectConfig_JWT.Validate if the designated constraints aren't met.
type TokenIntrospectConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_JWTValidationError) ErrorName() string {
	return "TokenIntrospectConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_JWTValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Opaque) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Opaque with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OpaqueMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Opaque) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Opaque) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenIntrospectConfig_OpaqueMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OpaqueMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Opaque.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OpaqueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OpaqueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OpaqueMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OpaqueValidationError is the validation error returned
// by TokenIntrospectConfig_Opaque.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OpaqueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OpaqueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OpaqueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OpaqueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OpaqueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OpaqueValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OpaqueValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OpaqueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Opaque.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OpaqueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OpaqueValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Offline with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OfflineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenIntrospectConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Offline.ValidateAll()
// if the designated constraints aren't met.
type TokenIntrospectConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OfflineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OfflineValidationError is the validation error
// returned by TokenIntrospectConfig_Offline.Validate if the designated
// constraints aren't met.
type TokenIntrospectConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OfflineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OfflineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Online) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Online with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OnlineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Online) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Online) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserinfoEndpoint

	if all {
		switch v := interface{}(m.GetCacheTtl()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenIntrospectConfig_OnlineValidationError{
					field:  "CacheTtl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenIntrospectConfig_OnlineValidationError{
					field:  "CacheTtl",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCacheTtl()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenIntrospectConfig_OnlineValidationError{
				field:  "CacheTtl",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenIntrospectConfig_OnlineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OnlineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Online.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_OnlineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OnlineMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OnlineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OnlineValidationError is the validation error returned
// by TokenIntrospectConfig_Online.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_OnlineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OnlineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OnlineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OnlineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OnlineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OnlineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OnlineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OnlineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Online.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OnlineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OnlineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_ClaimMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Selector

	if len(errors) > 0 {
		return TokenIntrospectConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_ClaimMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Claim.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_ClaimMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_ClaimValidationError is the validation error returned
// by TokenIntrospectConfig_Claim.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_ClaimValidationError) ErrorName() string {
	return "TokenIntrospectConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_ClaimValidationError{}

// Validate checks the field values on EntityMatchingPipelineConfig_NodeFilter
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *EntityMatchingPipelineConfig_NodeFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EntityMatchingPipelineConfig_NodeFilter with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// EntityMatchingPipelineConfig_NodeFilterMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig_NodeFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig_NodeFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EntityMatchingPipelineConfig_NodeFilterMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfig_NodeFilterMultiError is an error wrapping
// multiple validation errors returned by
// EntityMatchingPipelineConfig_NodeFilter.ValidateAll() if the designated
// constraints aren't met.
type EntityMatchingPipelineConfig_NodeFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfig_NodeFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfig_NodeFilterMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfig_NodeFilterValidationError is the validation
// error returned by EntityMatchingPipelineConfig_NodeFilter.Validate if the
// designated constraints aren't met.
type EntityMatchingPipelineConfig_NodeFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfig_NodeFilterValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfig_NodeFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig_NodeFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfig_NodeFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfig_NodeFilterValidationError{}

// Validate checks the field values on
// EntityMatchingPipelineConfig_PropertyMapping with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EntityMatchingPipelineConfig_PropertyMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// EntityMatchingPipelineConfig_PropertyMapping with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// EntityMatchingPipelineConfig_PropertyMappingMultiError, or nil if none found.
func (m *EntityMatchingPipelineConfig_PropertyMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityMatchingPipelineConfig_PropertyMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceNodeType

	// no validation rules for SourceNodeProperty

	// no validation rules for TargetNodeType

	// no validation rules for TargetNodeProperty

	// no validation rules for SimilarityScoreCutoff

	if len(errors) > 0 {
		return EntityMatchingPipelineConfig_PropertyMappingMultiError(errors)
	}

	return nil
}

// EntityMatchingPipelineConfig_PropertyMappingMultiError is an error wrapping
// multiple validation errors returned by
// EntityMatchingPipelineConfig_PropertyMapping.ValidateAll() if the
// designated constraints aren't met.
type EntityMatchingPipelineConfig_PropertyMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityMatchingPipelineConfig_PropertyMappingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityMatchingPipelineConfig_PropertyMappingMultiError) AllErrors() []error { return m }

// EntityMatchingPipelineConfig_PropertyMappingValidationError is the
// validation error returned by
// EntityMatchingPipelineConfig_PropertyMapping.Validate if the designated
// constraints aren't met.
type EntityMatchingPipelineConfig_PropertyMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) ErrorName() string {
	return "EntityMatchingPipelineConfig_PropertyMappingValidationError"
}

// Error satisfies the builtin error interface
func (e EntityMatchingPipelineConfig_PropertyMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityMatchingPipelineConfig_PropertyMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityMatchingPipelineConfig_PropertyMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityMatchingPipelineConfig_PropertyMappingValidationError{}

// Validate checks the field values on CapturePipelineTopicConfig_Script with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CapturePipelineTopicConfig_Script) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CapturePipelineTopicConfig_Script
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CapturePipelineTopicConfig_ScriptMultiError, or nil if none found.
func (m *CapturePipelineTopicConfig_Script) ValidateAll() error {
	return m.validate(true)
}

func (m *CapturePipelineTopicConfig_Script) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return CapturePipelineTopicConfig_ScriptMultiError(errors)
	}

	return nil
}

// CapturePipelineTopicConfig_ScriptMultiError is an error wrapping multiple
// validation errors returned by
// CapturePipelineTopicConfig_Script.ValidateAll() if the designated
// constraints aren't met.
type CapturePipelineTopicConfig_ScriptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CapturePipelineTopicConfig_ScriptMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CapturePipelineTopicConfig_ScriptMultiError) AllErrors() []error { return m }

// CapturePipelineTopicConfig_ScriptValidationError is the validation error
// returned by CapturePipelineTopicConfig_Script.Validate if the designated
// constraints aren't met.
type CapturePipelineTopicConfig_ScriptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CapturePipelineTopicConfig_ScriptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CapturePipelineTopicConfig_ScriptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CapturePipelineTopicConfig_ScriptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CapturePipelineTopicConfig_ScriptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CapturePipelineTopicConfig_ScriptValidationError) ErrorName() string {
	return "CapturePipelineTopicConfig_ScriptValidationError"
}

// Error satisfies the builtin error interface
func (e CapturePipelineTopicConfig_ScriptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCapturePipelineTopicConfig_Script.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CapturePipelineTopicConfig_ScriptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CapturePipelineTopicConfig_ScriptValidationError{}
