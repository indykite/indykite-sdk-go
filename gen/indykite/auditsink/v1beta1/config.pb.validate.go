// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/auditsink/v1beta1/config.proto

package auditsinkv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ContainersPath with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainersPath) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainersPath with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainersPathMultiError,
// or nil if none found.
func (m *ContainersPath) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainersPath) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomerId

	// no validation rules for ApplicationSpaceId

	// no validation rules for TenantId

	if len(errors) > 0 {
		return ContainersPathMultiError(errors)
	}

	return nil
}

// ContainersPathMultiError is an error wrapping multiple validation errors
// returned by ContainersPath.ValidateAll() if the designated constraints
// aren't met.
type ContainersPathMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainersPathMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainersPathMultiError) AllErrors() []error { return m }

// ContainersPathValidationError is the validation error returned by
// ContainersPath.Validate if the designated constraints aren't met.
type ContainersPathValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainersPathValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainersPathValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainersPathValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainersPathValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainersPathValidationError) ErrorName() string { return "ContainersPathValidationError" }

// Error satisfies the builtin error interface
func (e ContainersPathValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainersPath.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainersPathValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainersPathValidationError{}

// Validate checks the field values on CreatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatedConfigMultiError, or
// nil if none found.
func (m *CreatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatedConfigMultiError(errors)
	}

	return nil
}

// CreatedConfigMultiError is an error wrapping multiple validation errors
// returned by CreatedConfig.ValidateAll() if the designated constraints
// aren't met.
type CreatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfigMultiError) AllErrors() []error { return m }

// CreatedConfigValidationError is the validation error returned by
// CreatedConfig.Validate if the designated constraints aren't met.
type CreatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfigValidationError) ErrorName() string { return "CreatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e CreatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfigValidationError{}

// Validate checks the field values on ReadConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadConfigMultiError, or
// nil if none found.
func (m *ReadConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	switch v := m.Identifier.(type) {
	case *ReadConfig_Id:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Id
	case *ReadConfig_Name:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadConfigValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReadConfigMultiError(errors)
	}

	return nil
}

// ReadConfigMultiError is an error wrapping multiple validation errors
// returned by ReadConfig.ValidateAll() if the designated constraints aren't met.
type ReadConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfigMultiError) AllErrors() []error { return m }

// ReadConfigValidationError is the validation error returned by
// ReadConfig.Validate if the designated constraints aren't met.
type ReadConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfigValidationError) ErrorName() string { return "ReadConfigValidationError" }

// Error satisfies the builtin error interface
func (e ReadConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfigValidationError{}

// Validate checks the field values on UpdatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatedConfigMultiError, or
// nil if none found.
func (m *UpdatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "Before",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "After",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatedConfigMultiError(errors)
	}

	return nil
}

// UpdatedConfigMultiError is an error wrapping multiple validation errors
// returned by UpdatedConfig.ValidateAll() if the designated constraints
// aren't met.
type UpdatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatedConfigMultiError) AllErrors() []error { return m }

// UpdatedConfigValidationError is the validation error returned by
// UpdatedConfig.Validate if the designated constraints aren't met.
type UpdatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatedConfigValidationError) ErrorName() string { return "UpdatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e UpdatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatedConfigValidationError{}

// Validate checks the field values on DeletedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletedConfigMultiError, or
// nil if none found.
func (m *DeletedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeletedConfigMultiError(errors)
	}

	return nil
}

// DeletedConfigMultiError is an error wrapping multiple validation errors
// returned by DeletedConfig.ValidateAll() if the designated constraints
// aren't met.
type DeletedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletedConfigMultiError) AllErrors() []error { return m }

// DeletedConfigValidationError is the validation error returned by
// DeletedConfig.Validate if the designated constraints aren't met.
type DeletedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletedConfigValidationError) ErrorName() string { return "DeletedConfigValidationError" }

// Error satisfies the builtin error interface
func (e DeletedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletedConfigValidationError{}

// Validate checks the field values on ConfigDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigDetailMultiError, or
// nil if none found.
func (m *ConfigDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Version

	switch v := m.Configuration.(type) {
	case *ConfigDetail_CustomerConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCustomerConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CustomerConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "CustomerConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustomerConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "CustomerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ApplicationSpaceConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationSpaceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationSpaceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationSpaceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationSpaceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationSpaceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_TenantConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTenantConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TenantConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TenantConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTenantConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "TenantConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ApplicationAgentCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationAgentCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationAgentCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationAgentCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ServiceAccountCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceAccountCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceAccountCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ServiceAccountCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuthFlowConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthFlowConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthFlowConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthFlowConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthFlowConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuthFlowConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_EmailServiceConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmailServiceConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "EmailServiceConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmailServiceConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "EmailServiceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuditSinkConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuditSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_Oauth2ClientConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOauth2ClientConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ClientConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOauth2ClientConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "Oauth2ClientConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_WebAuthnProviderConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebAuthnProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "WebAuthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "WebAuthnProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebAuthnProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "WebAuthnProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_TokenExchangeConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenExchangeConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenExchangeConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenExchangeConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenExchangeConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "TokenExchangeConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_Oauth2ApplicationConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOauth2ApplicationConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ApplicationConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ApplicationConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOauth2ApplicationConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "Oauth2ApplicationConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_Oauth2ProviderConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOauth2ProviderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "Oauth2ProviderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOauth2ProviderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "Oauth2ProviderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ConsentConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConfigDetailMultiError(errors)
	}

	return nil
}

// ConfigDetailMultiError is an error wrapping multiple validation errors
// returned by ConfigDetail.ValidateAll() if the designated constraints aren't met.
type ConfigDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigDetailMultiError) AllErrors() []error { return m }

// ConfigDetailValidationError is the validation error returned by
// ConfigDetail.Validate if the designated constraints aren't met.
type ConfigDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigDetailValidationError) ErrorName() string { return "ConfigDetailValidationError" }

// Error satisfies the builtin error interface
func (e ConfigDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigDetailValidationError{}

// Validate checks the field values on CustomerConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CustomerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomerConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomerConfigMultiError,
// or nil if none found.
func (m *CustomerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefaultAuthFlowId

	// no validation rules for DefaultEmailServiceId

	if len(errors) > 0 {
		return CustomerConfigMultiError(errors)
	}

	return nil
}

// CustomerConfigMultiError is an error wrapping multiple validation errors
// returned by CustomerConfig.ValidateAll() if the designated constraints
// aren't met.
type CustomerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomerConfigMultiError) AllErrors() []error { return m }

// CustomerConfigValidationError is the validation error returned by
// CustomerConfig.Validate if the designated constraints aren't met.
type CustomerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomerConfigValidationError) ErrorName() string { return "CustomerConfigValidationError" }

// Error satisfies the builtin error interface
func (e CustomerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomerConfigValidationError{}

// Validate checks the field values on ApplicationSpaceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplicationSpaceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationSpaceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplicationSpaceConfigMultiError, or nil if none found.
func (m *ApplicationSpaceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationSpaceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefaultTenantId

	// no validation rules for DefaultAuthFlowId

	// no validation rules for DefaultEmailServiceId

	if all {
		switch v := interface{}(m.GetUsernamePolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationSpaceConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationSpaceConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsernamePolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationSpaceConfigValidationError{
				field:  "UsernamePolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationSpaceConfigMultiError(errors)
	}

	return nil
}

// ApplicationSpaceConfigMultiError is an error wrapping multiple validation
// errors returned by ApplicationSpaceConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationSpaceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationSpaceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationSpaceConfigMultiError) AllErrors() []error { return m }

// ApplicationSpaceConfigValidationError is the validation error returned by
// ApplicationSpaceConfig.Validate if the designated constraints aren't met.
type ApplicationSpaceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationSpaceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationSpaceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationSpaceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationSpaceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationSpaceConfigValidationError) ErrorName() string {
	return "ApplicationSpaceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationSpaceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationSpaceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationSpaceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationSpaceConfigValidationError{}

// Validate checks the field values on TenantConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TenantConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TenantConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TenantConfigMultiError, or
// nil if none found.
func (m *TenantConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TenantConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefaultAuthFlowId

	// no validation rules for DefaultEmailServiceId

	if all {
		switch v := interface{}(m.GetUsernamePolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantConfigValidationError{
					field:  "UsernamePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsernamePolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantConfigValidationError{
				field:  "UsernamePolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TenantConfigMultiError(errors)
	}

	return nil
}

// TenantConfigMultiError is an error wrapping multiple validation errors
// returned by TenantConfig.ValidateAll() if the designated constraints aren't met.
type TenantConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantConfigMultiError) AllErrors() []error { return m }

// TenantConfigValidationError is the validation error returned by
// TenantConfig.Validate if the designated constraints aren't met.
type TenantConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantConfigValidationError) ErrorName() string { return "TenantConfigValidationError" }

// Error satisfies the builtin error interface
func (e TenantConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantConfigValidationError{}

// Validate checks the field values on UsernamePolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UsernamePolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UsernamePolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UsernamePolicyConfigMultiError, or nil if none found.
func (m *UsernamePolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *UsernamePolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ValidEmail

	// no validation rules for VerifyEmail

	if all {
		switch v := interface{}(m.GetVerifyEmailGracePeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UsernamePolicyConfigValidationError{
					field:  "VerifyEmailGracePeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UsernamePolicyConfigValidationError{
					field:  "VerifyEmailGracePeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerifyEmailGracePeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UsernamePolicyConfigValidationError{
				field:  "VerifyEmailGracePeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UsernamePolicyConfigMultiError(errors)
	}

	return nil
}

// UsernamePolicyConfigMultiError is an error wrapping multiple validation
// errors returned by UsernamePolicyConfig.ValidateAll() if the designated
// constraints aren't met.
type UsernamePolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsernamePolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsernamePolicyConfigMultiError) AllErrors() []error { return m }

// UsernamePolicyConfigValidationError is the validation error returned by
// UsernamePolicyConfig.Validate if the designated constraints aren't met.
type UsernamePolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsernamePolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsernamePolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsernamePolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsernamePolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsernamePolicyConfigValidationError) ErrorName() string {
	return "UsernamePolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e UsernamePolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsernamePolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsernamePolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsernamePolicyConfigValidationError{}

// Validate checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplicationAgentCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialConfigMultiError, or nil if none found.
func (m *ApplicationAgentCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialConfigMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by
// ApplicationAgentCredentialConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialConfigMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialConfigValidationError is the validation error
// returned by ApplicationAgentCredentialConfig.Validate if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialConfigValidationError) ErrorName() string {
	return "ApplicationAgentCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialConfigValidationError{}

// Validate checks the field values on ServiceAccountCredentialConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialConfigMultiError, or nil if none found.
func (m *ServiceAccountCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialConfigMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by ServiceAccountCredentialConfig.ValidateAll()
// if the designated constraints aren't met.
type ServiceAccountCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialConfigMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialConfigValidationError is the validation error
// returned by ServiceAccountCredentialConfig.Validate if the designated
// constraints aren't met.
type ServiceAccountCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialConfigValidationError) ErrorName() string {
	return "ServiceAccountCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialConfigValidationError{}

// Validate checks the field values on AuthFlowConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthFlowConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthFlowConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthFlowConfigMultiError,
// or nil if none found.
func (m *AuthFlowConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthFlowConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceFormat

	// no validation rules for Source

	if len(errors) > 0 {
		return AuthFlowConfigMultiError(errors)
	}

	return nil
}

// AuthFlowConfigMultiError is an error wrapping multiple validation errors
// returned by AuthFlowConfig.ValidateAll() if the designated constraints
// aren't met.
type AuthFlowConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthFlowConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthFlowConfigMultiError) AllErrors() []error { return m }

// AuthFlowConfigValidationError is the validation error returned by
// AuthFlowConfig.Validate if the designated constraints aren't met.
type AuthFlowConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthFlowConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthFlowConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthFlowConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthFlowConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthFlowConfigValidationError) ErrorName() string { return "AuthFlowConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuthFlowConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthFlowConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthFlowConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthFlowConfigValidationError{}

// Validate checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmailServiceConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailServiceConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailServiceConfigMultiError, or nil if none found.
func (m *EmailServiceConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailServiceConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvitationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "InvitationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvitationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "InvitationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResetPasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "ResetPasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResetPasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "ResetPasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVerificationMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "VerificationMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVerificationMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "VerificationMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOneTimePasswordMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailServiceConfigValidationError{
					field:  "OneTimePasswordMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOneTimePasswordMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailServiceConfigValidationError{
				field:  "OneTimePasswordMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Provider.(type) {
	case *EmailServiceConfig_Sendgrid:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSendgrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendgrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Sendgrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EmailServiceConfig_Amazon:
		if v == nil {
			err := EmailServiceConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAmazon()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailServiceConfigValidationError{
						field:  "Amazon",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAmazon()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailServiceConfigValidationError{
					field:  "Amazon",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EmailServiceConfigMultiError(errors)
	}

	return nil
}

// EmailServiceConfigMultiError is an error wrapping multiple validation errors
// returned by EmailServiceConfig.ValidateAll() if the designated constraints
// aren't met.
type EmailServiceConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailServiceConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailServiceConfigMultiError) AllErrors() []error { return m }

// EmailServiceConfigValidationError is the validation error returned by
// EmailServiceConfig.Validate if the designated constraints aren't met.
type EmailServiceConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailServiceConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailServiceConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailServiceConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailServiceConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailServiceConfigValidationError) ErrorName() string {
	return "EmailServiceConfigValidationError"
}

// Error satisfies the builtin error interface
func (e EmailServiceConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailServiceConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailServiceConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailServiceConfigValidationError{}

// Validate checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Email) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmailMultiError, or nil if none found.
func (m *Email) ValidateAll() error {
	return m.validate(true)
}

func (m *Email) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Name

	if len(errors) > 0 {
		return EmailMultiError(errors)
	}

	return nil
}

// EmailMultiError is an error wrapping multiple validation errors returned by
// Email.ValidateAll() if the designated constraints aren't met.
type EmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMultiError) AllErrors() []error { return m }

// EmailValidationError is the validation error returned by Email.Validate if
// the designated constraints aren't met.
type EmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailValidationError) ErrorName() string { return "EmailValidationError" }

// Error satisfies the builtin error interface
func (e EmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailValidationError{}

// Validate checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendGridProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendGridProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendGridProviderConfigMultiError, or nil if none found.
func (m *SendGridProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SendGridProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiKey

	// no validation rules for SandboxMode

	// no validation rules for IpPoolName

	// no validation rules for Host

	if len(errors) > 0 {
		return SendGridProviderConfigMultiError(errors)
	}

	return nil
}

// SendGridProviderConfigMultiError is an error wrapping multiple validation
// errors returned by SendGridProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type SendGridProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendGridProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendGridProviderConfigMultiError) AllErrors() []error { return m }

// SendGridProviderConfigValidationError is the validation error returned by
// SendGridProviderConfig.Validate if the designated constraints aren't met.
type SendGridProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendGridProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendGridProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendGridProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendGridProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendGridProviderConfigValidationError) ErrorName() string {
	return "SendGridProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SendGridProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendGridProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendGridProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendGridProviderConfigValidationError{}

// Validate checks the field values on AmazonSESProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AmazonSESProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AmazonSESProviderConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AmazonSESProviderConfigMultiError, or nil if none found.
func (m *AmazonSESProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AmazonSESProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessKeyId

	// no validation rules for SecretAccessKey

	// no validation rules for Region

	// no validation rules for ConfigurationSetName

	if all {
		switch v := interface{}(m.GetDefaultFromAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AmazonSESProviderConfigValidationError{
					field:  "DefaultFromAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultFromAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AmazonSESProviderConfigValidationError{
				field:  "DefaultFromAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FeedbackForwardingEmailAddress

	if len(errors) > 0 {
		return AmazonSESProviderConfigMultiError(errors)
	}

	return nil
}

// AmazonSESProviderConfigMultiError is an error wrapping multiple validation
// errors returned by AmazonSESProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type AmazonSESProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AmazonSESProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AmazonSESProviderConfigMultiError) AllErrors() []error { return m }

// AmazonSESProviderConfigValidationError is the validation error returned by
// AmazonSESProviderConfig.Validate if the designated constraints aren't met.
type AmazonSESProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AmazonSESProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AmazonSESProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AmazonSESProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AmazonSESProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AmazonSESProviderConfigValidationError) ErrorName() string {
	return "AmazonSESProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AmazonSESProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAmazonSESProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AmazonSESProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AmazonSESProviderConfigValidationError{}

// Validate checks the field values on EmailDefinition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailDefinitionMultiError, or nil if none found.
func (m *EmailDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Email.(type) {
	case *EmailDefinition_Template:
		if v == nil {
			err := EmailDefinitionValidationError{
				field:  "Email",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTemplate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailDefinitionValidationError{
						field:  "Template",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemplate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailDefinitionValidationError{
					field:  "Template",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EmailDefinitionMultiError(errors)
	}

	return nil
}

// EmailDefinitionMultiError is an error wrapping multiple validation errors
// returned by EmailDefinition.ValidateAll() if the designated constraints
// aren't met.
type EmailDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailDefinitionMultiError) AllErrors() []error { return m }

// EmailDefinitionValidationError is the validation error returned by
// EmailDefinition.Validate if the designated constraints aren't met.
type EmailDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailDefinitionValidationError) ErrorName() string { return "EmailDefinitionValidationError" }

// Error satisfies the builtin error interface
func (e EmailDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailDefinitionValidationError{}

// Validate checks the field values on EmailTemplate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailTemplateMultiError, or
// nil if none found.
func (m *EmailTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TemplateId

	// no validation rules for TemplateVersion

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReplyTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmailTemplateValidationError{
					field:  "ReplyTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReplyTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmailTemplateValidationError{
				field:  "ReplyTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Cc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Cc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBcc() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Bcc[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Bcc[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Subject

	// no validation rules for Headers

	// no validation rules for CustomArgs

	{
		sorted_keys := make([]string, len(m.GetDynamicTemplateValues()))
		i := 0
		for key := range m.GetDynamicTemplateValues() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetDynamicTemplateValues()[key]
			_ = val

			// no validation rules for DynamicTemplateValues[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmailTemplateValidationError{
							field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmailTemplateValidationError{
						field:  fmt.Sprintf("DynamicTemplateValues[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmailTemplateValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmailTemplateValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for EventPayload

	// no validation rules for TemplateArn

	if len(errors) > 0 {
		return EmailTemplateMultiError(errors)
	}

	return nil
}

// EmailTemplateMultiError is an error wrapping multiple validation errors
// returned by EmailTemplate.ValidateAll() if the designated constraints
// aren't met.
type EmailTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailTemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailTemplateMultiError) AllErrors() []error { return m }

// EmailTemplateValidationError is the validation error returned by
// EmailTemplate.Validate if the designated constraints aren't met.
type EmailTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailTemplateValidationError) ErrorName() string { return "EmailTemplateValidationError" }

// Error satisfies the builtin error interface
func (e EmailTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailTemplateValidationError{}

// Validate checks the field values on EmailAttachment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmailAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmailAttachmentMultiError, or nil if none found.
func (m *EmailAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentType

	// no validation rules for ContentId

	// no validation rules for Inline

	// no validation rules for FileName

	// no validation rules for Content

	if len(errors) > 0 {
		return EmailAttachmentMultiError(errors)
	}

	return nil
}

// EmailAttachmentMultiError is an error wrapping multiple validation errors
// returned by EmailAttachment.ValidateAll() if the designated constraints
// aren't met.
type EmailAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailAttachmentMultiError) AllErrors() []error { return m }

// EmailAttachmentValidationError is the validation error returned by
// EmailAttachment.Validate if the designated constraints aren't met.
type EmailAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailAttachmentValidationError) ErrorName() string { return "EmailAttachmentValidationError" }

// Error satisfies the builtin error interface
func (e EmailAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailAttachmentValidationError{}

// Validate checks the field values on AuditSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfigMultiError, or nil if none found.
func (m *AuditSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Provider.(type) {
	case *AuditSinkConfig_Kafka_:
		if v == nil {
			err := AuditSinkConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditSinkConfigValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuditSinkConfigMultiError(errors)
	}

	return nil
}

// AuditSinkConfigMultiError is an error wrapping multiple validation errors
// returned by AuditSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type AuditSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfigMultiError) AllErrors() []error { return m }

// AuditSinkConfigValidationError is the validation error returned by
// AuditSinkConfig.Validate if the designated constraints aren't met.
type AuditSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfigValidationError) ErrorName() string { return "AuditSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuditSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfigValidationError{}

// Validate checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ClientConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ClientConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ClientConfigMultiError, or nil if none found.
func (m *OAuth2ClientConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ClientConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderType

	// no validation rules for ClientId

	// no validation rules for ClientSecret

	// no validation rules for AllowSignup

	// no validation rules for Issuer

	// no validation rules for AuthorizationEndpoint

	// no validation rules for TokenEndpoint

	// no validation rules for DiscoveryUrl

	// no validation rules for UserinfoEndpoint

	// no validation rules for JwksUri

	// no validation rules for ImageUrl

	// no validation rules for Tenant

	// no validation rules for HostedDomain

	// no validation rules for AuthStyle

	// no validation rules for PrivateKeyPem

	// no validation rules for PrivateKeyId

	// no validation rules for TeamId

	if len(errors) > 0 {
		return OAuth2ClientConfigMultiError(errors)
	}

	return nil
}

// OAuth2ClientConfigMultiError is an error wrapping multiple validation errors
// returned by OAuth2ClientConfig.ValidateAll() if the designated constraints
// aren't met.
type OAuth2ClientConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ClientConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ClientConfigMultiError) AllErrors() []error { return m }

// OAuth2ClientConfigValidationError is the validation error returned by
// OAuth2ClientConfig.Validate if the designated constraints aren't met.
type OAuth2ClientConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ClientConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ClientConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ClientConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ClientConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ClientConfigValidationError) ErrorName() string {
	return "OAuth2ClientConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ClientConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ClientConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ClientConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ClientConfigValidationError{}

// Validate checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ProviderConfigMultiError, or nil if none found.
func (m *OAuth2ProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestObjectSigningAlg

	// no validation rules for FrontChannelLoginUri

	// no validation rules for FrontChannelConsentUri

	if len(errors) > 0 {
		return OAuth2ProviderConfigMultiError(errors)
	}

	return nil
}

// OAuth2ProviderConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ProviderConfigMultiError) AllErrors() []error { return m }

// OAuth2ProviderConfigValidationError is the validation error returned by
// OAuth2ProviderConfig.Validate if the designated constraints aren't met.
type OAuth2ProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ProviderConfigValidationError) ErrorName() string {
	return "OAuth2ProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ProviderConfigValidationError{}

// Validate checks the field values on OAuth2ApplicationConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuth2ApplicationConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuth2ApplicationConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuth2ApplicationConfigMultiError, or nil if none found.
func (m *OAuth2ApplicationConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuth2ApplicationConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientId

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Owner

	// no validation rules for PolicyUri

	// no validation rules for TermsOfServiceUri

	// no validation rules for ClientUri

	// no validation rules for LogoUri

	// no validation rules for UserSupportEmailAddress

	// no validation rules for SubjectType

	// no validation rules for SectorIdentifierUri

	// no validation rules for TokenEndpointAuthMethod

	// no validation rules for TokenEndpointAuthSigningAlg

	// no validation rules for UserinfoSignedResponseAlg

	// no validation rules for Trusted

	if len(errors) > 0 {
		return OAuth2ApplicationConfigMultiError(errors)
	}

	return nil
}

// OAuth2ApplicationConfigMultiError is an error wrapping multiple validation
// errors returned by OAuth2ApplicationConfig.ValidateAll() if the designated
// constraints aren't met.
type OAuth2ApplicationConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuth2ApplicationConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuth2ApplicationConfigMultiError) AllErrors() []error { return m }

// OAuth2ApplicationConfigValidationError is the validation error returned by
// OAuth2ApplicationConfig.Validate if the designated constraints aren't met.
type OAuth2ApplicationConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuth2ApplicationConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuth2ApplicationConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuth2ApplicationConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuth2ApplicationConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuth2ApplicationConfigValidationError) ErrorName() string {
	return "OAuth2ApplicationConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OAuth2ApplicationConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuth2ApplicationConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuth2ApplicationConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuth2ApplicationConfigValidationError{}

// Validate checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebAuthnProviderConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAuthnProviderConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebAuthnProviderConfigMultiError, or nil if none found.
func (m *WebAuthnProviderConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAuthnProviderConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RelyingParties

	// no validation rules for AttestationPreference

	// no validation rules for AuthenticatorAttachment

	// no validation rules for RequireResidentKey

	// no validation rules for UserVerification

	if all {
		switch v := interface{}(m.GetRegistrationTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAuthnProviderConfigValidationError{
					field:  "RegistrationTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAuthnProviderConfigValidationError{
					field:  "RegistrationTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegistrationTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAuthnProviderConfigValidationError{
				field:  "RegistrationTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAuthenticationTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAuthnProviderConfigValidationError{
					field:  "AuthenticationTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAuthnProviderConfigValidationError{
					field:  "AuthenticationTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticationTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAuthnProviderConfigValidationError{
				field:  "AuthenticationTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAuthnProviderConfigMultiError(errors)
	}

	return nil
}

// WebAuthnProviderConfigMultiError is an error wrapping multiple validation
// errors returned by WebAuthnProviderConfig.ValidateAll() if the designated
// constraints aren't met.
type WebAuthnProviderConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAuthnProviderConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAuthnProviderConfigMultiError) AllErrors() []error { return m }

// WebAuthnProviderConfigValidationError is the validation error returned by
// WebAuthnProviderConfig.Validate if the designated constraints aren't met.
type WebAuthnProviderConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAuthnProviderConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAuthnProviderConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAuthnProviderConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAuthnProviderConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAuthnProviderConfigValidationError) ErrorName() string {
	return "WebAuthnProviderConfigValidationError"
}

// Error satisfies the builtin error interface
func (e WebAuthnProviderConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAuthnProviderConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAuthnProviderConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAuthnProviderConfigValidationError{}

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Policy

	// no validation rules for Status

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

// Validate checks the field values on AssignConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssignConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssignConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssignConfigPermissionsMultiError, or nil if none found.
func (m *AssignConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *AssignConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return AssignConfigPermissionsMultiError(errors)
	}

	return nil
}

// AssignConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by AssignConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type AssignConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssignConfigPermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssignConfigPermissionsMultiError) AllErrors() []error { return m }

// AssignConfigPermissionsValidationError is the validation error returned by
// AssignConfigPermissions.Validate if the designated constraints aren't met.
type AssignConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssignConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssignConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssignConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssignConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssignConfigPermissionsValidationError) ErrorName() string {
	return "AssignConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e AssignConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssignConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssignConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssignConfigPermissionsValidationError{}

// Validate checks the field values on RevokeConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeConfigPermissionsMultiError, or nil if none found.
func (m *RevokeConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return RevokeConfigPermissionsMultiError(errors)
	}

	return nil
}

// RevokeConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by RevokeConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type RevokeConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeConfigPermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeConfigPermissionsMultiError) AllErrors() []error { return m }

// RevokeConfigPermissionsValidationError is the validation error returned by
// RevokeConfigPermissions.Validate if the designated constraints aren't met.
type RevokeConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeConfigPermissionsValidationError) ErrorName() string {
	return "RevokeConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeConfigPermissionsValidationError{}

// Validate checks the field values on TokenExchangeConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenExchangeConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenExchangeConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenExchangeConfigMultiError, or nil if none found.
func (m *TokenExchangeConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenExchangeConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			// no validation rules for ClaimsMapping[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenExchangeConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenExchangeConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenExchangeConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for IkgNodeType

	// no validation rules for PerformUpsert

	switch v := m.TokenMatcher.(type) {
	case *TokenExchangeConfig_Jwt:
		if v == nil {
			err := TokenExchangeConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenExchangeConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenExchangeConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenExchangeConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Validation.(type) {
	case *TokenExchangeConfig_Offline_:
		if v == nil {
			err := TokenExchangeConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenExchangeConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenExchangeConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenExchangeConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TokenExchangeConfigMultiError(errors)
	}

	return nil
}

// TokenExchangeConfigMultiError is an error wrapping multiple validation
// errors returned by TokenExchangeConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenExchangeConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenExchangeConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenExchangeConfigMultiError) AllErrors() []error { return m }

// TokenExchangeConfigValidationError is the validation error returned by
// TokenExchangeConfig.Validate if the designated constraints aren't met.
type TokenExchangeConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenExchangeConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenExchangeConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenExchangeConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenExchangeConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenExchangeConfigValidationError) ErrorName() string {
	return "TokenExchangeConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenExchangeConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenExchangeConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenExchangeConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenExchangeConfigValidationError{}

// Validate checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig_Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatedConfig_LocationMultiError, or nil if none found.
func (m *CreatedConfig_Location) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig_Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if len(errors) > 0 {
		return CreatedConfig_LocationMultiError(errors)
	}

	return nil
}

// CreatedConfig_LocationMultiError is an error wrapping multiple validation
// errors returned by CreatedConfig_Location.ValidateAll() if the designated
// constraints aren't met.
type CreatedConfig_LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfig_LocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfig_LocationMultiError) AllErrors() []error { return m }

// CreatedConfig_LocationValidationError is the validation error returned by
// CreatedConfig_Location.Validate if the designated constraints aren't met.
type CreatedConfig_LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfig_LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfig_LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfig_LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfig_LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfig_LocationValidationError) ErrorName() string {
	return "CreatedConfig_LocationValidationError"
}

// Error satisfies the builtin error interface
func (e CreatedConfig_LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig_Location.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfig_LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfig_LocationValidationError{}

// Validate checks the field values on ReadConfig_NameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadConfig_NameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig_NameIdentifier with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadConfig_NameIdentifierMultiError, or nil if none found.
func (m *ReadConfig_NameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig_NameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LocationId

	// no validation rules for Name

	if m.LocationType != nil {
		// no validation rules for LocationType
	}

	if len(errors) > 0 {
		return ReadConfig_NameIdentifierMultiError(errors)
	}

	return nil
}

// ReadConfig_NameIdentifierMultiError is an error wrapping multiple validation
// errors returned by ReadConfig_NameIdentifier.ValidateAll() if the
// designated constraints aren't met.
type ReadConfig_NameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfig_NameIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfig_NameIdentifierMultiError) AllErrors() []error { return m }

// ReadConfig_NameIdentifierValidationError is the validation error returned by
// ReadConfig_NameIdentifier.Validate if the designated constraints aren't met.
type ReadConfig_NameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfig_NameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfig_NameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfig_NameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfig_NameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfig_NameIdentifierValidationError) ErrorName() string {
	return "ReadConfig_NameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e ReadConfig_NameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig_NameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfig_NameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfig_NameIdentifierValidationError{}

// Validate checks the field values on AuditSinkConfig_Kafka with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig_Kafka) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig_Kafka with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfig_KafkaMultiError, or nil if none found.
func (m *AuditSinkConfig_Kafka) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig_Kafka) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Topic

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return AuditSinkConfig_KafkaMultiError(errors)
	}

	return nil
}

// AuditSinkConfig_KafkaMultiError is an error wrapping multiple validation
// errors returned by AuditSinkConfig_Kafka.ValidateAll() if the designated
// constraints aren't met.
type AuditSinkConfig_KafkaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfig_KafkaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfig_KafkaMultiError) AllErrors() []error { return m }

// AuditSinkConfig_KafkaValidationError is the validation error returned by
// AuditSinkConfig_Kafka.Validate if the designated constraints aren't met.
type AuditSinkConfig_KafkaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfig_KafkaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfig_KafkaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfig_KafkaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfig_KafkaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfig_KafkaValidationError) ErrorName() string {
	return "AuditSinkConfig_KafkaValidationError"
}

// Error satisfies the builtin error interface
func (e AuditSinkConfig_KafkaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig_Kafka.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfig_KafkaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfig_KafkaValidationError{}

// Validate checks the field values on TokenExchangeConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenExchangeConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenExchangeConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenExchangeConfig_JWTMultiError, or nil if none found.
func (m *TokenExchangeConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenExchangeConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Issuer

	// no validation rules for Audience

	if len(errors) > 0 {
		return TokenExchangeConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenExchangeConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenExchangeConfig_JWT.ValidateAll() if the designated
// constraints aren't met.
type TokenExchangeConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenExchangeConfig_JWTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenExchangeConfig_JWTMultiError) AllErrors() []error { return m }

// TokenExchangeConfig_JWTValidationError is the validation error returned by
// TokenExchangeConfig_JWT.Validate if the designated constraints aren't met.
type TokenExchangeConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenExchangeConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenExchangeConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenExchangeConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenExchangeConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenExchangeConfig_JWTValidationError) ErrorName() string {
	return "TokenExchangeConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenExchangeConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenExchangeConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenExchangeConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenExchangeConfig_JWTValidationError{}

// Validate checks the field values on TokenExchangeConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenExchangeConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenExchangeConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenExchangeConfig_OfflineMultiError, or nil if none found.
func (m *TokenExchangeConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenExchangeConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenExchangeConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenExchangeConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenExchangeConfig_Offline.ValidateAll() if
// the designated constraints aren't met.
type TokenExchangeConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenExchangeConfig_OfflineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenExchangeConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenExchangeConfig_OfflineValidationError is the validation error returned
// by TokenExchangeConfig_Offline.Validate if the designated constraints
// aren't met.
type TokenExchangeConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenExchangeConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenExchangeConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenExchangeConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenExchangeConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenExchangeConfig_OfflineValidationError) ErrorName() string {
	return "TokenExchangeConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenExchangeConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenExchangeConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenExchangeConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenExchangeConfig_OfflineValidationError{}

// Validate checks the field values on TokenExchangeConfig_Claim with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenExchangeConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenExchangeConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenExchangeConfig_ClaimMultiError, or nil if none found.
func (m *TokenExchangeConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenExchangeConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Selector

	if len(errors) > 0 {
		return TokenExchangeConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenExchangeConfig_ClaimMultiError is an error wrapping multiple validation
// errors returned by TokenExchangeConfig_Claim.ValidateAll() if the
// designated constraints aren't met.
type TokenExchangeConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenExchangeConfig_ClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenExchangeConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenExchangeConfig_ClaimValidationError is the validation error returned by
// TokenExchangeConfig_Claim.Validate if the designated constraints aren't met.
type TokenExchangeConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenExchangeConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenExchangeConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenExchangeConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenExchangeConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenExchangeConfig_ClaimValidationError) ErrorName() string {
	return "TokenExchangeConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenExchangeConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenExchangeConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenExchangeConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenExchangeConfig_ClaimValidationError{}
