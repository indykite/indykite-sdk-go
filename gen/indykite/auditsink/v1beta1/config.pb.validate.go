// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/auditsink/v1beta1/config.proto

package auditsinkv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ContainersPath with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ContainersPath) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ContainersPath with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainersPathMultiError,
// or nil if none found.
func (m *ContainersPath) ValidateAll() error {
	return m.validate(true)
}

func (m *ContainersPath) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CustomerId

	// no validation rules for ApplicationSpaceId

	if len(errors) > 0 {
		return ContainersPathMultiError(errors)
	}

	return nil
}

// ContainersPathMultiError is an error wrapping multiple validation errors
// returned by ContainersPath.ValidateAll() if the designated constraints
// aren't met.
type ContainersPathMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainersPathMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainersPathMultiError) AllErrors() []error { return m }

// ContainersPathValidationError is the validation error returned by
// ContainersPath.Validate if the designated constraints aren't met.
type ContainersPathValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainersPathValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainersPathValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainersPathValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainersPathValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainersPathValidationError) ErrorName() string { return "ContainersPathValidationError" }

// Error satisfies the builtin error interface
func (e ContainersPathValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainersPath.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainersPathValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainersPathValidationError{}

// Validate checks the field values on CreatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatedConfigMultiError, or
// nil if none found.
func (m *CreatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Location",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatedConfigValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatedConfigValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatedConfigMultiError(errors)
	}

	return nil
}

// CreatedConfigMultiError is an error wrapping multiple validation errors
// returned by CreatedConfig.ValidateAll() if the designated constraints
// aren't met.
type CreatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfigMultiError) AllErrors() []error { return m }

// CreatedConfigValidationError is the validation error returned by
// CreatedConfig.Validate if the designated constraints aren't met.
type CreatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfigValidationError) ErrorName() string { return "CreatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e CreatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfigValidationError{}

// Validate checks the field values on ReadConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReadConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReadConfigMultiError, or
// nil if none found.
func (m *ReadConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	switch v := m.Identifier.(type) {
	case *ReadConfig_Id:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Id
	case *ReadConfig_Name:
		if v == nil {
			err := ReadConfigValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReadConfigValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReadConfigValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReadConfigMultiError(errors)
	}

	return nil
}

// ReadConfigMultiError is an error wrapping multiple validation errors
// returned by ReadConfig.ValidateAll() if the designated constraints aren't met.
type ReadConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfigMultiError) AllErrors() []error { return m }

// ReadConfigValidationError is the validation error returned by
// ReadConfig.Validate if the designated constraints aren't met.
type ReadConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfigValidationError) ErrorName() string { return "ReadConfigValidationError" }

// Error satisfies the builtin error interface
func (e ReadConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfigValidationError{}

// Validate checks the field values on UpdatedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatedConfigMultiError, or
// nil if none found.
func (m *UpdatedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "Before",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatedConfigValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatedConfigValidationError{
				field:  "After",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatedConfigMultiError(errors)
	}

	return nil
}

// UpdatedConfigMultiError is an error wrapping multiple validation errors
// returned by UpdatedConfig.ValidateAll() if the designated constraints
// aren't met.
type UpdatedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatedConfigMultiError) AllErrors() []error { return m }

// UpdatedConfigValidationError is the validation error returned by
// UpdatedConfig.Validate if the designated constraints aren't met.
type UpdatedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatedConfigValidationError) ErrorName() string { return "UpdatedConfigValidationError" }

// Error satisfies the builtin error interface
func (e UpdatedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatedConfigValidationError{}

// Validate checks the field values on DeletedConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletedConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletedConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletedConfigMultiError, or
// nil if none found.
func (m *DeletedConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletedConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetContainersPath()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletedConfigValidationError{
					field:  "ContainersPath",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainersPath()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletedConfigValidationError{
				field:  "ContainersPath",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeletedConfigMultiError(errors)
	}

	return nil
}

// DeletedConfigMultiError is an error wrapping multiple validation errors
// returned by DeletedConfig.ValidateAll() if the designated constraints
// aren't met.
type DeletedConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletedConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletedConfigMultiError) AllErrors() []error { return m }

// DeletedConfigValidationError is the validation error returned by
// DeletedConfig.Validate if the designated constraints aren't met.
type DeletedConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletedConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletedConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletedConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletedConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletedConfigValidationError) ErrorName() string { return "DeletedConfigValidationError" }

// Error satisfies the builtin error interface
func (e DeletedConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletedConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletedConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletedConfigValidationError{}

// Validate checks the field values on ConfigDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigDetailMultiError, or
// nil if none found.
func (m *ConfigDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Version

	switch v := m.Configuration.(type) {
	case *ConfigDetail_ApplicationAgentCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplicationAgentCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ApplicationAgentCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplicationAgentCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ApplicationAgentCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ServiceAccountCredential:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceAccountCredential()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ServiceAccountCredential",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceAccountCredential()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ServiceAccountCredential",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuditSinkConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuditSinkConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuditSinkConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuditSinkConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuditSinkConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_AuthorizationPolicyConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizationPolicyConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "AuthorizationPolicyConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizationPolicyConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "AuthorizationPolicyConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_TokenIntrospectConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTokenIntrospectConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "TokenIntrospectConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTokenIntrospectConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "TokenIntrospectConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_ConsentConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConsentConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "ConsentConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConsentConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "ConsentConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConfigDetail_IngestPipelineConfig:
		if v == nil {
			err := ConfigDetailValidationError{
				field:  "Configuration",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIngestPipelineConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigDetailValidationError{
						field:  "IngestPipelineConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIngestPipelineConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigDetailValidationError{
					field:  "IngestPipelineConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConfigDetailMultiError(errors)
	}

	return nil
}

// ConfigDetailMultiError is an error wrapping multiple validation errors
// returned by ConfigDetail.ValidateAll() if the designated constraints aren't met.
type ConfigDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigDetailMultiError) AllErrors() []error { return m }

// ConfigDetailValidationError is the validation error returned by
// ConfigDetail.Validate if the designated constraints aren't met.
type ConfigDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigDetailValidationError) ErrorName() string { return "ConfigDetailValidationError" }

// Error satisfies the builtin error interface
func (e ConfigDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigDetailValidationError{}

// Validate checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplicationAgentCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplicationAgentCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApplicationAgentCredentialConfigMultiError, or nil if none found.
func (m *ApplicationAgentCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplicationAgentCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplicationAgentCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplicationAgentCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApplicationAgentCredentialConfigMultiError(errors)
	}

	return nil
}

// ApplicationAgentCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by
// ApplicationAgentCredentialConfig.ValidateAll() if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationAgentCredentialConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationAgentCredentialConfigMultiError) AllErrors() []error { return m }

// ApplicationAgentCredentialConfigValidationError is the validation error
// returned by ApplicationAgentCredentialConfig.Validate if the designated
// constraints aren't met.
type ApplicationAgentCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationAgentCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationAgentCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationAgentCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationAgentCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationAgentCredentialConfigValidationError) ErrorName() string {
	return "ApplicationAgentCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ApplicationAgentCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplicationAgentCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationAgentCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationAgentCredentialConfigValidationError{}

// Validate checks the field values on ServiceAccountCredentialConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceAccountCredentialConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccountCredentialConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ServiceAccountCredentialConfigMultiError, or nil if none found.
func (m *ServiceAccountCredentialConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccountCredentialConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kid

	// no validation rules for KeyFormat

	// no validation rules for OriginalKid

	if all {
		switch v := interface{}(m.GetExpireTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceAccountCredentialConfigValidationError{
					field:  "ExpireTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceAccountCredentialConfigValidationError{
				field:  "ExpireTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceAccountCredentialConfigMultiError(errors)
	}

	return nil
}

// ServiceAccountCredentialConfigMultiError is an error wrapping multiple
// validation errors returned by ServiceAccountCredentialConfig.ValidateAll()
// if the designated constraints aren't met.
type ServiceAccountCredentialConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountCredentialConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountCredentialConfigMultiError) AllErrors() []error { return m }

// ServiceAccountCredentialConfigValidationError is the validation error
// returned by ServiceAccountCredentialConfig.Validate if the designated
// constraints aren't met.
type ServiceAccountCredentialConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountCredentialConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountCredentialConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountCredentialConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountCredentialConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountCredentialConfigValidationError) ErrorName() string {
	return "ServiceAccountCredentialConfigValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceAccountCredentialConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccountCredentialConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountCredentialConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountCredentialConfigValidationError{}

// Validate checks the field values on AuditSinkConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfigMultiError, or nil if none found.
func (m *AuditSinkConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Provider.(type) {
	case *AuditSinkConfig_Kafka_:
		if v == nil {
			err := AuditSinkConfigValidationError{
				field:  "Provider",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuditSinkConfigValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuditSinkConfigValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuditSinkConfigMultiError(errors)
	}

	return nil
}

// AuditSinkConfigMultiError is an error wrapping multiple validation errors
// returned by AuditSinkConfig.ValidateAll() if the designated constraints
// aren't met.
type AuditSinkConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfigMultiError) AllErrors() []error { return m }

// AuditSinkConfigValidationError is the validation error returned by
// AuditSinkConfig.Validate if the designated constraints aren't met.
type AuditSinkConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfigValidationError) ErrorName() string { return "AuditSinkConfigValidationError" }

// Error satisfies the builtin error interface
func (e AuditSinkConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfigValidationError{}

// Validate checks the field values on AuthorizationPolicyConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthorizationPolicyConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthorizationPolicyConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthorizationPolicyConfigMultiError, or nil if none found.
func (m *AuthorizationPolicyConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthorizationPolicyConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Policy

	// no validation rules for Status

	if len(errors) > 0 {
		return AuthorizationPolicyConfigMultiError(errors)
	}

	return nil
}

// AuthorizationPolicyConfigMultiError is an error wrapping multiple validation
// errors returned by AuthorizationPolicyConfig.ValidateAll() if the
// designated constraints aren't met.
type AuthorizationPolicyConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthorizationPolicyConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthorizationPolicyConfigMultiError) AllErrors() []error { return m }

// AuthorizationPolicyConfigValidationError is the validation error returned by
// AuthorizationPolicyConfig.Validate if the designated constraints aren't met.
type AuthorizationPolicyConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthorizationPolicyConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthorizationPolicyConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthorizationPolicyConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthorizationPolicyConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthorizationPolicyConfigValidationError) ErrorName() string {
	return "AuthorizationPolicyConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AuthorizationPolicyConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthorizationPolicyConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthorizationPolicyConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthorizationPolicyConfigValidationError{}

// Validate checks the field values on AssignConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssignConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssignConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssignConfigPermissionsMultiError, or nil if none found.
func (m *AssignConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *AssignConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return AssignConfigPermissionsMultiError(errors)
	}

	return nil
}

// AssignConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by AssignConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type AssignConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssignConfigPermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssignConfigPermissionsMultiError) AllErrors() []error { return m }

// AssignConfigPermissionsValidationError is the validation error returned by
// AssignConfigPermissions.Validate if the designated constraints aren't met.
type AssignConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssignConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssignConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssignConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssignConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssignConfigPermissionsValidationError) ErrorName() string {
	return "AssignConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e AssignConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssignConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssignConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssignConfigPermissionsValidationError{}

// Validate checks the field values on RevokeConfigPermissions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeConfigPermissions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeConfigPermissions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeConfigPermissionsMultiError, or nil if none found.
func (m *RevokeConfigPermissions) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeConfigPermissions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetIdentifier

	// no validation rules for TargetType

	// no validation rules for Role

	// no validation rules for CustomerId

	// no validation rules for ObjectId

	// no validation rules for ObjectType

	if len(errors) > 0 {
		return RevokeConfigPermissionsMultiError(errors)
	}

	return nil
}

// RevokeConfigPermissionsMultiError is an error wrapping multiple validation
// errors returned by RevokeConfigPermissions.ValidateAll() if the designated
// constraints aren't met.
type RevokeConfigPermissionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeConfigPermissionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeConfigPermissionsMultiError) AllErrors() []error { return m }

// RevokeConfigPermissionsValidationError is the validation error returned by
// RevokeConfigPermissions.Validate if the designated constraints aren't met.
type RevokeConfigPermissionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeConfigPermissionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeConfigPermissionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeConfigPermissionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeConfigPermissionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeConfigPermissionsValidationError) ErrorName() string {
	return "RevokeConfigPermissionsValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeConfigPermissionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeConfigPermissions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeConfigPermissionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeConfigPermissionsValidationError{}

// Validate checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfigMultiError, or nil if none found.
func (m *TokenIntrospectConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetClaimsMapping()))
		i := 0
		for key := range m.GetClaimsMapping() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetClaimsMapping()[key]
			_ = val

			// no validation rules for ClaimsMapping[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TokenIntrospectConfigValidationError{
							field:  fmt.Sprintf("ClaimsMapping[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TokenIntrospectConfigValidationError{
						field:  fmt.Sprintf("ClaimsMapping[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for IkgNodeType

	// no validation rules for PerformUpsert

	switch v := m.TokenMatcher.(type) {
	case *TokenIntrospectConfig_Jwt:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "TokenMatcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJwt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Jwt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJwt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Jwt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Validation.(type) {
	case *TokenIntrospectConfig_Offline_:
		if v == nil {
			err := TokenIntrospectConfigValidationError{
				field:  "Validation",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOffline()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenIntrospectConfigValidationError{
						field:  "Offline",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOffline()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenIntrospectConfigValidationError{
					field:  "Offline",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TokenIntrospectConfigMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfigMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig.ValidateAll() if the designated
// constraints aren't met.
type TokenIntrospectConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfigMultiError) AllErrors() []error { return m }

// TokenIntrospectConfigValidationError is the validation error returned by
// TokenIntrospectConfig.Validate if the designated constraints aren't met.
type TokenIntrospectConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfigValidationError) ErrorName() string {
	return "TokenIntrospectConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfigValidationError{}

// Validate checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatedConfig_Location) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatedConfig_Location with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatedConfig_LocationMultiError, or nil if none found.
func (m *CreatedConfig_Location) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatedConfig_Location) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	if len(errors) > 0 {
		return CreatedConfig_LocationMultiError(errors)
	}

	return nil
}

// CreatedConfig_LocationMultiError is an error wrapping multiple validation
// errors returned by CreatedConfig_Location.ValidateAll() if the designated
// constraints aren't met.
type CreatedConfig_LocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatedConfig_LocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatedConfig_LocationMultiError) AllErrors() []error { return m }

// CreatedConfig_LocationValidationError is the validation error returned by
// CreatedConfig_Location.Validate if the designated constraints aren't met.
type CreatedConfig_LocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatedConfig_LocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatedConfig_LocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatedConfig_LocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatedConfig_LocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatedConfig_LocationValidationError) ErrorName() string {
	return "CreatedConfig_LocationValidationError"
}

// Error satisfies the builtin error interface
func (e CreatedConfig_LocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatedConfig_Location.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatedConfig_LocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatedConfig_LocationValidationError{}

// Validate checks the field values on ReadConfig_NameIdentifier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadConfig_NameIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadConfig_NameIdentifier with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadConfig_NameIdentifierMultiError, or nil if none found.
func (m *ReadConfig_NameIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadConfig_NameIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LocationId

	// no validation rules for Name

	if m.LocationType != nil {
		// no validation rules for LocationType
	}

	if len(errors) > 0 {
		return ReadConfig_NameIdentifierMultiError(errors)
	}

	return nil
}

// ReadConfig_NameIdentifierMultiError is an error wrapping multiple validation
// errors returned by ReadConfig_NameIdentifier.ValidateAll() if the
// designated constraints aren't met.
type ReadConfig_NameIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadConfig_NameIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadConfig_NameIdentifierMultiError) AllErrors() []error { return m }

// ReadConfig_NameIdentifierValidationError is the validation error returned by
// ReadConfig_NameIdentifier.Validate if the designated constraints aren't met.
type ReadConfig_NameIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadConfig_NameIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadConfig_NameIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadConfig_NameIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadConfig_NameIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadConfig_NameIdentifierValidationError) ErrorName() string {
	return "ReadConfig_NameIdentifierValidationError"
}

// Error satisfies the builtin error interface
func (e ReadConfig_NameIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadConfig_NameIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadConfig_NameIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadConfig_NameIdentifierValidationError{}

// Validate checks the field values on AuditSinkConfig_Kafka with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuditSinkConfig_Kafka) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuditSinkConfig_Kafka with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuditSinkConfig_KafkaMultiError, or nil if none found.
func (m *AuditSinkConfig_Kafka) ValidateAll() error {
	return m.validate(true)
}

func (m *AuditSinkConfig_Kafka) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Topic

	// no validation rules for DisableTls

	// no validation rules for TlsSkipVerify

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return AuditSinkConfig_KafkaMultiError(errors)
	}

	return nil
}

// AuditSinkConfig_KafkaMultiError is an error wrapping multiple validation
// errors returned by AuditSinkConfig_Kafka.ValidateAll() if the designated
// constraints aren't met.
type AuditSinkConfig_KafkaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuditSinkConfig_KafkaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuditSinkConfig_KafkaMultiError) AllErrors() []error { return m }

// AuditSinkConfig_KafkaValidationError is the validation error returned by
// AuditSinkConfig_Kafka.Validate if the designated constraints aren't met.
type AuditSinkConfig_KafkaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuditSinkConfig_KafkaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuditSinkConfig_KafkaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuditSinkConfig_KafkaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuditSinkConfig_KafkaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuditSinkConfig_KafkaValidationError) ErrorName() string {
	return "AuditSinkConfig_KafkaValidationError"
}

// Error satisfies the builtin error interface
func (e AuditSinkConfig_KafkaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuditSinkConfig_Kafka.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuditSinkConfig_KafkaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuditSinkConfig_KafkaValidationError{}

// Validate checks the field values on TokenIntrospectConfig_JWT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_JWT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_JWT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_JWTMultiError, or nil if none found.
func (m *TokenIntrospectConfig_JWT) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_JWT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Issuer

	// no validation rules for Audience

	if len(errors) > 0 {
		return TokenIntrospectConfig_JWTMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_JWTMultiError is an error wrapping multiple validation
// errors returned by TokenIntrospectConfig_JWT.ValidateAll() if the
// designated constraints aren't met.
type TokenIntrospectConfig_JWTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_JWTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_JWTMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_JWTValidationError is the validation error returned by
// TokenIntrospectConfig_JWT.Validate if the designated constraints aren't met.
type TokenIntrospectConfig_JWTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_JWTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_JWTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_JWTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_JWTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_JWTValidationError) ErrorName() string {
	return "TokenIntrospectConfig_JWTValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_JWTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_JWT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_JWTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_JWTValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Offline with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Offline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Offline with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_OfflineMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Offline) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Offline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TokenIntrospectConfig_OfflineMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_OfflineMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Offline.ValidateAll()
// if the designated constraints aren't met.
type TokenIntrospectConfig_OfflineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_OfflineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_OfflineMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_OfflineValidationError is the validation error
// returned by TokenIntrospectConfig_Offline.Validate if the designated
// constraints aren't met.
type TokenIntrospectConfig_OfflineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_OfflineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_OfflineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_OfflineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_OfflineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_OfflineValidationError) ErrorName() string {
	return "TokenIntrospectConfig_OfflineValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_OfflineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Offline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_OfflineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_OfflineValidationError{}

// Validate checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenIntrospectConfig_Claim) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenIntrospectConfig_Claim with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenIntrospectConfig_ClaimMultiError, or nil if none found.
func (m *TokenIntrospectConfig_Claim) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenIntrospectConfig_Claim) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Selector

	if len(errors) > 0 {
		return TokenIntrospectConfig_ClaimMultiError(errors)
	}

	return nil
}

// TokenIntrospectConfig_ClaimMultiError is an error wrapping multiple
// validation errors returned by TokenIntrospectConfig_Claim.ValidateAll() if
// the designated constraints aren't met.
type TokenIntrospectConfig_ClaimMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenIntrospectConfig_ClaimMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenIntrospectConfig_ClaimMultiError) AllErrors() []error { return m }

// TokenIntrospectConfig_ClaimValidationError is the validation error returned
// by TokenIntrospectConfig_Claim.Validate if the designated constraints
// aren't met.
type TokenIntrospectConfig_ClaimValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenIntrospectConfig_ClaimValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenIntrospectConfig_ClaimValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenIntrospectConfig_ClaimValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenIntrospectConfig_ClaimValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenIntrospectConfig_ClaimValidationError) ErrorName() string {
	return "TokenIntrospectConfig_ClaimValidationError"
}

// Error satisfies the builtin error interface
func (e TokenIntrospectConfig_ClaimValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenIntrospectConfig_Claim.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenIntrospectConfig_ClaimValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenIntrospectConfig_ClaimValidationError{}
